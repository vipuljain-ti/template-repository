schema {
  query: Query
  mutation: Mutation
}

type Query {
  "List assignable groups and agents based on query matched against name\n\n#### Allowed For\n\n* Agents\n"
  ListAssigneeFieldAssignableGroupsAndAgentsSearch(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Query string used to search assignable groups & agents in the AssigneeField"
    name: String!
  ): AssigneeFieldAssignableGroupsAndAgentsSearchResponse
  "List assignable groups on the AssigneeField\n\n#### Allowed For\n\n* Agents\n"
  ListAssigneeFieldAssignableGroups(subdomain: String = "example", domain: String = "zendesk"): AssigneeFieldAssignableGroupsResponse
  "List assignable agents from a group on the AssigneeField\n\n#### Allowed For\n\n* Agents\n"
  ListAssigneeFieldAssignableGroupAgents(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the group"
    group_id: Int!
  ): AssigneeFieldAssignableGroupAgentsResponse
  "Returns a list of source objects whose values are populated with the id of a related target object.  For example,\nif you have a lookup field called \"Success Manager\" on a ticket, this endpoint can answer the question,\n\"What tickets (sources) is this user (found by `target_type` and `target_id`)\nassigned as the 'Success Manager' (field referenced by `field_id`)?\"\n\n#### Allowed For\n\n* Agents\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n"
  GetSourcesByTarget(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The type of object the relationship field is targeting.\nThe options are \"zen:user\", \"zen:ticket\", \"zen:organization\", and \"zen:custom_object:CUSTOM_OBJECT_KEY\""
    target_type: String!
    "The id of the object the relationship field is targeting"
    target_id: Int!
    "The id of the lookup relationship field"
    field_id: Int!
    "The type of object the relationship field belongs to (example. ticket field belongs to a ticket object).\nThe options are \"zen:user\", \"zen:ticket\", \"zen:organization\", and \"zen:custom_object:CUSTOM_OBJECT_KEY\""
    source_type: String!
  ): ReverseLookupResponse
  "Shows the settings that are available for the account.\n\n#### Allowed For\n\n* Agents\n"
  ShowAccountSettings(subdomain: String = "example", domain: String = "zendesk"): AccountSettingsResponse
  "Zendesk Support credentials are not required to access this endpoint. You can use any Zendesk Support subdomain.\n\nReturns \"true\" if the subdomain is available.\n"
  VerifySubdomainAvailability(
    "Specify the name of the subdomain you want to verify. The name can't contain underscores, hyphens, or spaces."
    subdomain: String!
    domain: String = "zendesk"
  ): VerifySubdomainAvailability_200_response
  "Lists ticket activities in the last 30 days affecting the agent making the request.\nAlso sideloads the following arrays of user records:\n\n- actors - All actors involved in the listed activities\n- users - All users involved in the listed activities\n\n#### Pagination\n\n- Cursor pagination (recommended)\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Agents\n"
  ListActivities(
    subdomain: String = "example"
    domain: String = "zendesk"
    "A UTC time in ISO 8601 format to return ticket activities since said date."
    since: String
  ): ActivitiesResponse
  "Lists a specific activity.\n\n#### Allowed For\n\n* Agents\n"
  ShowActivity(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The activity ID"
    activity_id: Int!
  ): ActivityResponse
  "Returns an approximate count of ticket activities in the last 30 days affecting the agent making the request. If the count exceeds 100,000, the count will return a cached result. This cached result will update every 24 hours.\n\nThe `count[refreshed_at]` property is a timestamp that indicates when the count was last updated.\n\n**Note**: When the count exceeds 100,000, `count[refreshed_at]` may occasionally be null.\nThis indicates that the count is being updated in the background, and `count[value]` is limited to 100,000 until the update is complete.\n\n#### Allowed For\n* Agents"
  CountActivities(subdomain: String = "example", domain: String = "zendesk"): ActivitiesCountResponse
  "Shows attachment details. You can get the value of the `attachment_id` parameter by listing the ticket's comments.\nSee [List Comments](/api-reference/ticketing/tickets/ticket_comments/#list-comments). Each comment\nin the list has an `attachments` list that specifies an `id` for each attachment.\n\n\n #### Allowed for\n\n * Agents\n"
  ShowAttachment(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the attachment"
    attachment_id: Int!
  ): AttachmentResponse
  "#### Allowed For\n\n* Admins on accounts that have audit log access\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n"
  ListAuditLogs(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Filter audit logs by the source type. For example, user or rule"
    filter_LEFT_SQUARE_BRACE_source_type_RIGHT_SQUARE_BRACE_: String
    "Filter audit logs by the source id. Requires `filter[source_type]` to also be set"
    filter_LEFT_SQUARE_BRACE_source_id_RIGHT_SQUARE_BRACE_: Int
    "Filter audit logs by the actor id"
    filter_LEFT_SQUARE_BRACE_actor_id_RIGHT_SQUARE_BRACE_: Int
    "Filter audit logs by the ip address"
    filter_LEFT_SQUARE_BRACE_ip_address_RIGHT_SQUARE_BRACE_: String
    "Filter audit logs by the time of creation. When used, you must specify `filter[created_at]` twice in your request, first with the start time and again with an end time"
    filter_LEFT_SQUARE_BRACE_created_at_RIGHT_SQUARE_BRACE_: String
    "Filter audit logs by the action"
    filter_LEFT_SQUARE_BRACE_action_RIGHT_SQUARE_BRACE_: String
    "Offset pagination only. Sort audit logs. Default is `sort_by=created_at`"
    sort_by: String
    "Offset pagination only. Sort audit logs. Default is `sort_order=desc`"
    sort_order: String
    "Cursor pagination only. Sort audit logs. Default is `sort=-created_at`"
    sort: String
  ): AuditLogsResponse
  "#### Allowed For\n\n* Admins on accounts that have audit-log access\n"
  ShowAuditLog(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the audit log"
    audit_log_id: Int!
  ): AuditLogResponse
  "Returns an array of registered and recent tag names that start with the characters specified in the `name` query parameter. You must specify at least 2 characters.\n\n#### Pagination\n\n* Offset pagination only\n\nSee [Using Offset Pagination](/api-reference/ticketing/introduction/#using-offset-pagination).\n\n\n#### Allowed For\n\n* Agents\n"
  AutocompleteTags(
    subdomain: String = "example"
    domain: String = "zendesk"
    "A substring of a tag to search for"
    name: String
  ): TagsByObjectIdResponse
  "Lists all automations for the current account.\n\n#### Allowed For\n\n* Agents\n\n#### Available Parameters\n\nYou can pass in any combination of the following optional filters:\n\n| Name       | Type    | Comment\n| ---------- | ------- | -------\n| active     | boolean | Only active automations if true, inactive automations if false\n| sort_by    | string  | Possible values are \"alphabetical\", \"created_at\", \"updated_at\", \"usage_1h\", \"usage_24h\", or \"usage_7d\". Defaults to \"position\"\n| sort_order | string  | One of \"asc\" or \"desc\". Defaults to \"asc\" for alphabetical and position sort, \"desc\" for all others\n\n#### Sideloads\n\nThe following sideloads are supported. The usage sideloads are only supported on the Support Professional or Suite Growth plan or above.\n\n| Name             | Will sideload\n| ---------------- | -------------\n| app_installation | The app installation that requires each automation, if present\n| permissions      | The permissions for each automation\n| usage_1h         | The number of times each automation has been used in the past hour\n| usage_24h        | The number of times each automation has been used in the past day\n| usage_7d         | The number of times each automation has been used in the past week\n| usage_30d        | The number of times each automation has been used in the past thirty days\n\n#### Pagination\n\n- Cursor pagination (recommended)\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n"
  ListAutomations(subdomain: String = "example", domain: String = "zendesk"): AutomationsResponse
  "#### Allowed For\n\n* Agents\n"
  ShowAutomation(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the automation"
    automation_id: Int!
  ): AutomationResponse
  "Lists all active automations.\n\n#### Allowed For\n\n* Agents\n\n#### Available Parameters\n\nYou can pass in any combination of the following optional filters:\n\n| Name       | Type   | Comment\n| ---------- | ------ | -------\n| sort_by    | string | Possible values are \"alphabetical\", \"created_at\", \"updated_at\", \"usage_1h\", \"usage_24h\", or \"usage_7d\". Defaults to \"position\"\n| sort_order | string | One of \"asc\" or \"desc\". Defaults to \"asc\" for alphabetical and position sort, \"desc\" for all others\n\n#### Sideloads\n\nThe following sideloads are supported:\n\n| Name             | Will sideload\n| ---------------- | -------------\n| app_installation | The app installation that requires each automation, if present\n| permissions      | The permissions for each automation\n| usage_1h         | The number of times each automation has been used in the past hour\n| usage_24h        | The number of times each automation has been used in the past day\n| usage_7d         | The number of times each automation has been used in the past week\n| usage_30d        | The number of times each automation has been used in the past thirty days\n"
  ListActiveAutomations(subdomain: String = "example", domain: String = "zendesk"): AutomationsResponse
  "#### Pagination\n\n* Offset pagination only\n\nSee [Using Offset Pagination](/api-reference/ticketing/introduction/#using-offset-pagination).\n\n#### Allowed For\n\n* Agents\n\n#### Sideloads\n\nThe following sideloads are supported. For more information, see [Side-loading](/documentation/ticketing/using-the-zendesk-api/side_loading/).\n\n| Name             | Will sideload\n| ---------------- | -------------\n| app_installation | The app installation that requires each automation, if present\n| permissions      | The permissions for each automation\n| usage_1h         | The number of times each automation has been used in the past hour\n| usage_24h        | The number of times each automation has been used in the past day\n| usage_7d         | The number of times each automation has been used in the past week\n| usage_30d        | The number of times each automation has been used in the past thirty days\n"
  SearchAutomations(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Query string used to find all automations with matching title"
    query: String!
    "Filter by active automations if true or inactive automations if false"
    active: Boolean
    "Possible values are \"alphabetical\", \"created_at\", \"updated_at\", and \"position\". If unspecified, the automations are sorted by relevance"
    sort_by: String
    "One of \"asc\" or \"desc\". Defaults to \"asc\" for alphabetical and position sort, \"desc\" for all others"
    sort_order: String
    "A sideload to include in the response. See [Sideloads](#sideloads-2)"
    include: String
  ): AutomationsResponse
  "#### Allowed For\n- Agents"
  ListBookmarks(subdomain: String = "example", domain: String = "zendesk"): BookmarksResponse
  "Returns a list of all brands for your account sorted by name.\n\n#### Allowed for\n\n* Admins, Agents\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/)."
  ListBrands(subdomain: String = "example", domain: String = "zendesk"): BrandsResponse
  "Returns a brand for your account.\n\n#### Allowed for\n\n* Admins, Agents"
  ShowBrand(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the brand"
    brand_id: Int!
  ): BrandResponse
  "Returns a JSON object determining whether a host mapping is valid for the given brand.\n\n#### Allowed for\n- Admins"
  CheckHostMappingValidityForExistingBrand(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the brand"
    brand_id: Int!
  ): Host_Mapping
  "Returns a JSON object determining whether a host mapping is valid for a given subdomain.\n\n#### Allowed for\n\n* Admins"
  CheckHostMappingValidity(
    "Subdomain for a given Zendesk account address"
    subdomain: String!
    domain: String = "zendesk"
    "The hostmapping to a brand, if any (only admins view this key)"
    host_mapping: String!
  ): Host_Mapping
  "#### Allowed For\n\n* Admins\n* Agents\n"
  ListMonitoredTwitterHandles(subdomain: String = "example", domain: String = "zendesk"): TwitterChannelsResponse
  "#### Allowed For\n\n* Admins\n* Agents\n"
  ShowMonitoredTwitterHandle(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the custom agent role"
    monitored_twitter_handle_id: Int!
  ): TwitterChannelResponse
  "#### Allowed For\n\n* Agents\n"
  GettingTwicketStatus(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the comment"
    comment_id: Int!
    "Optional comment ids to retrieve tweet information for only particular comments"
    ids: String
  ): TwitterChannelTwicketStatusResponse
  "Lists all undeleted custom objects for the account\n#### Allowed For\n* Agents"
  ListCustomObjects(subdomain: String = "example", domain: String = "zendesk"): CustomObjectsResponse
  "Returns an object with the specified key\n#### Allowed For\n* Agents\n"
  ShowCustomObject(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
  ): CustomObjectResponse
  "Lists all undeleted custom fields for the specified object.\n\n#### Allowed For\n* Agents\n\n#### Pagination\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/)."
  ListCustomObjectFields(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
    "Include standard fields if true. Exclude them if false"
    include_standard_fields: Boolean
  ): CustomObjectFieldsResponse
  "Returns a custom field for a specific object using a provided key or id of the field.\n#### Allowed For\n* Agents\n"
  ShowCustomObjectField(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
    "The key or id of a custom object field"
    custom_object_field_key_or_id: String!
  ): CustomObjectFieldResponse
  "List the current count and the limit for a custom object's fields\n#### Allowed For\n* Agents"
  CustomObjectFieldsLimit(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
  ): CustomObjectLimitsResponse
  "Lists all undeleted custom object records for the specified object\n\n #### Pagination\n\n* [Cursor pagination](/api-reference/introduction/pagination/#cursor-pagination) only.\n#### Allowed For\n* Agents"
  ListCustomObjectRecords(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
    "Optional comma-separated list of ids to filter records by. If one or more ids are specified, only matching records are returned. The ids must be unique and are case sensitive."
    filter_LEFT_SQUARE_BRACE_ids_RIGHT_SQUARE_BRACE_: String
    "Optional comma-separated list of external ids to filter records by. If one or more ids are specified, only matching records are returned. The ids must be unique and are case sensitive."
    filter_LEFT_SQUARE_BRACE_external_ids_RIGHT_SQUARE_BRACE_: String
    "One of `id`, `updated_at`, `-id`, or `-updated_at`. The `-` denotes the sort will be descending."
    sort: String
    "A [pagination cursor](/documentation/api-basics/pagination/paginating-through-lists-using-cursor-pagination) that tells the endpoint which page to start on. It should be a `meta.before_cursor` value from a previous request. Note: `page[before]` and `page[after]` can't be used together in the same request."
    page_LEFT_SQUARE_BRACE_before_RIGHT_SQUARE_BRACE_: String
    "A [pagination cursor](/documentation/api-basics/pagination/paginating-through-lists-using-cursor-pagination) that tells the endpoint which page to start on. It should be a `meta.after_cursor` value from a previous request. Note: `page[before]` and `page[after]` can't be used together in the same request."
    page_LEFT_SQUARE_BRACE_after_RIGHT_SQUARE_BRACE_: String
    "Specifies how many records should be returned in the response. You can specify up to 100 records per page."
    page_LEFT_SQUARE_BRACE_size_RIGHT_SQUARE_BRACE_: Int
  ): CustomObjectRecordsResponse
  "Returns a custom record for a specific object using a provided id.\n#### Allowed For\n* Agents\n"
  ShowCustomObjectRecord(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
    "The id of a custom object record"
    custom_object_record_id: String!
  ): CustomObjectRecordResponse
  "Retrieves an array of custom object records that have a field value that matches the value specified in the `name` parameter.\n\n#### Pagination\n\n* [Cursor pagination](/api-reference/introduction/pagination/#cursor-pagination) only.\n* Returns the first 10,000 records sorted by relevancy with page limits.\n#### Allowed For\n* Agents"
  AutocompleteCustomObjectRecordSearch(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
    "Part of a name of the record you are searching for"
    name: String
    "A [pagination cursor](/documentation/api-basics/pagination/paginating-through-lists-using-cursor-pagination) that tells the endpoint which page to start on. It should be a `meta.before_cursor` value from a previous request. Note: `page[before]` and `page[after]` can't be used together in the same request."
    page_LEFT_SQUARE_BRACE_before_RIGHT_SQUARE_BRACE_: String
    "A [pagination cursor](/documentation/api-basics/pagination/paginating-through-lists-using-cursor-pagination) that tells the endpoint which page to start on. It should be a `meta.after_cursor` value from a previous request. Note: `page[before]` and `page[after]` can't be used together in the same request."
    page_LEFT_SQUARE_BRACE_after_RIGHT_SQUARE_BRACE_: String
    "The number of records to return in the response. You can specify up to 100 records per page."
    page_LEFT_SQUARE_BRACE_size_RIGHT_SQUARE_BRACE_: Int
    "The id of the lookup field. If the field has a relationship filter, the filter is applied to the results. Must be used with `source` param."
    field_id: String
    "One of \"zen:user\", \"zen:ticket\", \"zen:organization\", or \"zen:custom_object:CUSTOM_OBJECT_KEY\". Represents the object `field_id` belongs to. Must be used with field_id param."
    source: String
    "The id of the requester. For use with dynamic filters."
    requester_id: Int
    "The id of the selected assignee. For use with dynamic filters."
    assignee_id: Int
    "The id of the organization the requester belongs to. For use with dynamic filters."
    organization_id: Int
  ): CustomObjectRecordsResponse
  "Returns a total count of records for a specific custom object as well as the time the count was refreshed.\n#### Allowed For\n* Agents"
  CountCustomObjectRecords(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
  ): CountCustomObjectRecords_200_response
  "Returns an array of custom object records that meet the search criteria\n\n#### Pagination\n\n* [Cursor pagination](/api-reference/introduction/pagination/#cursor-pagination) only.\n* Returns the records sorted by relevancy with page limits. Without a `sort` parameter, only the first 10,000 records are returned. With a `sort` parameter, all records are returned.\n#### Allowed For\n* Agents"
  SearchCustomObjectRecords(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
    "The query parameter is used to search text-based fields for records that match specific query terms.\nThe query can be multiple words or numbers. Every record that matches the beginning of any word or number in the query string is returned.<br/><br/>\n\nFuzzy search is supported for the following text-based field types: : Text fields, Multi Line Text fields, and RegExp fields.<br/><br/>\n\nFor example, you might want to search for records related to Tesla vehicles: `query=Tesla`. In this example the API would return every record for the given custom object where any of the supported text fields contain the word 'Tesla'.<br/><br/>\n\nYou can include multiple words or numbers in your search. For example: `query=Tesla Honda 2020`. This search phrase would be URL encoded as `query=Tesla%20Honda%202020` and return every record for the custom object for which any of the supported text fields contained 'Tesla', 'Honda', or '2020'."
    query: String
    "One of `name`, `created_at`, `updated_at`, `-name`, `-created_at`, or `-updated_at`. The `-` denotes the sort will be descending. Defaults to sorting by relevance."
    sort: String
    "A [pagination cursor](/documentation/api-basics/pagination/paginating-through-lists-using-cursor-pagination) that tells the endpoint which page to start on. It should be a `meta.before_cursor` value from a previous request. Note: `page[before]` and `page[after]` can't be used together in the same request."
    page_LEFT_SQUARE_BRACE_before_RIGHT_SQUARE_BRACE_: String
    "A [pagination cursor](/documentation/api-basics/pagination/paginating-through-lists-using-cursor-pagination) that tells the endpoint which page to start on. It should be a `meta.after_cursor` value from a previous request. Note: `page[before]` and `page[after]` can't be used together in the same request."
    page_LEFT_SQUARE_BRACE_after_RIGHT_SQUARE_BRACE_: String
    "Specifies how many records should be returned in the response. You can specify up to 100 records per page."
    page_LEFT_SQUARE_BRACE_size_RIGHT_SQUARE_BRACE_: Int
  ): CustomObjectRecordsResponse
  "List the current count and the limit for custom objects\n#### Allowed For\n* Admins"
  CustomObjectsLimit(subdomain: String = "example", domain: String = "zendesk"): CustomObjectLimitsResponse
  "List the current count and the limit for custom object records\n#### Allowed For\n* Agents"
  CustomObjectRecordsLimit(subdomain: String = "example", domain: String = "zendesk"): CustomObjectLimitsResponse
  "#### Availability\n\n* Accounts on the Enterprise plan or above\n\n#### Allowed For\n\n* Agents\n"
  ListCustomRoles(subdomain: String = "example", domain: String = "zendesk"): CustomRolesResponse
  "#### Availability\n\n* Accounts on the Enterprise plan or above\n\n#### Allowed for\n\n* Administrators\n* Agents with the `manage_roles` permission\n"
  ShowCustomRoleById(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the custom agent role"
    custom_role_id: Int!
  ): CustomRoleResponse
  "Lists all undeleted custom ticket statuses for the account. No pagination is provided.\n\n#### Allowed For\n\n* End Users\n"
  ListCustomStatuses(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Filter the list of custom ticket statuses by a comma-separated list of status categories"
    status_categories: String
    "If true, show only active custom ticket statuses. If false, show only inactive custom ticket statuses. If the filter is not used, show all custom ticket statuses"
    active: Boolean
    "If true, show only default custom ticket statuses. If false, show only non-default custom ticket statuses. If the filter is not used, show all custom ticket statuses"
    default: Boolean
  ): CustomStatusesResponse
  "Returns the custom ticket status object.\n\n#### Allowed For\n\n* End Users\n"
  ShowCustomStatus(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the custom status"
    custom_status_id: Int!
  ): CustomStatusResponse
  "Returns a maximum of 100 deleted tickets per page. See [Pagination](/api-reference/introduction/pagination/).\n\nThe results includes all deleted (and not yet archived) tickets that\nhave not yet been [scrubbed](https://support.zendesk.com/hc/en-us/articles/4408845703194#topic_fv5_w51_sdb) in the past 30 days. Archived tickets are\nnot included in the results. See [About archived tickets](https://support.zendesk.com/hc/en-us/articles/203657756)\nin the Support Help Center.\n\nThe tickets are ordered chronologically by created date, from oldest to newest.\nThe first ticket listed may not be the oldest ticket in your\naccount due to [ticket archiving](https://support.zendesk.com/hc/en-us/articles/203657756).\n\n#### Pagination\n\n- Cursor pagination (recommended)\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Agents\n\n#### Rate Limit\n\nYou can make 10 requests every 1 minute using this endpoint.\nWhen making requests beyond page 100, you can make 5 requests every 1 minute.\nThe rate limiting mechanism behaves as described in\n[Monitoring your request activity](/api-reference/ticketing/account-configuration/usage_limits/#monitoring-your-request-activity) in the API introduction."
  ListDeletedTickets(subdomain: String = "example", domain: String = "zendesk", sort_by: TicketSortBy_parameter, sort_order: TicketSortOrder_parameter): ListDeletedTicketsResponse
  "Returns deleted users, including permanently deleted users.\n\nIf the results contains permanently deleted users, the users' properties\nthat normally contain personal data, such as `email` and `phone`,\nare null. The `name` property is \"Permanently Deleted User\".\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Agents\n"
  ListDeletedUsers(subdomain: String = "example", domain: String = "zendesk"): DeletedUsersResponse
  "Returns users that have been deleted but not permanently yet. See [Permanently Delete User](#permanently-delete-user).\n\n#### Allowed For:\n\n* Agents\n"
  ShowDeletedUser(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the deleted user"
    deleted_user_id: Int!
  ): DeletedUserResponse
  "Returns an approximate count of deleted users, including permanently deleted users. If the count exceeds 100,000, it is updated every 24 hours.\n\nThe response includes a `refreshed_at` property in a `count` object that contains a timestamp indicating when the count was last updated.\n\n**Note**: When the count exceeds 100,000, `count[refreshed_at]` may occasionally be null.\nThis indicates that the count is being updated in the background, and `count[value]` is limited to 100,000 until the update is complete.\n\n#### Allowed For\n\n* Agents\n"
  CountDeletedUsers(subdomain: String = "example", domain: String = "zendesk"): CountResponse
  "Returns a list of all dynamic content items for your account if accessed as an admin or agents who have permission to manage dynamic content.\n\n#### Allowed For\n\n* Admins, Agents\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n"
  ListDynamicContents(subdomain: String = "example", domain: String = "zendesk"): DynamicContentsResponse
  "#### Allowed For\n\n* Admins, Agents\n"
  ShowDynamicContentItem(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the dynamic content item"
    dynamic_content_item_id: Int!
  ): DynamicContentResponse
  "Returns all the variants of the specified dynamic content item.\n\n#### Allowed For\n\n* Admins\n* Agents who have permission to manage dynamic content\n\n#### Pagination\n\n* Cursor pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n"
  DynamicContentListVariants(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the dynamic content item"
    dynamic_content_item_id: Int!
  ): DynamicContentVariantsResponse
  "#### Allowed For\n\n* Admins, Agents\n"
  ShowDynamicContentVariant(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the dynamic content item"
    dynamic_content_item_id: Int!
    "The ID of the variant"
    dynammic_content_variant_id: Int!
  ): DynamicContentVariantResponse
  "#### Stability\n\n* Development\n\n#### Allowed For\n\n* Admins, Agents\n"
  ShowManyDynamicContents(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Identifiers for the dynamic contents"
    identifiers: String
  ): DynamicContentsResponse
  "#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For:\n\n* Agents\n"
  ListGroupMemberships(subdomain: String = "example", domain: String = "zendesk"): GroupMembershipsResponse
  "The 'id' is the group membership id, not a group id.\n\n#### Allowed For\n\n* Agents\n"
  ShowGroupMembershipById(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the group membership"
    group_membership_id: Int!
  ): GroupMembershipResponse
  "Returns a maximum of 100 group memberships per page.\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For:\n\n* Agents\n"
  ListAssignableGroupMemberships(subdomain: String = "example", domain: String = "zendesk"): GroupMembershipsResponse
  "#### Allowed For\n\n* Admins\n"
  ListGroupSLAPolicies(subdomain: String = "example", domain: String = "zendesk"): GroupSLAPoliciesResponse
  "#### Allowed For\n\n* Admins\n"
  ShowGroupSLAPolicy(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the Group SLA policy"
    group_sla_policy_id: Int!
  ): GroupSLAPolicyResponse
  "#### Allowed For\n\n* Admins\n"
  RetrieveGroupSLAPolicyFilterDefinitionItems(subdomain: String = "example", domain: String = "zendesk"): GroupSLAPolicyFilterDefinitionResponse
  "#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Admins\n* Agents\n"
  ListGroups(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Whether to exclude deleted entities"
    exclude_deleted: Boolean
  ): GroupsResponse
  "#### Allowed For\n\n* Admins\n* Agents\n"
  ShowGroupById(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the group"
    group_id: Int!
  ): GroupResponse
  "#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Admins\n* Agents\n"
  ListAssignableGroups(subdomain: String = "example", domain: String = "zendesk"): GroupsResponse
  "Returns an approximate count of groups. If the count exceeds 100,000, it is updated every 24 hours.\n\nThe `refreshed_at` property of the `count` object is a timestamp that indicates when the count was last updated.\n\n**Note**: When the count exceeds 100,000, `refreshed_at` may occasionally be null. This indicates that the count is being updated in the background, and the `value` property of the `count` object is limited to 100,000 until the update is complete.\n\n#### Allowed For\n\n* Admins\n* Agents\n"
  CountGroups(subdomain: String = "example", domain: String = "zendesk"): GroupsCountObject
  "Use this endpoint to test the incremental export format. It's more strict in terms of rate limiting,\nat 10 requests per 20 minutes instead of 10 requests per minute. It also returns only up to 50\nresults per request. Otherwise, it's identical to the above APIs.\n\nUse the `incremental_resource` parameter to specify the resource. Possible values are \"tickets\", \"ticket_events\", \"users\", or \"organizations\".\n"
  IncrementalSampleExport(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The resource requested for incremental sample export"
    incremental_resource: String!
    "The time to start the incremental export from. Must be at least one minute in the past. Data isn't provided for the most recent minute"
    start_time: Int!
  ): TimeBasedExportIncrementalTicketsResponse
  "#### Allowed For\n\n * Admins\n\n#### Sideloading\n\nSee [Organizations sideloads](/documentation/ticketing/using-the-zendesk-api/side_loading/#supported-endpoints).\n"
  IncrementalOrganizationExport(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The time to start the incremental export from. Must be at least one minute in the past. Data isn't provided for the most recent minute"
    start_time: Int!
  ): ExportIncrementalOrganizationsResponse
  "Returns a stream of changes that occurred on routing attribute values.\n\n#### Allowed For\n\n* Admins\n\n#### Parameters\n\nOptional\n\n| Name   | Type   | Comment\n| ------ | ------ | -------\n| cursor | string | The `cursor` parameter is a non-human-readable argument you can use to move forward or backward in time. The cursor is a read-only URL parameter that's only available in API responses. See [Pagination](#pagination).\n"
  IncrementalSkilBasedRoutingAttributeValuesExport(subdomain: String = "example", domain: String = "zendesk"): Incremental_Skill_based_Routing
  "Returns a stream of changes that occurred on routing attributes.\n\n#### Allowed For\n\n* Admins\n\n#### Parameters\n\nOptional\n\n\n| Name   | Type   | Comment\n| ------ | ------ | -------\n| cursor | string | The `cursor` parameter is a non-human-readable argument you can use to move forward or backward in time. The cursor is a read-only URL parameter that's only available in API responses. See [Pagination](#pagination).\n"
  IncrementalSkilBasedRoutingAttributesExport(subdomain: String = "example", domain: String = "zendesk"): Incremental_Skill_based_Routing
  "Returns a stream of changes that occurred on routing instance values. Changes are grouped by `attribute_value_id`,\nwith unassociate type events listed with associate type events by the associate eventâ€™s timestamp.\n\n#### Allowed For\n\n* Admins\n\n#### Parameters\n\nOptional\n\n| Name   | Type   | Comment\n| ------ | ------ | -------\n| cursor | string | The `cursor` parameter is a non-human-readable argument you can use to move forward or backward in time. The cursor is a read-only URL parameter that's only available in API responses. See [Pagination](#pagination).\n"
  IncrementalSkilBasedRoutingInstanceValuesExport(subdomain: String = "example", domain: String = "zendesk"): Incremental_Skill_based_Routing
  "Returns a stream of changes that occurred on tickets. Each event is tied\nto an update on a ticket and contains all the fields that were updated in that\nchange. For more information, see:\n\n- [Exporting ticket events](/documentation/ticketing/managing-tickets/using-the-incremental-export-api#exporting-ticket-events) in [Using the Incremental Exports API](/documentation/ticketing/managing-tickets/using-the-incremental-export-api)\n- [Time-based incremental exports](/documentation/ticketing/managing-tickets/using-the-incremental-export-api#time-based-incremental-exports) in [Using the Incremental Exports API](/documentation/ticketing/managing-tickets/using-the-incremental-export-api)\n\nYou can include comments in the event stream by using the `comment_events`\nsideload. See Sideloading below. If you don't specify the sideload, any comment\npresent in the ticket update is described only by Boolean `comment_present`\nand `comment_public` object properties in the event's `child_events` array.\nThe comment itself is not included.\n\n#### Allowed For\n\n * Admins\n\n#### Sideloading\n\nThe endpoint supports the `comment_events` sideload. Any comment present in the ticket\nupdate is listed as an object in the event's `child_events` array. Example:\n\n```js\n\"child_events\": [\n  {\n    \"id\": 91048994488,\n    \"via\": {\n      \"channel\": \"api\",\n      \"source\": {\"from\":{},\"to\":{},\"rel\":null}},\n    \"via_reference_id\":null,\n    \"type\": \"Comment\",\n    \"author_id\": 5031726587,\n    \"body\": \"This is a comment\",\n    \"html_body\": \"&lt;div class=\"zd-comment\"&gt;&lt;p dir=\"auto\"&gt;This is a comment&lt;/p&gt;\",\n    \"public\": true,\n    \"attachments\": [],\n    \"audit_id\": 91048994468,\n    \"created_at\": \"2009-06-25T10:15:18Z\",\n    \"event_type\": \"Comment\"\n  },\n  ...\n],\n...\n```\n"
  IncrementalTicketEvents(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The time to start the incremental export from. Must be at least one minute in the past. Data isn't provided for the most recent minute"
    start_time: Int!
  ): ExportIncrementalTicketEventsResponse
  "Returns ticket metric events that occurred on or after the start time.\n\nCursor pagination returns a maximum of 100 records per page. Events are listed in chronological order.\n\nIf the results are not paginated, events will be returned as a time-based incremental export.\n\nSee [Time-based incremental exports](/documentation/ticketing/managing-tickets/using-the-incremental-export-api#time-based-incremental-exports).\n\n#### Pagination\n* Cursor pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\n#### Allowed For\n\n* Admins"
  ListTicketMetricEvents(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The Unix UTC epoch time of the oldest event you're interested in. Example: 1332034771."
    start_time: Int!
  ): TicketMetricEventsResponse
  "Returns the tickets that changed since the start time. For more information,\nsee [Exporting tickets](/documentation/ticketing/managing-tickets/using-the-incremental-export-api#exporting-tickets) in [Using the Incremental Exports API](/documentation/ticketing/managing-tickets/using-the-incremental-export-api).\n\nThis endpoint supports time-based incremental exports.\nFor more information, see [Time-based incremental exports](/documentation/ticketing/managing-tickets/using-the-incremental-export-api#time-based-incremental-exports) in [Using the Incremental Exports API](/documentation/ticketing/managing-tickets/using-the-incremental-export-api). You can also return tickets using cursor-based pagination. See [Incremental Ticket Export, Cursor Based](#incremental-ticket-export-cursor-based).\n\nThe results include tickets that were updated by the system. See\n[Excluding system-updated tickets](/documentation/ticketing/managing-tickets/using-the-incremental-export-api#excluding-system-updated-tickets-time-based-exports) in [Using the Incremental Exports API](/documentation/ticketing/managing-tickets/using-the-incremental-export-api).\n\nThe endpoint can return tickets with an `updated_at` time that's earlier than the\n`start_time` time. The reason is that the API compares the `start_time` with the ticket's\n`generated_timestamp` value, not its `updated_at` value. The `updated_at` value is\nupdated only if the update generates a [ticket event](#incremental-ticket-event-export).\nThe `generated_timestamp` value is updated for all ticket updates, including system\nupdates. If a system update occurs after a ticket event, the unchanged\n`updated_at` time will become earlier relative to the updated `generated_timestamp`\ntime.\n\n#### Allowed For\n\n * Admins\n\n#### Sideloading\n\nSee [Tickets sideloads](/documentation/ticketing/using-the-zendesk-api/side_loading/#supported-endpoints). For performance reasons,\n`last_audits` sideloads aren't supported.\n"
  IncrementalTicketExportTime(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The time to start the incremental export from. Must be at least one minute in the past. Data isn't provided for the most recent minute"
    start_time: Int!
  ): TimeBasedExportIncrementalTicketsResponse
  "Returns the tickets that changed since the start time. For more information,\nsee [Exporting tickets](/documentation/ticketing/managing-tickets/using-the-incremental-export-api#exporting-tickets) in [Using the Incremental Exports API](/documentation/ticketing/managing-tickets/using-the-incremental-export-api).\n\nThis endpoint supports cursor-based incremental exports.\nCursor-based exports are highly encouraged because they provide more consistent performance and\nresponse body sizes. For more information, see [Cursor-based incremental exports](/documentation/ticketing/managing-tickets/using-the-incremental-export-api#cursor-based-incremental-exports) in [Using the Incremental Exports API](/documentation/ticketing/managing-tickets/using-the-incremental-export-api).\n\n\n\n#### Allowed For\n\n * Admins\n\n#### Sideloading\n\nSee [Tickets sideloads](/documentation/ticketing/using-the-zendesk-api/side_loading/#supported-endpoints). For performance reasons,\n`last_audits` sideloads aren't supported.\n"
  IncrementalTicketExportCursor(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The time to start the incremental export from. Must be at least one minute in the past. Data isn't provided for the most recent minute"
    start_time: Int!
    "The cursor pointer to work with for all subsequent exports after the initial request"
    cursor: String
  ): CursorBasedExportIncrementalTicketsResponse
  "#### Allowed For\n\n * Admins\n\n#### Sideloading\n\nSee [Users sideloads](/documentation/ticketing/using-the-zendesk-api/side_loading/#supported-endpoints).\n"
  IncrementalUserExportTime(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The time to start the incremental export from. Must be at least one minute in the past. Data isn't provided for the most recent minute"
    start_time: Int!
    "The number of records to return per page"
    per_page: Int
  ): TimeBasedExportIncrementalUsersResponse
  "#### Allowed For\n\n * Admins\n\n#### Sideloading\n\nSee [Users sideloads](/documentation/ticketing/using-the-zendesk-api/side_loading/#supported-endpoints).\n"
  IncrementalUserExportCursor(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The time to start the incremental export from. Must be at least one minute in the past. Data isn't provided for the most recent minute"
    start_time: Int!
    "The cursor pointer to work with for all subsequent exports after the initial request"
    cursor: String
    "The number of records to return per page"
    per_page: Int
  ): CursorBasedExportIncrementalUsersResponse
  "Shows the statuses for background jobs. Statuses are sorted first by completion date and then by creation date in descending order.\n\n#### Allowed For:\n\n* Agents\n\n#### Pagination\n\n* Cursor pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n"
  ListJobStatuses(subdomain: String = "example", domain: String = "zendesk"): JobStatusesResponse
  "Shows the status of a background job.\n\n#### Allowed For:\n\n* Agents\n"
  ShowJobStatus(
    subdomain: String = "example"
    domain: String = "zendesk"
    "the Id of the Job status"
    job_status_id: String!
  ): JobStatusResponse
  "Accepts a comma-separated list of job status ids.\n\n#### Allowed For:\n\n* Agents\n"
  ShowManyJobStatuses(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Comma-separated list of job status ids."
    ids: String!
  ): JobStatusesResponse
  "Lists the translation locales available for the account.\n\n**Note**: You can alter the list by passing an updated `locale_ids` array to the [Update Account Settings](/api-reference/ticketing/account-configuration/account_settings/#update-account-settings) endpoint.\n\n#### Allowed For\n\n* Anyone\n"
  ListLocales(subdomain: String = "example", domain: String = "zendesk"): LocalesResponse
  "#### Allowed For\n\n* Anyone\n"
  ShowLocaleById(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID or the [BCP-47 code](https://en.wikipedia.org/wiki/IETF_language_tag) of the locale. Examples: es-419, en-us, pr-br"
    locale_id: String!
  ): LocaleResponse
  "Lists the translation locales that have been localized for agents on a specific account.\n\n#### Allowed For\n\n* Anyone\n"
  ListLocalesForAgent(subdomain: String = "example", domain: String = "zendesk"): LocalesResponse
  "This works like [Show Locale](#show-locale), but instead of taking a locale id as an argument, it renders the locale of the user performing the request.\n\n#### Allowed For\n\n* Anyone\n"
  ShowCurrentLocale(subdomain: String = "example", domain: String = "zendesk"): LocaleResponse
  "#### Allowed For\n\n* Anyone\n"
  DetectBestLocale(subdomain: String = "example", domain: String = "zendesk"): LocaleResponse
  "Lists the translation locales that are available to all accounts.\n\n#### Allowed For\n\n* Anyone\n"
  ListAvailablePublicLocales(subdomain: String = "example", domain: String = "zendesk"): LocalesResponse
  "Lists all shared and personal macros available to the current user. For admins, the API returns all macros for the account, including the personal macros of agents and other admins.\n\n#### Pagination\n\n- Cursor pagination (recommended)\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n* Agents\n"
  ListMacros(
    subdomain: String = "example"
    domain: String = "zendesk"
    "A sideload to include in the response. See [Sideloads](#sideloads-2)"
    include: String
    "Filter macros by access. Possible values are \"personal\", \"agents\", \"shared\", or \"account\". The \"agents\" value returns all personal macros for the account's agents and is only available to admins."
    access: String
    "Filter by active macros if true or inactive macros if false"
    active: Boolean
    "Filter macros by category"
    category: Int
    "Filter macros by group"
    group_id: Int
    "If true, returns only macros that can be applied to tickets. If false, returns all macros the current user can manage. Default is false"
    only_viewable: Boolean
    "Possible values are alphabetical, \"created_at\", \"updated_at\", \"usage_1h\", \"usage_24h\", \"usage_7d\", or \"usage_30d\". Defaults to alphabetical"
    sort_by: String
    "One of \"asc\" or \"desc\". Defaults to \"asc\" for alphabetical and position sort, \"desc\" for all others"
    sort_order: String
  ): MacrosResponse
  "#### Allowed For\n* Agents\n"
  ShowMacro(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the macro"
    macro_id: Int!
  ): MacroResponse
  "Returns the changes the macro would make to a ticket. It doesn't actually\nchange a ticket. You can use the response data in a subsequent API call\nto the [Tickets](/api-reference/ticketing/tickets/tickets/) endpoint to update the ticket.\n\nThe response includes only the ticket fields that would be changed by the\nmacro. To get the full ticket object after the macro is applied,\nsee [Show Ticket After Changes](#show-ticket-after-changes).\n\n#### Allowed For\n* Agents\n"
  ShowChangesToTicket(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the macro"
    macro_id: Int!
  ): MacroApplyTicketResponse
  "Lists the attachments associated with a macro.\n\n#### Allowed For\n* Agents\n"
  ListMacroAttachments(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the macro"
    macro_id: Int!
  ): MacroAttachmentsResponse
  "#### Allowed For\n* Agents\n"
  ListMacrosActions(subdomain: String = "example", domain: String = "zendesk"): ListMacrosActions_200_response
  "Lists all active shared and personal macros available to the current user.\n\n#### Allowed For\n* Agents\n"
  ListActiveMacros(
    subdomain: String = "example"
    domain: String = "zendesk"
    "A sideload to include in the response. See [Sideloads](#sideloads-2)"
    include: String
    "Filter macros by access. Possible values are \"personal\", \"agents\", \"shared\", or \"account\". The \"agents\" value returns all personal macros for the account's agents and is only available to admins."
    access: String
    "Filter macros by category"
    category: Int
    "Filter macros by group"
    group_id: Int
    "Possible values are alphabetical, \"created_at\", \"updated_at\", \"usage_1h\", \"usage_24h\", \"usage_7d\", or \"usage_30d\". Defaults to alphabetical"
    sort_by: String
    "One of \"asc\" or \"desc\". Defaults to \"asc\" for alphabetical and position sort, \"desc\" for all others"
    sort_order: String
  ): MacrosResponse
  "Shows the properties of the specified macro attachment.\n\n#### Allowed For\n* Agents\n"
  ShowMacroAttachment(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the attachment"
    attachment_id: Int!
  ): MacroAttachmentResponse
  "Lists all macro categories available to the current user.\n\n#### Allowed For\n* Agents\n"
  ListMacroCategories(subdomain: String = "example", domain: String = "zendesk"): MacroCategoriesResponse
  "Returns the definitions of the actions a macro can perform. For example,\none action can set the status of a ticket. The definition of the action\nincludes a title (\"Status\"), a type (\"list\"), and possible values. For a\nlist of support actions, see [Actions reference](/documentation/ticketing/reference-guides/actions-reference).\n\n#### Allowed For\n\n* Agents\n"
  ListMacroActionDefinitions(subdomain: String = "example", domain: String = "zendesk"): ListMacroActionDefinitions_200_response
  "Returns an unpersisted macro representation derived from a ticket or macro.\n\nThe endpoint takes one of the following query parameters: `macro_id` or `ticket_id`. If you include both, `macro_id` is used.\n\n#### Allowed For\n* Agents\n"
  ShowDerivedMacro(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the macro to replicate"
    macro_id: Int!
    "The ID of the ticket from which to build a macro replica"
    ticket_id: Int!
  ): MacroResponse
  "#### Pagination\n\n* Offset pagination only\n\nSee [Using Offset Pagination](/api-reference/ticketing/introduction/#using-offset-pagination).\n\n#### Allowed For\n* Agents\n"
  SearchMacro(
    subdomain: String = "example"
    domain: String = "zendesk"
    "A sideload to include in the response. See [Sideloads](#sideloads-2)"
    include: String
    "Filter macros by access. Possible values are \"personal\", \"agents\", \"shared\", or \"account\". The \"agents\" value returns all personal macros for the account's agents and is only available to admins."
    access: String
    "Filter by active macros if true or inactive macros if false"
    active: Boolean
    "Filter macros by category"
    category: Int
    "Filter macros by group"
    group_id: Int
    "If true, returns only macros that can be applied to tickets. If false, returns all macros the current user can manage. Default is false"
    only_viewable: Boolean
    "Possible values are alphabetical, \"created_at\", \"updated_at\", \"usage_1h\", \"usage_24h\", \"usage_7d\", or \"usage_30d\". Defaults to alphabetical"
    sort_by: String
    "One of \"asc\" or \"desc\". Defaults to \"asc\" for alphabetical and position sort, \"desc\" for all others"
    sort_order: String
    "Query string used to find macros with matching titles"
    query: String!
  ): MacrosResponse
  "Gets the essentials card for an object type.\n#### Allowed For\n* Admins and agents\n"
  ShowEssentialsCard(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Essentials card type. Example: `zen:user` refers user type"
    object_type: String!
  ): EssentialsCardResponse
  "Gets the list of essentials cards.\n#### Allowed For\n* Admins\n"
  ShowEssentialsCards(subdomain: String = "example", domain: String = "zendesk"): EssentialsCardsResponse
  "Returns a list of custom organization fields in your account. Fields are returned in the order that you specify in your organization fields configuration in Zendesk Support. Clients should cache this resource for the duration of their API usage and map the key for each organization field to the values returned under the `organization_fields` attribute on the [organization](/api-reference/ticketing/organizations/organizations/) resource.\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Agents\n"
  ListOrganizationFields(subdomain: String = "example", domain: String = "zendesk"): OrganizationFieldsResponse
  "#### Allowed for\n\n* Agents\n"
  ShowOrganizationField(subdomain: String = "example", domain: String = "zendesk", organization_field_id: OrganizationFieldId_parameter_Input!): OrganizationFieldResponse
  "Returns a list of organization memberships for the account, user or organization in question.\n\n**Note**: When returning organization memberships for a user, organization memberships are sorted with the default organization first, and then by organization name.\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n- Agents\n- End users\n"
  ListOrganizationMemberships(subdomain: String = "example", domain: String = "zendesk"): OrganizationMembershipsResponse
  "#### Allowed for\n\n* Agents\n"
  ShowOrganizationMembershipById(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the organization membership"
    organization_membership_id: Int!
  ): OrganizationMembershipResponse
  "Retrieves the details of a specific organization merge operation. This endpoint is useful for obtaining the status and outcome of a merge that was previously initiated. It provides information such as the winning and losing organization IDs, the status of the merge, and the associated URLs.\n\nThis endpoint can be used to determine if a merge is still in progress, has completed successfully, or has encountered an error.\n\n#### Allowed For\n\n* Admins\n"
  ShowOrganizationMerge(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the organization merge"
    organization_merge_id: String!
  ): OrganizationMergeResponse
  "#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For:\n\n* Agents\n* End users\n\nFor end users, the response will only list the subscriptions created by the requesting end user."
  ListOrganizationSubscriptions(subdomain: String = "example", domain: String = "zendesk"): OrganizationSubscriptionsResponse
  "#### Allowed For:\n\n* Agents\n* End users\n\nFor end users, the response will only list the subscriptions created by the requesting end user."
  ShowOrganizationSubscription(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the organization subscription"
    organization_subscription_id: Int!
  ): OrganizationSubscriptionResponse
  "#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Agents, with certain restrictions\n\nIf the agent has a custom agent role that restricts their access to only users in their own organization, a 403 Forbidden error is returned. See [Creating custom agent roles](https://support.zendesk.com/hc/en-us/articles/203662026-Creating-custom-roles-and-assigning-agents#topic_cxn_hig_bd) in Zendesk help.\n"
  ListOrganizations(subdomain: String = "example", domain: String = "zendesk"): OrganizationsResponse
  "#### Allowed For\n\n* Admins\n* Agents\n"
  ShowOrganization(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of an organization"
    organization_id: Int!
  ): OrganizationResponse
  "Retrieves a list of all organization merge operations associated with a given organization. This endpoint allows you to track the history of merge actions for an organization, including ongoing and completed merges.\n\nEach entry in the list contains details such as the ID of the merge, the winning and losing organization IDs, the current status of the merge, and a URL to access the `Organization Merge` record.\n\n#### Pagination\n\n- Cursor pagination is used for this endpoint.\n- A maximum of 100 records can be returned per page.\n\nSee [Pagination](/api-reference/introduction/pagination/) for more details.\n\n#### Allowed For\n\n* Admins\n"
  ListOrganizationMerges(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of an organization"
    organization_id: Int!
  ): OrganizationMergeListResponse
  "#### Allowed For\n\n* Agents\n"
  OrganizationRelated(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of an organization"
    organization_id: Int!
  ): OrganizationsRelatedResponse
  "Returns an array of organizations whose name starts with the\nvalue specified in the `name` parameter.\n\n#### Pagination\n\n* Offset pagination only\n\nSee [Using Offset Pagination](/api-reference/ticketing/introduction/#using-offset-pagination).\n\n#### Allowed For\n\n* Agents\n"
  AutocompleteOrganizations(
    subdomain: String = "example"
    domain: String = "zendesk"
    "A substring of an organization to search for"
    name: String!
    "The id of a lookup relationship field.  The type of field is determined\nby the `source` param"
    field_id: String
    "If a `field_id` is provided, this specifies the type of the field.\nFor example, if the field is on a \"zen:user\", it references a field on a user"
    source: String
  ): AutocompleteOrganizations_response
  "Returns an approximate count of organizations. If the count exceeds\n100,000, it is updated every 24 hours.\n\nThe `refreshed_at` property of the `count` object is a timestamp that indicates\nwhen the count was last updated.\n\nWhen the count exceeds 100,000, the `refreshed_at` property may\noccasionally be null. This indicates that the count is being\nupdated in the background and the `value` property of the `count` object is limited to\n100,000 until the update is complete.\n\n#### Allowed For\n\n* Agents\n"
  CountOrganizations(subdomain: String = "example", domain: String = "zendesk"): CountOrganizationResponse
  "Returns an array of organizations matching the criteria. You may search by an organization's `external_id` or `name`, but not both:\n\n#### Searching by `external_id`\n\nIf you set the `external_id` value of an organization to associate it to an external record, you can use it to search for the organization.\n\nFor an organization to be returned, its `external_id` must exactly match the value provided (case insensitive).\n\n#### Searching by `name`\n\nFor an organization to be returned, its `name` must exactly match the value provided (case insensitive).\n\n#### Allowed For:\n\n* Admins\n* Agents assigned to a custom role with permissions to add or modify organizations (Enterprise only)\n\nSee [Creating custom agent roles](https://support.zendesk.com/hc/en-us/articles/203662026#topic_cxn_hig_bd) in the Support Help Center.\n"
  SearchOrganizations(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The external id of an organization"
    external_id: Int
    "The name of an organization"
    name: String
  ): OrganizationsResponse
  "Accepts a comma-separated list of up to 100 organization ids or external ids.\n\n#### Allowed For\n\n* Admins\n* Agents\n"
  ShowManyOrganizations(
    subdomain: String = "example"
    domain: String = "zendesk"
    "A list of organization ids"
    ids: String
    "A list of external ids"
    external_ids: String
  ): OrganizationsResponse
  "The response is always ordered by `updated_at` in descending order\n\n#### Allowed For\n\n* Agents\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/)."
  ListTicketProblems(subdomain: String = "example", domain: String = "zendesk"): AWSJSON
  "#### Allowed For\n\n* Admins\n"
  ListQueues(subdomain: String = "example", domain: String = "zendesk"): QueuesResponse
  "#### Allowed For\n\n* Admins\n"
  ShowQueueById(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the omnichannel routing queue"
    queue_id: String!
  ): QueueResponse
  "#### Allowed For\n\n* Admins\n"
  ListQueueDefinitions(subdomain: String = "example", domain: String = "zendesk"): DefinitionsResponse
  "Lists all the support addresses for the account.\n\n#### Pagination\n\n- Cursor pagination (recommended)\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Admins\n* Agents\n"
  ListSupportAddresses(subdomain: String = "example", domain: String = "zendesk"): SupportAddressesResponse
  "#### Allowed For\n\n* Admins\n* Agents\n"
  ShowSupportAddress(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the support address"
    support_address_id: Int!
  ): SupportAddressResponse
  "Returns filter definitions based on the given target type.  Target types\ninclude users (zen:user), tickets (zen:ticket), organizations (zen:organization), or custom objects (zen:custom_object:CUSTOM_OBJECT_KEY).\nThe returned filter definitions are the options that you can use to build a custom field or ticket field's\n`relationship_filter`.\n"
  GetRelationshipFilterDefinitions(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The target type for which you would like to see filter definitions.\nThe options are \"zen:user\", \"zen:ticket\", \"zen:organization\", and \"zen:custom_object:CUSTOM_OBJECT_KEY\""
    target_type: String!
    "The source type for which you would like to see filter definitions.\nThe options are \"zen:user\", \"zen:ticket\", and \"zen:organization\""
    source_type: String
  ): RelationshipFilterDefinitionResponse
  "#### Allowed for\n\n* End Users\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n"
  ListRequests(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Possible values are \"updated_at\", \"created_at\""
    sort_by: String
    "One of \"asc\", \"desc\". Defaults to \"asc\""
    sort_order: String
  ): RequestsResponse
  "#### Sideloads\n\nThe following sideloads are supported:\n\n| Name             | Will sideload\n| ---------------- | -------------\n| users            | The email ccs for a request by side-loading users\n\n#### Allowed For\n\n* End Users\n"
  ShowRequest(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the request"
    request_id: Int!
  ): RequestResponse
  "#### Pagination\n\n- Cursor pagination (recommended)\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\n#### Sorting\n\nBy default, comments are sorted by creation date in ascending order.\n\nWhen using cursor pagination, use the following parameter to change the sort order:\n\n| Name   | Type   | Required | Comments\n| ------ | ------ | -------- | --------\n| `sort` | string | no       | Possible values are \"created_at\" (ascending order) or \"-created_at\" (descending order)\n\nWhen using offset pagination, use the following parameters to change the sort order:\n\n| Name         | Type   | Required | Comments\n| ------------ | ------ | -------- | --------\n| `sort_by`    | string | no       | One of `created_at`, `updated_at`\n| `sort_order` | string | no       | One of `asc`, `desc`\n\n#### Allowed For\n\n* End Users\n"
  ListComments(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the request"
    request_id: Int!
    "Filters the comments from the given datetime"
    since: String
    "One of \"agent\", \"end_user\". If not specified it does not filter"
    role: String
  ): TicketCommentsResponse
  "#### Allowed For\n\n* End Users\n"
  ShowComment(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the request"
    request_id: Int!
    "The ID of the ticket comment"
    ticket_comment_id: Int!
  ): TicketCommentResponse
  "Examples:\n\n* `GET /api/v2/requests/search.json?query=printer`\n* `GET /api/v2/requests/search.json?query=printer&organization_id=1`\n* `GET /api/v2/requests/search.json?query=printer&cc_id=true`\n* `GET /api/v2/requests/search.json?query=printer&status=hold,open`\n\n#### Pagination\n\n* Offset pagination only\n\nSee [Using Offset Pagination](/api-reference/ticketing/introduction/#using-offset-pagination).\n\n#### Results limit\n\nThe Search Requests endpoint returns up to 1,000 results per query, with a maximum of 100 results per page. See [Pagination](/api-reference/ticketing/introduction/#pagination). If you request a page past the limit (`page=11` at 100 results per page), a 422 Insufficient Resource Error is returned.\n\n#### Allowed For\n\n* End Users\n"
  SearchRequests(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The syntax and matching logic for the string is detailed in the [Zendesk Support search reference](https://support.zendesk.com/hc/en-us/articles/203663226). See also [Query basics](/api-reference/ticketing/ticket-management/search/#query-basics) in the Tickets API doc."
    query: String
  ): RequestsResponse
  "Lists resource collections for the account.\n\n#### Allowed for\n\n* Admins\n"
  ListResourceCollections(subdomain: String = "example", domain: String = "zendesk"): ResourceCollectionsResponse
  "Retrieves details for a specified resource collection.\n\n#### Allowed for\n\n* Admins\n"
  RetrieveResourceCollection(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the resource collection"
    resource_collection_id: Int!
  ): ResourceCollectionResponse
  "Returns an attribute value.\n\n#### Allowed For\n\n* Agents and admins\n"
  ListAGentAttributeValues(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
  ): SkillBasedRoutingAttributeValuesResponse
  "Returns a list of attributes for the account.\n\n#### Sideloads\n\nThe following sideloads are supported:\n\n| Name             | Will sideload\n| ---------------- | -------------\n| attribute_values | The attribute values available on the account\n\n#### Allowed For\n\n* Agents and admins\n"
  ListAccountAttributes(subdomain: String = "example", domain: String = "zendesk"): SkillBasedRoutingAttributesResponse
  "Returns an attribute.\n\n#### Allowed For\n\n* Admins\n"
  ShowAttribute(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the skill-based routing attribute"
    attribute_id: String!
  ): SkillBasedRoutingAttributeResponse
  "Returns a list of attribute values for a provided attribute.\n\n#### Allowed For\n\n* Admins\n"
  ListAttributeValues(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the skill-based routing attribute"
    attribute_id: String!
  ): SkillBasedRoutingAttributeValuesResponse
  "Returns an attribute value.\n\n#### Allowed For\n\n* Admins\n"
  ShowAttributeValue(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the skill-based routing attribute"
    attribute_id: String!
    "The ID of the skill-based routing attribute value"
    attribute_value_id: String!
  ): SkillBasedRoutingAttributeValueResponse
  "Returns the condition definitions that can be configured to apply attributes to a ticket.\n\n#### Allowed For\n\n* Admins\n"
  ListRoutingAttributeDefinitions(subdomain: String = "example", domain: String = "zendesk"): SkillBasedRoutingAttributeDefinitions
  "Returns a list of ticket ids that contain attributes matching the current user's attributes. Accepts a `ticket_ids` parameter for relevant tickets to check for matching attributes.\n\n#### Allowed For\n\n* Agents and admins\n"
  ListTicketsFullfilledByUser(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The IDs of the relevant tickets to check for matching attributes"
    ticket_ids: Int!
  ): SkillBasedRoutingTicketFulfilledResponse
  "Returns a list of attributes values for the ticket.\n\n#### Allowed For\n\n* Agents and admins\n"
  ListTicketAttributeValues(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): SkillBasedRoutingAttributeValuesResponse
  "#### Allowed For\n* Admins\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\n#### Filters\n\n| Parameter  | Value\n| ---------- | -----\n| score      | offered, unoffered, received, received\\_with\\_comment, received\\_without\\_comment,<br/>good, good\\_with\\_comment, good\\_without\\_comment,<br/>bad, bad\\_with\\_comment, bad\\_without\\_comment\n| start_time | Time of the oldest satisfaction rating, as a [Unix epoch time](https://www.epochconverter.com/)\n| end_time   | Time of the most recent satisfaction rating, as a [Unix epoch time](https://www.epochconverter.com/)\n\nIf you specify an unqualified score such as `good`, the results include all the records with and without comments.\n\nExamples:\n\n* `/api/v2/satisfaction_ratings.json?score=bad`\n* `/api/v2/satisfaction_ratings.json?score=bad&start_time=1498151194`\n* `/api/v2/satisfaction_ratings.json?start_time=1340384793&end_time=1371920793`\n"
  ListSatisfactionRatings(subdomain: String = "example", domain: String = "zendesk"): SatisfactionRatingsResponse
  "Returns a specific satisfaction rating. You can get the id from\nthe [List Satisfaction Ratings](#list-satisfaction-ratings) endpoint.\n\n#### Allowed For\n\n * Admins\n"
  ShowSatisfactionRating(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the satisfaction rating to retrieve"
    satisfaction_rating_id: Int!
  ): SatisfactionRatingResponse
  "Returns an approximate count of satisfaction ratings in the account. If the count exceeds 100,000, the count will return a cached result. This cached result will update every 24 hours.\n\nThe `count[refreshed_at]` property is a timestamp that indicates when the count was last updated.\n\n**Note**: When the count exceeds 100,000, `count[refreshed_at]` may occasionally be null.\nThis indicates that the count is being updated in the background, and `count[value]` is limited to 100,000 until the update is complete.\n\n#### Allowed For\n* Admins"
  CountSatisfactionRatings(subdomain: String = "example", domain: String = "zendesk"): SatisfactionRatingsCountResponse
  "List all reasons for an account\n\n#### Allowed For\n\n* Admins\n"
  ListSatisfactionRatingReasons(subdomain: String = "example", domain: String = "zendesk"): SatisfactionReasonsResponse
  "#### Allowed For\n\n* Admins\n"
  ShowSatisfactionRatings(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the satisfaction rating reason"
    satisfaction_reason_id: Int!
  ): SatisfactionReasonResponse
  "Use the ampersand character (&) to append the `sort_by` or `sort_order` parameters to the URL.\n\nFor examples, see [Searching with Zendesk API](/documentation/ticketing/using-the-zendesk-api/searching-with-the-zendesk-api).\n\n#### Pagination\n\n* Offset pagination only\n\nOffset pagination may result in duplicate results when paging. You can also use the \n[Export Search Results](/api-reference/ticketing/ticket-management/search/#export-search-results) endpoint, which \nuses cursor-based pagination and doesn't return duplicate results. See \n[Pagination](/api-reference/introduction/pagination/) for more information.\n\n#### Allowed For\n\n* Admins, Agents and Light Agents\n\n\n#### Errors JSON Format\n\nErrors are represented as JSON objects which have the following keys:\n\n| Name                  | Type                 | Comment\n| --------------------- | ---------------------| --------------------\n| error                 | string               | The type of error. Examples: \"unavailable\", \"invalid\"\n| description           | string               |\n\n##### Example Error\n```js\n{\n  \"error\": \"unavailable\",\n  \"description\": \"Sorry, we could not complete your search query. Please try again in a moment.\"\n}\n```\n"
  ListSearchResults(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The search query. See [Query basics](#query-basics) above. For details on the query syntax, see the [Zendesk Support search reference](https://support.zendesk.com/hc/en-us/articles/203663226)"
    query: String!
    "One of `updated_at`, `created_at`, `priority`, `status`, or `ticket_type`. Defaults to sorting by relevance"
    sort_by: String
    "One of `asc` or `desc`.  Defaults to `desc`"
    sort_order: String
  ): SearchResponse
  "Returns the number of items matching the query rather than the items. The search string works the same as a regular search.\n"
  CountSearchResults(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The search query"
    query: String!
  ): SearchCountResponse
  "Exports a set of results. See [Query basics](#query-basics) for the syntax of the `query` parameter.\n\nThis endpoint is for search queries that will return more than 1000 results. The result set is ordered only by the `created_at` attribute.\n\nThe search only returns results of a single object type. The following object types are supported: ticket, organization, user, or group.\n\nYou must specify the type in the `filter[type]` parameter. Searches with type in the query string will result in an error.\n\n#### Allowed For\n\n- Agents\n\n#### Pagination\n\n- Cursor pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 1000 records per page. The number of results shown in a page is determined by the `page[size]` parameter.\n\n**Note**: You may experience a speed reduction or a timeout if you request 1000 results per page and you have many archived tickets in the results. Try reducing the number of results per page. We recommend 100 results per page.\n\nThe cursor specified by the `after_cursor` property in a response expires after one hour.\n\nFor more information on cursor-based pagination, see the following articles:\n\n- [Comparing cursor pagination and offset pagination](/documentation/developer-tools/pagination/comparing-cursor-pagination-and-offset-pagination)\n- [Paginating through lists using cursor pagination](/documentation/developer-tools/pagination/paginating-through-lists-using-cursor-pagination)\n\n#### Limits\n\nThis API endpoint is rate-limited to 100 requests per minute per account. The limit also counts towards the global API rate limit.\n\n#### Response Format\n\n| Name                  | Type                 | Comment\n| --------------------- | ---------------------| --------------------\n| links[next]           | string               | URL to the next page of results\n| meta[has_more]        | string               | Boolean indicating if there are more results\n| meta[after_cursor]    | string               | Cursor object returned from the Search Service\n| results               | array                | May consist of tickets, users, groups, or organizations, as specified by the `filter_type` parameter\n\nThe response is similar to the response of `GET /api/v2/search.json?`, with a few changes:\n\n* `links` - Has the following nested properties: `prev` and `next`. These replace the `next_page` and `prev_page` links. The `prev` property is always null because backward pagination is not supported. The `next` property may include an auto-generated link to the next page of results.\n* `meta` - Has the following nested properties: `has_more` and `after_cursor`. The `has_more` property indicates whether the next page has more results. The `after_cursor` property is the cursor used to paginate to the next page. It expires after one hour.\n\nThere's no `count` property.\n"
  ExportSearchResults(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The search query. See [Query basics](#query-basics) above. For details on the query syntax, see the [Zendesk Support search reference](https://support.zendesk.com/hc/en-us/articles/203663226)"
    query: String!
    "The number of results shown in a page."
    page_LEFT_SQUARE_BRACE_size_RIGHT_SQUARE_BRACE_: Int
    "The object type returned by the export query. Can be `ticket`, `organization`, `user`, or `group`."
    filter_LEFT_SQUARE_BRACE_type_RIGHT_SQUARE_BRACE_: String
  ): SearchExportResponse
  "If authenticated as an admin, returns all the account's sessions. If authenticated as an agent or end user, returns only the sessions of the user making the request.\n\n#### Pagination\n\n- Cursor pagination (recommended)\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\n#### Allowed For\n\n* Admins, Agents, End users\n"
  ListSessions(subdomain: String = "example", domain: String = "zendesk"): SessionsResponse
  "#### Allowed For\n\n* Agents\n"
  ListSharingAgreements(subdomain: String = "example", domain: String = "zendesk"): SharingAgreementsResponse
  "Returns a sharing agreement for your account.\n\n#### Allowed For\n\n* Agents\n"
  ShowSharingAgreement(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the sharing agreement"
    sharing_agreement_id: Int!
  ): SharingAgreementResponse
  "#### Availability\n\n* Accounts on the Support Professional or Suite Growth plan or above\n\n#### Allowed For\n\n* Admins\n"
  ListSLAPolicies(subdomain: String = "example", domain: String = "zendesk"): SLAPoliciesResponse
  "#### Availability\n\n* Accounts on the Support Professional or Suite Growth plan or above\n\n#### Allowed For\n\n* Admins\n"
  ShowSLAPolicy(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the SLA Policy"
    sla_policy_id: Int!
  ): SLAPolicyResponse
  "#### Availability\n\n* Accounts on the Support Professional or Suite Growth plan or above\n\n#### Allowed For\n\n* Admins\n"
  RetrieveSLAPolicyFilterDefinitionItems(subdomain: String = "example", domain: String = "zendesk"): SLAPolicyFilterDefinitionResponse
  "#### Allowed For\n\n* Admins and [agents in custom roles with permission](https://support.zendesk.com/hc/en-us/articles/4408882153882#topic_cxn_hig_bd) to manage suspended tickets on Enterprise plans\n* Unrestricted agents on all other plans\n\n#### Sorting\n\nYou can sort the tickets with the `sort_by` and `sort_order` query string parameters.\n\n#### Pagination\n\n* Cursor pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n"
  ListSuspendedTickets(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The field to sort the ticket by, being one of `author_email`, `cause`, `created_at`, or `subject`."
    sort_by: String
    "The order in which to sort the suspended tickets.  This can take value `asc` or `desc`."
    sort_order: String
  ): SuspendedTicketsResponse
  "#### Allowed For\n\n* Admins and [agents in custom roles with permission](https://support.zendesk.com/hc/en-us/articles/4408882153882#topic_cxn_hig_bd) to manage suspended tickets on Enterprise plans\n* Unrestricted agents on all other plans\n"
  ShowSuspendedTickets(
    subdomain: String = "example"
    domain: String = "zendesk"
    "id of the suspended ticket"
    id: Float!
  ): SuspendedTicketsResponse
  "Lists up to the 20,000 most popular tags in the last 60 days, in decreasing popularity.\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Agents\n"
  ListTags(subdomain: String = "example", domain: String = "zendesk"): TagsResponse
  "Returns an approximate count of tags. If the count exceeds 100,000, it\nis updated every 24 hours.\n\nThe `refreshed_at` property of the `count` object is a timestamp that indicates when\nthe count was last updated.\n\n**Note**: When the count exceeds 100,000, the `refreshed_at` property in the `count` object may\noccasionally be null. This indicates that the count is being\nupdated in the background and the `value` property in the `count` object is limited to\n100,000 until the update is complete.\n\n#### Allowed For\n\n* Admins\n"
  CountTags(subdomain: String = "example", domain: String = "zendesk"): TagCountResponse
  "Returns the 25 most recent target failures, per target.\n\n#### Stability\n\n* Development\n\n#### Allowed For\n\n* Admins\n"
  ListTargetFailures(subdomain: String = "example", domain: String = "zendesk"): TargetFailuresResponse
  "#### Stability\n\n* Development\n\n#### Allowed For\n\n* Admins\n"
  ShowTargetFailure(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the target failure"
    target_failure_id: Int!
  ): TargetFailureResponse
  "#### Allowed For\n\n* Agents\n"
  ListTargets(subdomain: String = "example", domain: String = "zendesk"): TargetsResponse
  "#### Allowed For\n\n* Agents\n"
  ShowTarget(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the target"
    target_id: Int!
  ): TargetResponse
  "Returns ticket audits. Archived tickets are not included in the response. Use the [List Audits for a Ticket](#list-audits-for-a-ticket) endpoint to \nretrieve audit records for an archived ticket. To learn more about archived tickets, see [About archived tickets](https://support.zendesk.com/hc/en-us/articles/203657756).\n\nThis endpoint should not be used for capturing change data. When continually chasing the tail of a cursor, some records will be skipped. For this use case, use the [Incremental Ticket Event Export API](/api-reference/ticketing/ticket-management/incremental_exports/#incremental-ticket-event-export).\n\n#### Pagination\n\n- Cursor pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Admins\n"
  ListTicketAudits(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Maximum number of results returned"
    limit: Int
  ): TicketAuditsResponse
  "Returns a list of all system and custom ticket fields in your account.\n\nCursor pagination returns a maximum of 100 records per page and fields are returned in the order specified by their id.\n\nIf the results are not paginated every field is returned in the response and fields are returned in the order specified by the position and id.\n\nFor accounts without access to multiple ticket forms, positions can be changed using the [Update Ticket Field](/api-reference/ticketing/tickets/ticket_fields/#update-ticket-field) endpoint or the Ticket Forms page in Zendesk Support (**Admin** > **Manage** > **Ticket Forms**). The Ticket Forms page shows the fields for the account. The order of the fields is used in the different products to show the field values in the tickets.\n\nFor accounts with access to multiple ticket forms, positions can only be changed using the [Update Ticket Field](/api-reference/ticketing/tickets/ticket_fields/#update-ticket-field) endpoint because products use the order defined on each form to show the field values instead of the general position of the ticket field in the account.\n\nConsider caching this resource to use with the [Tickets](/api-reference/ticketing/tickets/tickets/#json-format) API.\n\n#### Pagination\n\n- Cursor pagination (recommended)\n- No pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\n#### Sideloads\n\nThe following sideloads are supported:\n\n| Name             | Will sideload\n| ---------------- | -------------\n| users            | The user or users that created the ticket field\n\n#### Allowed For\n\n* Agents\n"
  ListTicketFields(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Forces the `title_in_portal` property to return a dynamic content variant for the specified locale.\n Only accepts [active locale ids](/api-reference/ticketing/account-configuration/locales/#list-locales).\nExample: `locale=\"de\"`."
    locale: String
    "Displays the `creator_user_id` and `creator_app_name` properties. If the ticket field is created\n by an app, `creator_app_name` is the name of the app and `creator_user_id` is `-1`. If the ticket field\n is not created by an app, `creator_app_name` is null"
    creator: Boolean
  ): TicketFieldsResponse
  "#### Allowed for\n\n* Agents\n\n#### Sideloads\n\nThe following sideloads are supported:\n\n| Name             | Will sideload\n| ---------------- | -------------\n| users            | The user or users that created the ticket field\n"
  ShowTicketfield(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket field"
    ticket_field_id: Int!
    "If true, displays the `creator_user_id` and `creator_app_name` properties. If the ticket field is created\n by an app, `creator_app_name` is the name of the app and `creator_user_id` is `-1`. If the ticket field\n is not created by an app, then `creator_app_name` is null"
    creator: Boolean
  ): TicketFieldResponse
  "Returns a list of custom ticket field options for the given drop-down ticket field.\n\n#### Allowed For\n\n* Agents\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n"
  ListTicketFieldOptions(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket field"
    ticket_field_id: Int!
  ): CustomFieldOptionsResponse
  "#### Allowed for\n* Agents\n"
  ShowTicketFieldOption(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket field"
    ticket_field_id: Int!
    "The ID of the ticket field option"
    ticket_field_option_id: Int!
  ): CustomFieldOptionResponse
  "Returns an approximate count of system and custom ticket fields in the account. If the count exceeds 100,000, the count will return a cached result.  This cached result will update every 24 hours.\n\nThe `count[refreshed_at]` property is a timestamp that indicates when the count was last updated.\n\n**Note**: When the count exceeds 100,000, `count[refreshed_at]` may occasionally be null.\nThis indicates that the count is being updated in the background, and `count[value]` is limited to 100,000 until the update is complete.\n\n#### Allowed For\n* Agents"
  CountTicketFields(subdomain: String = "example", domain: String = "zendesk"): TicketFieldCountResponse
  "Returns a list of all ticket forms for your account if accessed as an admin or agent. End users only see ticket forms that have `end_user_visible` set to true.\n\n#### Allowed For\n\n* Anyone\n"
  ListTicketForms(
    subdomain: String = "example"
    domain: String = "zendesk"
    "true returns active ticket forms; false returns inactive ticket forms. If not present, returns both"
    active: Boolean
    "true returns ticket forms where `end_user_visible`; false returns ticket forms that are not end-user visible. If not present, returns both"
    end_user_visible: Boolean
    "true returns the default ticket form when the criteria defined by the parameters results in a set without active and end-user visible ticket forms"
    fallback_to_default: Boolean
    "true returns the ticket forms of the brand specified by the url's subdomain"
    associated_to_brand: Boolean
  ): TicketFormsResponse
  "#### Allowed For\n\n* Admins, Agents, and End Users\n"
  ShowTicketForm(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket form"
    ticket_form_id: Int!
  ): TicketFormResponse
  "Takes an `ids` query parameter that accepts a comma-separated list of up to 100 ticket form ids. This endpoint is used primarily by the [mobile SDK](/documentation/classic-web-widget-sdks/) and the [Web Widget](/api-reference/widget/introduction/).\n\n#### Allowed For\n\n* Anyone\n"
  ShowManyTicketForms(
    subdomain: String = "example"
    domain: String = "zendesk"
    "IDs of the ticket forms to be shown"
    ids: String!
    "true returns active ticket forms; false returns inactive ticket forms. If not present, returns both"
    active: Boolean
    "true returns ticket forms where `end_user_visible`; false returns ticket forms that are not end-user visible. If not present, returns both"
    end_user_visible: Boolean
    "true returns the default ticket form when the criteria defined by the parameters results in a set without active and end-user visible ticket forms"
    fallback_to_default: Boolean
    "true returns the ticket forms of the brand specified by the url's subdomain"
    associated_to_brand: Boolean
  ): TicketFormsResponse
  "Returns a list of tickets with their metrics.\n\nTickets are ordered chronologically by created date, from newest to oldest.\nThe last ticket listed may not be the absolute oldest ticket in your account\ndue to ticket archiving.\n\nArchived tickets are not included in the response. See\n[About archived tickets](https://support.zendesk.com/hc/en-us/articles/203657756) in\nZendesk help.\n\n#### Pagination\n\n- Cursor pagination (recommended)\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n\n#### Allowed For\n\n* Agents\n"
  ListTicketMetrics(subdomain: String = "example", domain: String = "zendesk"): TicketMetricsResponse
  "Returns a specific metric, or the metrics of a specific ticket.\n\n#### Pagination\n\n- Cursor pagination (recommended)\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Agents\n"
  ShowTicketMetrics(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the ticket metric to retrieve"
    ticket_metric_id: String!
  ): TicketMetricsByTicketMetricIdResponse
  "List Tickets"
  ListTickets(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Lists tickets by external id. External ids don't have to be unique for each ticket. As a result, the request may return multiple tickets with the same external id."
    external_id: String
  ): TicketsResponse
  "Returns a number of ticket properties though not the ticket comments. To get the comments, use [List Comments](/api-reference/ticketing/tickets/ticket_comments/#list-comments)\n\n#### Allowed For\n* Agents"
  ShowTicket(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): TicketResponse
  "Lists the audits for a specified ticket.\n\n#### Pagination\n\n- Cursor pagination (recommended)\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n**Note**: Audits for [Archived Tickets](https://support.zendesk.com/hc/en-us/articles/4408887617050) do not support pagination for this endpoint.\n\n#### Allowed for\n\n* Agents\n"
  ListAuditsForTicket(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): TicketAuditsResponseNoneCursor
  "#### Allowed for\n\n* Agents\n"
  ShowTicketAudit(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
    "The ID of the ticket audit"
    ticket_audit_id: Int!
  ): TicketAuditResponse
  "Returns an approximate count of audits for a specified ticket. If the count exceeds 100,000, the count will return a cached result.  This cached result will update every 24 hours.\n\nThe `count[refreshed_at]` property is a timestamp that indicates when the count was last updated.\n\n**Note**: When the count exceeds 100,000, `count[refreshed_at]` may occasionally be null.\nThis indicates that the count is being updated in the background, and `count[value]` is limited to 100,000 until the update is complete.\n\n#### Allowed for\n\n* Agents\n"
  CountAuditsForTicket(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): TicketAuditsCountResponse
  "#### Allowed For\n\n* Agents"
  ListTicketCollaborators(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): AWSJSON
  "Returns the comments added to the ticket.\n\nEach comment may include a `content_url` for an attachment or a `recording_url` for a voice comment that points to a file that may be hosted externally. For security reasons, take care not to inadvertently send Zendesk authentication credentials to third parties when attempting to access these files. See [Working with url properties](/documentation/ticketing/managing-tickets/working-with-url-properties).\n\n#### Pagination\n\n- Cursor pagination (recommended)\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Sorting\n\nBy default, comments are sorted by creation date in ascending order.\n\nWhen using cursor pagination, use the following parameter to change the sort order:\n\n| Name   | Type   | Required | Comments\n| ------ | ------ | -------- | --------\n| `sort` | string | no       | Possible values are \"created_at\" (ascending order) or \"-created_at\" (descending order)\n\nWhen using offset pagination, use the following parameters to change the sort order:\n\n| Name         | Type   | Required | Comments\n| ------------ | ------ | -------- | --------\n| `sort_order` | string | no       | One of `asc`, `desc`. Defaults to `asc`\n\n#### Allowed For\n\n* Agents\n"
  ListTicketComments(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
    "Default is false. When true, inline images are also listed as attachments in the response"
    include_inline_images: Boolean
    "Accepts \"users\". Use this parameter to list email CCs by side-loading users. Example: `?include=users`. **Note**: If the comment source is email, a deleted user will be represented as the CCd email address. If the comment source is anything else, a deleted user will be represented as the user name."
    include: String
  ): TicketCommentsResponse
  "Returns an approximate count of the comments added to the ticket. If the count exceeds 100,000, the count will return a cached result.  This cached result will update every 24 hours.\n\nThe `count[refreshed_at]` property is a timestamp that indicates when the count was last updated.\n\n**Note**: When the count exceeds 100,000, `count[refreshed_at]` may occasionally be null.\nThis indicates that the count is being updated in the background, and `count[value]` is limited to 100,000 until the update is complete.\n\n#### Allowed For\n* Agents"
  CountTicketComments(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): TicketCommentsCountResponse
  "Returns any users cc'd on the ticket.\n\n#### Availability\n\nThe [CCs and Followers](https://support.zendesk.com/hc/en-us/articles/203690846) feature must be enabled in Zendesk Support.\n\nIf the feature is not enabled, the default CC functionality is used. In that case, use [List Collaborators](/api-reference/ticketing/tickets/tickets/#list-collaborators-for-a-ticket) to list the users cc'ed on the ticket.\n\n#### Allowed For\n\n* Agents"
  ListTicketEmailCCs(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): AWSJSON
  "Returns any users who follow the ticket.\n\n#### Availability\n\nThe [CCs and Followers](https://support.zendesk.com/hc/en-us/articles/203690846) feature must be enabled in Zendesk Support.\n\n#### Allowed For\n\n* Agents"
  ListTicketFollowers(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): AWSJSON
  "#### Allowed For\n\n* Agents\n\n#### Pagination\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/)."
  ListTicketIncidents(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): AWSJSON
  "Returns the full ticket object as it would be after applying the macro to the ticket.\nIt doesn't actually change the ticket.\n\nTo get only the ticket fields that would be changed by the macro,\nsee [Show Changes to Ticket](#show-changes-to-ticket).\n\n#### Allowed For\n\n* Agents\n"
  ShowTicketAfterChanges(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
    "The ID of the macro"
    macro_id: Int!
  ): MacroApplyTicketResponse
  "The request returns a data object with the following properties:\n\n| Name                | Type    | Comment\n| ------------------- | ------- | -------\n| topic_id            | string  | Related topic in the Web portal (deprecated feature)\n| followup_source_ids | array   | Sources to follow up\n| from_archive        | boolean | Is true if the current ticket is archived\n| incidents           | integer | A count of related incident occurrences\n| twitter             | object  | X (formerly Twitter) information associated with the ticket\n\n#### Allowed For\n\n* Agents"
  TicketRelatedInformation(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): TicketRelatedInformation
  "#### Allowed For\n\n* Agents\n"
  ListResourceTags(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): TagsByObjectIdResponse
  "Returns an approximate count of tickets in the account. If the count exceeds 100,000, it is updated every 24 hours.\n\n`ccd` lists tickets that the specified user is cc'd on.\n\nThe `count[refreshed_at]` property is a timestamp that indicates when the count was last updated.\n\n**Note**: When the count exceeds 100,000, `count[refreshed_at]` may occasionally be null.\nThis indicates that the count is being updated in the background, and `count[value]` is limited to 100,000 until the update is complete.\n\n#### Allowed For\n* Agents"
  CountTickets(subdomain: String = "example", domain: String = "zendesk"): CountTickets_200_response
  "Accepts a comma-separated list of ticket ids to return.\n\nThis endpoint will return up to 100 tickets records.\n\n#### Allowed For\n* Agents"
  TicketsShowMany(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Comma-separated list of ticket ids"
    ids: String!
  ): TicketsResponse
  "Returns all the trigger categories in the account.\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n"
  ListTriggerCategories(subdomain: String = "example", domain: String = "zendesk", page: queryInput_ListTriggerCategories_page_Input, sort: queryInput_ListTriggerCategories_sort, include: rule_counts_const): ListTriggerCategories_response
  "Returns the trigger category with the specified ID."
  ShowTriggerCategoryById(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the trigger category to retrieve"
    trigger_category_id: String!
  ): ShowTriggerCategoryById_response
  "Lists all triggers for the current account.\n\n#### Pagination\n\n- Cursor pagination (recommended)\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Agents\n\n#### Sideloads\n\nThe following sideloads are supported. The usage sideloads are only supported on the Support Professional or Suite Growth plan or above.\n\n| Name             | Will sideload\n| ---------------- | -------------\n| app_installation | The app installation that requires each trigger, if present\n| permissions      | The permissions for each trigger\n| usage_1h         | The number of times each trigger has been used in the past hour\n| usage_24h        | The number of times each trigger has been used in the past day\n| usage_7d         | The number of times each trigger has been used in the past week\n| usage_30d        | The number of times each trigger has been used in the past thirty days\n"
  ListTriggers(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Filter by active triggers if true or inactive triggers if false"
    active: Boolean
    "Cursor-based pagination only. Possible values are \"alphabetical\", \"created_at\", \"updated_at\", or \"position\"."
    sort: String
    "Offset pagination only. Possible values are \"alphabetical\", \"created_at\", \"updated_at\", \"usage_1h\", \"usage_24h\", or \"usage_7d\". Defaults to \"position\""
    sort_by: String
    "One of \"asc\" or \"desc\". Defaults to \"asc\" for alphabetical and position sort, \"desc\" for all others"
    sort_order: String
    "Filter triggers by category ID"
    category_id: String
  ): TriggersResponse
  "#### Allowed For\n\n* Agents\n\nThe Via Type value is a number instead of a text string. See [Via types reference](/documentation/ticketing/reference-guides/via-types/) for the keys.\n"
  GetTrigger(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the trigger"
    trigger_id: Int!
  ): TriggerResponse
  "List the revisions associated with a trigger. Trigger revision history is only available on Enterprise plans.\n\n#### Allowed For\n\n * Agents\n\n#### Sideloads\n\nThe following sideloads are supported:\n\n| Name  | Will sideload\n| ----- | -------------\n| users | The user that authored each revision\n\n#### Pagination\n\nThis endpoint uses cursor-based pagination. The records are ordered in\ndescending order by the `created_at` timestamp, then by `id` on duplicate\n`created_at` values.\n\nThe `cursor` parameter is a non-human-readable argument you can use to move\nforward or backward in time.\n\nEach JSON response will contain the following attributes to help you get\nmore results:\n\n- `after_url` requests more recent results\n- `before_url` requests older results\n- `after_cursor` is the cursor to build the request yourself\n- `before_cursor` is the cursor to build the request yourself\n\nThe properties are null if no more records are available.\n\nYou can request a maximum of 1000 records using the `limit` parameter. If\nno `limit` parameter is supplied, it will default to 1,000.\n"
  ListTriggerRevisions(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the trigger"
    trigger_id: Int!
  ): TriggerRevisionsResponse
  "Fetches a revision associated with a trigger. Trigger revision history is only available on Enterprise plans.\n\n#### Allowed For\n\n * Agents\n\n#### Sideloads\n\nThe following sideloads are supported:\n\n| Name  | Will sideload\n| ----- | -------------\n| users | The user that authored each revision\n"
  TriggerRevision(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the trigger"
    trigger_id: Int!
    "The ID of the revision for a particular trigger"
    trigger_revision_id: Int!
  ): TriggerRevisionResponse
  "Lists all active triggers.\n\n#### Pagination\n\n- Cursor pagination (recommended)\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n#### Allowed For\n\n* Agents\n\n#### Sideloads\n\nThe following sideloads are supported:\n\n| Name             | Will sideload\n| ---------------- | -------------\n| app_installation | The app installation that requires each trigger, if present\n| permissions      | The permissions for each trigger\n| usage_1h         | The number of times each trigger has been used in the past hour\n| usage_24h        | The number of times each trigger has been used in the past day\n| usage_7d         | The number of times each trigger has been used in the past week\n| usage_30d        | The number of times each trigger has been used in the past thirty days\n"
  ListActiveTriggers(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Cursor-based pagination only. Possible values are \"alphabetical\", \"created_at\", \"updated_at\", or \"position\"."
    sort: String
    "Offset pagination only. Possible values are \"alphabetical\", \"created_at\", \"updated_at\", \"usage_1h\", \"usage_24h\", or \"usage_7d\". Defaults to \"position\""
    sort_by: String
    "One of \"asc\" or \"desc\". Defaults to \"asc\" for alphabetical and position sort, \"desc\" for all others"
    sort_order: String
    "Filter triggers by category ID"
    category_id: String
  ): TriggersResponse
  "Returns the definitions of the actions a trigger can perform and the\ndefinitions of the conditions under which a trigger can execute. The\ndefinition of the action includes a title (\"Status\"), a type (\"list\"), and\npossible values. The definition of the condition includes the same fields\nas well as the possible operators.\n\nFor a list of supported actions, see the [Actions reference](/documentation/ticketing/reference-guides/actions-reference)\nFor a list of supported conditions, see the [Conditions reference](/documentation/ticketing/reference-guides/conditions-reference)\n\n#### Allowed For\n\n* Agents\n"
  ListTriggerActionConditionDefinitions(subdomain: String = "example", domain: String = "zendesk"): TriggerDefinitionResponse
  "#### Pagination\n\n* Offset pagination only\n\nSee [Using Offset Pagination](/api-reference/ticketing/introduction/#using-offset-pagination).\n\n#### Allowed For\n\n* Agents\n\n#### Sideloads\n\nThe following sideloads are supported. For more information, see [Side-loading](/documentation/ticketing/using-the-zendesk-api/side_loading/).\n\n| Name             | Will sideload\n| ---------------- | -------------\n| app_installation | The app installation that requires each trigger, if present\n| permissions      | The permissions for each trigger\n| usage_1h         | The number of times each trigger has been used in the past hour\n| usage_24h        | The number of times each trigger has been used in the past day\n| usage_7d         | The number of times each trigger has been used in the past week\n| usage_30d        | The number of times each trigger has been used in the past thirty days\n\n#### Filter\n\nUse the `filter` query parameter to filter a trigger search by one or more attributes. For example, the following `filter` argument filters triggers by the `description` attribute:\n\n```json\n{\n  \"json\": {\n    \"description\": \"Close a ticket\"\n  }\n}\n```\n"
  SearchTriggers(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Query string used to find all triggers with matching title"
    query: String!
    filter: TriggerSearchFilter_parameter_Input
    "Filter by active triggers if true or inactive triggers if false"
    active: Boolean
    "Cursor-based pagination only. Possible values are \"alphabetical\", \"created_at\", \"updated_at\", or \"position\"."
    sort: String
    "Offset pagination only. Possible values are \"alphabetical\", \"created_at\", \"updated_at\", \"usage_1h\", \"usage_24h\", or \"usage_7d\". Defaults to \"position\""
    sort_by: String
    "One of \"asc\" or \"desc\". Defaults to \"asc\" for alphabetical and position sort, \"desc\" for all others"
    sort_order: String
    "A sideload to include in the response. See [Sideloads](#sideloads-2)"
    include: String
  ): TriggersResponse
  "Returns a list of custom user fields in your account. Fields are returned in the order that you specify in your user fields configuration in Zendesk Support. Clients should cache this resource for the duration of their API usage and map the key for each User Field to the values returned under the `user_fields` attribute on the [User](/api-reference/ticketing/users/users/) resource.\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Agents\n"
  ListUserFields(subdomain: String = "example", domain: String = "zendesk"): UserFieldsResponse
  "#### Allowed for\n\n* Agents\n"
  ShowUserField(subdomain: String = "example", domain: String = "zendesk", user_field_id: UserFieldId_parameter_Input!): UserFieldResponse
  "Returns a list of custom user field options for the given dropdown user field.\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Agents\n"
  ListUserFieldOptions(subdomain: String = "example", domain: String = "zendesk", user_field_id: UserFieldId_parameter_Input!): CustomFieldOptionsResponse
  "#### Allowed for\n* Agents\n"
  ShowUserFieldOption(
    subdomain: String = "example"
    domain: String = "zendesk"
    user_field_id: UserFieldId_parameter_Input!
    "The ID of the user field option"
    user_field_option_id: Int!
  ): CustomFieldOptionResponse
  "#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Admins, Agents and Light Agents\n"
  ListUsers(
    subdomain: String = "example"
    domain: String = "zendesk"
    role: UserRoleFilter_parameter
    "Filters the results by more than one role using the format `role[]={role}&role[]={role}`"
    role_LEFT_SQUARE_BRACE__RIGHT_SQUARE_BRACE_: String
    "For custom roles which is available on the Enterprise plan and above. You can only filter by one role ID per request"
    permission_set: Int
    "List users by external id. External id has to be unique for each user under the same account."
    external_id: String
  ): UsersResponse
  "#### Allowed For\n\n* Agents\n"
  ShowUser(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
  ): UserResponse
  "Returns the GDPR status for each user per area of compliance. A Zendesk area of compliance is typically a product like \"support/explore\" but can be more fine-grained for areas within the product lines.\n\nIf the user is not in the account, the request returns a 404 status.\n\n```http\nStatus: 404\n{\n  \"error\":\"RecordNotFound\",\n  \"description\":\"Not found\"\n}\n```\n\n#### Allowed For\n\n* Agents, with restrictions\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n"
  ShowUserComplianceDeletionStatuses(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
    "Area of compliance"
    application: String
  ): ComplianceDeletionStatusesResponse
  "Returns a list of identities for the given user.\n\nUse the first endpoint if authenticating as an agent. Use the second if authenticating as an end user. End users can only list email and phone number identities.\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Agents\n* Verified end users\n"
  ListUserIdentities(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
  ): UserIdentitiesResponse
  "Shows the identity with the given id for a given user.\n\nUse the first endpoint if authenticating as an agent. Use the second if authenticating as an end user. End users can only view email or phone number identity.\n\n#### Allowed For\n\n* Agents\n* Verified end users\n"
  ShowUserIdentity(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
    "The ID of the user identity"
    user_identity_id: Int!
  ): UserIdentityResponse
  "#### Allowed For\n\n* Agents\n* End Users\n"
  GetUserPasswordRequirements(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
  ): UserPasswordRequirementsResponse
  "Show User Related Information"
  ShowUserRelated(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
  ): UserRelatedResponse
  "#### Allowed For\n\n* Admins, Agents, End users\n"
  ShowSession(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
    "The ID of the session"
    session_id: Int!
  ): SessionResponse
  "Archived tickets are not included in the response. See\n[About archived tickets](https://support.zendesk.com/hc/en-us/articles/203657756) in\nthe Support Help Center.\n\n#### Pagination\n\n- Cursor pagination (recommended)\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n* Agents with \"View only\" or higher reports permissions in Support.\n  These permissions are distinct from Explore permissions.\n* Agents retrieving their own skips\n"
  ListTicketSkips(
    subdomain: String = "example"
    domain: String = "zendesk"
    "User ID of an agent"
    user_id: Int!
    sort_order: TicketSortOrder_parameter
  ): TicketSkipsResponse
  "Returns an array of users whose name starts with the value specified in the `name` parameter.\nIt only returns users with no foreign identities.\n\n#### Allowed For\n\n* Agents\n"
  AutocompleteUsers(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The name to search for the user."
    name: String!
    "The id of a lookup relationship field.  The type of field is determined\nby the `source` param"
    field_id: String
    "If a `field_id` is provided, this specifies the type of the field.\nFor example, if the field is on a \"zen:user\", it references a field on a user"
    source: String
  ): UsersResponse
  "Returns an approximate count of users. If the count exceeds 100,000, it is updated every 24 hours.\n\nThe response includes a `refreshed_at` property in a `count` object that contains a timestamp indicating when the count was last updated.\n\n**Note**: When the count exceeds 100,000, the `refreshed_at` property may occasionally be null.\nThis indicates that the count is being updated in the background. The `count` object's `value` property is limited to 100,000 until the update is complete.\n\n#### Allowed For\n\n* Admins, Agents and Light Agents\n"
  CountUsers(
    subdomain: String = "example"
    domain: String = "zendesk"
    role: UserRoleFilter_parameter
    "Filters the results by more than one role using the format `role[]={role}&role[]={role}`"
    role_LEFT_SQUARE_BRACE__RIGHT_SQUARE_BRACE_: String
    "For custom roles which is available on the Enterprise plan and above. You can only filter by one role ID per request"
    permission_set: Int
  ): CountResponse
  "The endpoint returns [user information](/api-reference/ticketing/users/users/) and an `authenticity_token`. \n\n#### Allowed For\n\n* Anonymous users\n\n#### Authenticity Token\n\nZendesk API calls made by end users from a Zendesk help center must include `authenticity_token` in the `X-CSRF-Token` HTTP header. This helps prevent [cross-site request forgery (CSRF)](https://en.wikipedia.org/wiki/Cross-site_request_forgery) attacks.\n\nFor an example using an authenticity token, see the AJAX request in the [Upgrading from Templating API v1](https://developer.zendesk.com/documentation/help_center/help-center-templates/v1#jquery) documentation.\n"
  ShowCurrentUser(subdomain: String = "example", domain: String = "zendesk"): CurrentUserResponse
  "#### Allowed For\n\n* Admins, Agents, End users\n"
  ShowCurrentlyAuthenticatedSession(subdomain: String = "example", domain: String = "zendesk"): SessionResponse
  "#### Allowed For\n\n* Admins, Agents, End users\n"
  RenewCurrentSession(subdomain: String = "example", domain: String = "zendesk"): RenewSessionResponse
  "Returns an array of users who meet the search criteria.\n\n#### Pagination\n\n* Offset pagination only\n\nSee [Using Offset Pagination](/api-reference/ticketing/introduction/#using-offset-pagination).\n\n#### Allowed For\n\n* Admins, Agents and Light Agents\n"
  SearchUsers(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The `query` parameter supports the Zendesk search syntax for more advanced\nuser searches. It can specify a partial or full value of any\nuser property, including name, email address, notes, or phone. Example:\n`query=\"jdoe\"`.\nSee the [Search API](/api-reference/ticketing/ticket-management/search/)."
    query: String
    "The `external_id` parameter does not support the search syntax. It only accepts ids."
    external_id: String
  ): UsersResponse
  "Accepts a comma-separated list of up to 100 user ids or external ids.\n\n#### Allowed For:\n\n* Agents\n"
  ShowManyUsers(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Accepts a comma-separated list of up to 100 user ids."
    ids: String
    "Accepts a comma-separated list of up to 100 external ids."
    external_ids: String
  ): UsersResponse
  "Lists shared and personal views available to the current user.\n\n#### Sideloads\n\nThe following sideloads are supported:\n\n| Name             | Will sideload\n| ---------------- | -------------\n| app_installation | The app installation that requires each view, if present\n| permissions      | The permissions for each view\n\n#### Pagination\n\n- Cursor pagination (recommended, but only sorts by `created_at`)\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Agents\n"
  ListViews(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Only views with given access. May be \"personal\", \"shared\", or \"account\""
    access: String
    "Only active views if true, inactive views if false"
    active: Boolean
    "Only views belonging to given group"
    group_id: Int
    "Possible values are \"alphabetical\", \"created_at\", or \"updated_at\". Defaults to \"position\""
    sort_by: String
    "One of \"asc\" or \"desc\". Defaults to \"asc\" for alphabetical and position sort, \"desc\" for all others"
    sort_order: String
  ): ViewsResponse
  "#### Allowed For\n\n* Agents\n"
  ShowView(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the view"
    view_id: Int!
  ): ViewResponse
  "Returns the ticket count for a single view.\n\nThis endpoint is rate limited to 5 requests per minute, per view, per agent.\n\n#### View Counts\n\nThe view count endpoints, Count Tickets in View (this endpoint) and [Count Tickets in Views](#count-tickets-in-views), let you estimate how many tickets remain in a view without having to retrieve the entire view. They're designed to help estimate view size. From a business perspective, accuracy becomes less relevant as view size increases.\n\nTo ensure quality of service, these counts are cached more heavily as the number of tickets in a view grows. For a view with thousands of tickets, you can expect the count to be cached for 60-90 minutes. As a result, the count may not reflect the actual number of tickets in your view.\n\nView counts are represented as JSON objects with the following attributes:\n\n| Name            | Type        | Comment\n| --------------- | ------------| -------\n| view_id         | integer     | The id of the view\n| url             | string      | The API url of the count\n| value           | integer     | The cached number of tickets in the view. Can also be null if the system is loading and caching new data. Not to be confused with 0 tickets\n| pretty          | string      | A pretty-printed text approximation of the view count\n| fresh           | boolean     | false if the cached data is stale and the system is still loading and caching new data\n| active          | boolean     | Only active views if true, inactive views if false, all views if null.\n\n#### Example\n```js\n{\n  \"view_count\": {\n    \"view_id\": 25,\n    \"url\":     \"https://company.zendesk.com/api/v2/views/25/count.json\",\n    \"value\":   719,\n    \"pretty\":  \"~700\",\n    \"fresh\":   true\n  }\n}\n```\n"
  GetViewCount(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the view"
    view_id: Int!
  ): ViewCountResponse
  "Returns the column titles and the rows of the specified view.\n\nThe `columns` array lists the view's column titles and includes only views parameters.\n\nThe `rows` array lists the values of each column for each ticket and includes parameters from both views and tickets. Though not displayed in the view, a partial ticket object is included with each row object.\n\n**Note**: To get the full ticket objects for a specified view, use [List Tickets from a View](#list-tickets-from-a-view).\n\nThis endpoint is rate limited to 5 requests per minute, per view, per agent.\n\nThe view execution system is designed for periodic rather than high-frequency API usage. In particular, views called very frequently may be cached by Zendesk. This means that the API client will still receive a result, but that result may have been computed at any time within the last 10 minutes.\n\nZendesk recommends using the Incremental Ticket Export endpoint to get the latest changes. You can call it more often, and it returns all the tickets that changed since the last poll. For details and rate limits, see [Incremental Exports](/api-reference/ticketing/ticket-management/incremental_exports/).\n\nView output sorting can be controlled by passing the `sort_by` and `sort_order` parameters in the format described in the table in [Preview Views](#preview-views).\n\n#### Allowed For\n\n* Agents\n\n#### Pagination\n\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n"
  ExecuteView(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the view"
    view_id: Int!
    "The ticket field used for sorting. This will either be a title or a custom field id."
    sort_by: String
    "The direction the tickets are sorted. May be one of 'asc' or 'desc'"
    sort_order: String
  ): ViewResponse
  "Returns the csv attachment of the specified view if possible. Enqueues a job to produce the csv if necessary.\n\n#### Allowed For\n\n* Agents\n"
  ExportView(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the view"
    view_id: Int!
  ): ViewExportResponse
  "#### Allowed For\n\n* Agents\n\n#### Pagination\n* Cursor pagination (recommended)\n* Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n"
  ListTicketsFromView(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the view"
    view_id: Int!
    "Sort or group the tickets by a column in the [View columns](#view-columns) table. The `subject` and `submitter` columns are not supported"
    sort_by: String
    "One of \"asc\" or \"desc\". Defaults to \"asc\" for alphabetical and position sort, \"desc\" for all others"
    sort_order: String
  ): TicketsResponse
  "Lists active shared and personal views available to the current user.\n\n#### Sideloads\n\nThe following sideloads are supported:\n\n| Name             | Will sideload\n| ---------------- | -------------\n| app_installation | The app installation that requires each view, if present\n| permissions      | The permissions for each view\n\n#### Pagination\n\n- Offset pagination\n\nSee [Pagination](/api-reference/introduction/pagination/).\n\nReturns a maximum of 100 records per page.\n\n#### Allowed For\n\n* Agents\n"
  ListActiveViews(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Only views with given access. May be \"personal\", \"shared\", or \"account\""
    access: String
    "Only views belonging to given group"
    group_id: Int
    "Possible values are \"alphabetical\", \"created_at\", or \"updated_at\". Defaults to \"position\""
    sort_by: String
    "One of \"asc\" or \"desc\". Defaults to \"asc\" for alphabetical and position sort, \"desc\" for all others"
    sort_order: String
  ): ViewsResponse
  "A compacted list of shared and personal views available to the current user. This endpoint never returns more than 32 records and does not respect the \"per_page\" option.\n\n#### Allowed For\n\n* Agents\n"
  ListCompactViews(subdomain: String = "example", domain: String = "zendesk"): ViewsResponse
  "Returns an approximate count of shared and personal views available to the current user. If the count exceeds 100,000, the count will return a cached result.  This cached result will update every 24 hours.\n\nThe `count[refreshed_at]` property is a timestamp that indicates when the count was last updated.\n\n**Note**: When the count exceeds 100,000, `count[refreshed_at]` may occasionally be null.\nThis indicates that the count is being updated in the background, and `count[value]` is limited to 100,000 until the update is complete.\n\n#### Allowed For\n* Agents"
  CountViews(subdomain: String = "example", domain: String = "zendesk"): ViewsCountResponse
  "Returns the ticket count of each view in a list of views. Accepts up to 20 view ids per request. For the ticket count of a single view, see [Count Tickets in View](#count-tickets-in-view).\n\nOnly returns values for personal and shared views accessible to the user performing the request.\n\nThis endpoint is rate limited to 6 requests every 5 minutes.\n\n#### Allowed For\n\n* Agents\n"
  GetViewCounts(
    subdomain: String = "example"
    domain: String = "zendesk"
    "List of view's ids separated by commas."
    ids: String!
  ): ViewCountsResponse
  "#### Pagination\n\n* Offset pagination only\n\nSee [Using Offset Pagination](/api-reference/ticketing/introduction/#using-offset-pagination).\n\n#### Allowed For\n\n* Agents\n\n#### Sideloads\n\nThe following sideloads are supported. For more information, see [Side-loading](/documentation/ticketing/using-the-zendesk-api/side_loading/).\n\n| Name             | Will sideload\n| ---------------- | -------------\n| app_installation | The app installation that requires each view, if present\n| permissions      | The permissions for each view\n"
  SearchViews(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Query string used to find all views with matching title"
    query: String!
    "Filter views by access. May be \"personal\", \"shared\", or \"account\""
    access: String
    "Filter by active views if true or inactive views if false"
    active: Boolean
    "Filter views by group"
    group_id: Int
    "Possible values are \"alphabetical\", \"created_at\", \"updated_at\", and \"position\". If unspecified, the views are sorted by relevance"
    sort_by: String
    "One of \"asc\" or \"desc\". Defaults to \"asc\" for alphabetical and position sort, \"desc\" for all others"
    sort_order: String
    "A sideload to include in the response. See [Sideloads](#sideloads-3)"
    include: String
  ): ViewsResponse
  "#### Allowed For\n\n* Agents\n\n#### Sideloads\n\nThe following sideloads are supported:\n\n| Name             | Will sideload\n| ---------------- | -------------\n| app_installation | The app installation that requires each view, if present\n| permissions      | The permissions for each view\n"
  ListViewsById(
    subdomain: String = "example"
    domain: String = "zendesk"
    "List of view's ids separated by commas."
    ids: String!
    "Only active views if true, inactive views if false"
    active: Boolean
  ): ViewsResponse
  "#### Allowed For\n\n* Admins, Agents\n"
  ListWorkspaces(subdomain: String = "example", domain: String = "zendesk"): WorkspaceResponse
  "#### Allowed For\n* Admins\n"
  ShowWorkspace(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the workspace"
    workspace_id: Int!
  ): ShowWorkspace_200_response
}

type AssigneeFieldAssignableGroupsAndAgentsSearchResponse {
  agents: [AssigneeFieldAssignableSearchAgentObject]
  "Number of agents + groups listed from search result."
  count: Int
  groups: [AssigneeFieldAssignableSearchGroupObject]
}

type AssigneeFieldAssignableSearchAgentObject {
  "Name of the agent's group"
  group: String
  "Agent's Group ID"
  group_id: Int
  "Agent ID"
  id: Int
  "Name of the agent"
  name: String
  "URL of Avatar"
  photo_url: String
}

type AssigneeFieldAssignableSearchGroupObject {
  "Group ID"
  id: Int
  "Name of the group"
  name: String
}

type AssigneeFieldAssignableGroupsResponse {
  "Number of groups listed in `groups` property."
  count: Int
  groups: [AssigneeFieldAssignableGroups]
  next_page: String
  previous_page: String
}

type AssigneeFieldAssignableGroups {
  "Description of the group"
  description: String
  "Group ID"
  id: Int
  "Name of the group"
  name: String
}

type AssigneeFieldAssignableGroupAgentsResponse {
  agents: [AssigneeFieldAssignableAgents]
  "Number of agents listed in `agents` property."
  count: Int
  next_page: String
  previous_page: String
}

type AssigneeFieldAssignableAgents {
  "URL of Agent's avatar"
  avatar_url: String
  "Agent Support ID"
  id: Int
  "Name of the agent"
  name: String
}

type ReverseLookupResponse {
  users: [UserObject]
}

type UserObject {
  "false if the user has been deleted"
  active: Boolean
  "An alias displayed to end users"
  alias: String
  "Whether or not the user is a chat-only agent"
  chat_only: Boolean
  "The time the user was created"
  created_at: String
  "A custom role if the user is an agent on the Enterprise plan or above"
  custom_role_id: Int
  "The id of the user's default group"
  default_group_id: Int
  "Any details you want to store about the user, such as an address"
  details: String
  "The primary email address of this user. If the primary email address is not [verified](https://support.zendesk.com/hc/en-us/articles/4408886752410), the secondary email address is used"
  email: String
  "A unique identifier from another system. The API treats the id as case insensitive. Example: \"ian1\" and \"IAN1\" are the same value."
  external_id: String
  "The time zone for the user"
  iana_time_zone: String
  "Automatically assigned when creating users"
  id: Int
  "Last time the user signed in to Zendesk Support or made an API request\nusing an API token or basic authentication"
  last_login_at: String
  "The locale for this user"
  locale: String
  "The language identifier for this user"
  locale_id: Int
  "Designates whether the user has forum moderation capabilities"
  moderator: Boolean
  "The name of the user"
  name: String!
  "Any notes you want to store about the user"
  notes: String
  "true if the user can only create private comments"
  only_private_comments: Boolean
  "The id of the user's organization. If the user has more than one [organization memberships](/api-reference/ticketing/organizations/organization_memberships/), the id of the user's default organization. If updating, see [Organization ID](/api-reference/ticketing/users/users/#organization-id)"
  organization_id: Int
  "The primary phone number of this user. See [Phone Number](/api-reference/ticketing/users/users/#phone-number) in the Users API"
  phone: String
  "The user's profile picture represented as an [Attachment](/api-reference/ticketing/tickets/ticket-attachments/) object"
  photo: AWSJSON
  "A URL pointing to the user's profile picture."
  remote_photo_url: String
  "This parameter is inert and has no effect. It may be deprecated in the\nfuture.\n\nPreviously, this parameter determined whether a user could access a CSV\nreport in a legacy Guide dashboard. This dashboard has been removed. See\n[Announcing Guide legacy reporting upgrade to\nExplore](https://support.zendesk.com/hc/en-us/articles/4762263171610-Announcing-Guide-legacy-reporting-upgrade-to-Explore-)"
  report_csv: Boolean
  "If the agent has any restrictions; false for admins and unrestricted agents, true for other agents"
  restricted_agent: Boolean
  "The role of the user. Possible values: `\"end-user\"`, `\"agent\"`, `\"admin\"`"
  role: String
  "The user's role id. 0 for a custom agent, 1 for a light agent, 2 for a chat agent, 3 for a chat agent added to the Support account as a contributor ([Chat Phase 4](https://support.zendesk.com/hc/en-us/articles/360022365373#topic_djh_1zk_4fb)), 4 for an admin, and 5 for a billing admin"
  role_type: Int
  "If the user is shared from a different Zendesk Support instance. Ticket sharing accounts only"
  shared: Boolean
  "If the user is a shared agent from a different Zendesk Support instance. Ticket sharing accounts only"
  shared_agent: Boolean
  "Whether the `phone` number is shared or not. See [Phone Number](/api-reference/ticketing/users/users/#phone-number) in the Users API"
  shared_phone_number: Boolean
  "The user's signature. Only agents and admins can have signatures"
  signature: String
  "If the agent is suspended. Tickets from suspended users are also suspended, and these users cannot sign in to the end user portal"
  suspended: Boolean
  "The user's tags. Only present if your account has user tagging enabled"
  tags: [String]
  "Specifies which tickets the user has access to. Possible values are: \"organization\", \"groups\", \"assigned\", \"requested\", null. \"groups\" and \"assigned\" are valid only for agents. If you pass an invalid value to an end user (for example, \"groups\"), they will be assigned to \"requested\", regardless of their previous access"
  ticket_restriction: String
  "The time-zone of this user"
  time_zone: String
  "If two factor authentication is enabled"
  two_factor_auth_enabled: Boolean
  "The time of the last update of the user"
  updated_at: String
  "The API url of this user"
  url: String
  "Values of custom fields in the user's profile. See [User Fields](#user-fields)"
  user_fields: AWSJSON
  "Any of the user's identities is verified. See [User Identities](/api-reference/ticketing/users/user_identities)"
  verified: Boolean
  additionalProperties: AWSJSON
}

type AccountSettingsResponse {
  settings: AccountSettingsObject
}

type AccountSettingsObject {
  active_features: AccountSettingsActiveFeaturesObject
  agents: AccountSettingsAgentObject
  api: AccountSettingsApiObject
  apps: AccountSettingsAppsObject
  billing: AccountSettingsBillingObject
  branding: AccountSettingsBrandingObject
  brands: AccountSettingsBrandsObject
  cdn: AccountSettingsCdnObject
  chat: AccountSettingsChatObject
  cross_sell: AccountSettingsCrossSellObject
  gooddata_advanced_analytics: AccountSettingsGooddataAdvancedAnalyticsObject
  google_apps: AccountSettingsGoogleAppsObject
  groups: AccountSettingsGroupObject
  limits: AccountSettingsLimitsObject
  localization: AccountSettingsLocalizationObject
  lotus: AccountSettingsLotusObject
  metrics: AccountSettingsMetricsObject
  onboarding: AccountSettingsOnboardingObject
  routing: AccountSettingsRoutingObject
  rule: AccountSettingsRuleObject
  side_conversations: AccountSettingsSideConversationsObject
  statistics: AccountSettingsStatisticsObject
  ticket_form: AccountSettingsTicketFormObject
  ticket_sharing_partners: AccountSettingsTicketSharingPartnersObject
  tickets: AccountSettingsTicketObject
  twitter: AccountSettingsTwitterObject
  user: AccountSettingsUserObject
  voice: AccountSettingsVoiceObject
}

"The active features for an account. See [Active Features](#active-features)"
type AccountSettingsActiveFeaturesObject {
  advanced_analytics: Boolean
  agent_forwarding: Boolean
  allow_ccs: Boolean
  allow_email_template_customization: Boolean
  automatic_answers: Boolean
  bcc_archiving: Boolean
  benchmark_opt_out: Boolean
  business_hours: Boolean
  chat: Boolean
  chat_about_my_ticket: Boolean
  csat_reason_code: Boolean
  custom_dkim_domain: Boolean
  customer_context_as_default: Boolean
  customer_satisfaction: Boolean
  dynamic_contents: Boolean
  explore: Boolean
  explore_on_support_ent_plan: Boolean
  explore_on_support_pro_plan: Boolean
  facebook: Boolean
  facebook_login: Boolean
  fallback_composer: Boolean
  forum_analytics: Boolean
  good_data_and_explore: Boolean
  google_login: Boolean
  insights: Boolean
  is_abusive: Boolean
  light_agents: Boolean
  markdown: Boolean
  on_hold_status: Boolean
  organization_access_enabled: Boolean
  rich_content_in_emails: Boolean
  sandbox: Boolean
  satisfaction_prediction: Boolean
  suspended_ticket_notification: Boolean
  ticket_forms: Boolean
  ticket_tagging: Boolean
  topic_suggestion: Boolean
  twitter: Boolean
  twitter_login: Boolean
  user_org_fields: Boolean
  user_tagging: Boolean
  voice: Boolean
}

"Configuration for the agent workspace. See [Agents](#agents)"
type AccountSettingsAgentObject {
  agent_home: Boolean
  agent_workspace: Boolean
  aw_self_serve_migration_enabled: Boolean
  focus_mode: Boolean
  idle_timeout_enabled: Boolean
  unified_agent_statuses: Boolean
}

"API configuration options. See [API](#api)"
type AccountSettingsApiObject {
  accepted_api_agreement: Boolean
  api_password_access: String
  api_token_access: String
}

"Apps configuration options. See [Apps](#apps)"
type AccountSettingsAppsObject {
  create_private: Boolean
  create_public: Boolean
  use: Boolean
}

"Billing configuration options. See [Billing](#billing)"
type AccountSettingsBillingObject {
  backend: String
}

"Branding settings. See [Branding](#branding)"
type AccountSettingsBrandingObject {
  favicon_url: String
  header_color: String
  header_logo_url: String
  page_background_color: String
  tab_background_color: String
  text_color: String
}

"Brand settings. See [Brands](#brands)"
type AccountSettingsBrandsObject {
  default_brand_id: Int
  require_brand_on_new_tickets: Boolean
}

"CDN settings"
type AccountSettingsCdnObject {
  cdn_provider: String
  fallback_cdn_provider: String
  hosts: [query_ShowAccountSettings_settings_cdn_hosts_items]
}

type query_ShowAccountSettings_settings_cdn_hosts_items {
  name: String
  url: String
}

"Zendesk Chat settings. See [Chat](#chat)"
type AccountSettingsChatObject {
  available: Boolean
  enabled: Boolean
  integrated: Boolean
  maximum_request_count: Int
  welcome_message: String
}

"Cross Sell settings"
type AccountSettingsCrossSellObject {
  show_chat_tooltip: Boolean
  xsell_source: String
}

"GoodData settings, used for insights. Legacy configuration prior to Zendesk Explore. See [GoodData Advanced Analytics](#gooddata-advanced-analytics)"
type AccountSettingsGooddataAdvancedAnalyticsObject {
  enabled: Boolean
}

"Google Apps configuration. See [G Suite](#g-suite)"
type AccountSettingsGoogleAppsObject {
  has_google_apps: Boolean
  has_google_apps_admin: Boolean
}

"Group configuration"
type AccountSettingsGroupObject {
  check_group_name_uniqueness: Boolean
}

"Account limits configuration. See [Limits](#limits)"
type AccountSettingsLimitsObject {
  attachment_size: Int
}

"Internationalization configuration settings. See [Localization](#localization)"
type AccountSettingsLocalizationObject {
  locale_ids: [Int]
}

"Support UI settings. See [Lotus](#lotus)"
type AccountSettingsLotusObject {
  pod_id: Int
  prefer_lotus: Boolean
  reporting: Boolean
}

"Account metrics settings. See [Metrics](#metrics)"
type AccountSettingsMetricsObject {
  account_size: String
}

"Onboarding settings"
type AccountSettingsOnboardingObject {
  checklist_onboarding_version: Int
  onboarding_segments: String
  product_sign_up: String
}

"Configuration for routing. See [Routing](#routing)"
type AccountSettingsRoutingObject {
  autorouting_tag: String
  enabled: Boolean
  max_email_capacity: Int
  max_messaging_capacity: Int
  reassignment_messaging_enabled: Boolean
  reassignment_messaging_timeout: Int
  reassignment_talk_timeout: Int
}

"Rules settings for triggers, macros, views, and automations. See [Rules](#rules)"
type AccountSettingsRuleObject {
  macro_most_used: Boolean
  macro_order: String
  skill_based_filtered_views: [AWSJSON]
  using_skill_based_routing: Boolean
}

"Side conversations settings"
type AccountSettingsSideConversationsObject {
  email_channel: Boolean
  msteams_channel: Boolean
  show_in_context_panel: Boolean
  slack_channel: Boolean
  tickets_channel: Boolean
}

"Account statistics settings. See [Statistics](#statistics)"
type AccountSettingsStatisticsObject {
  forum: Boolean
  rule_usage: Boolean
  search: Boolean
}

"Ticket form settings. See [Ticket Form](#ticket-form)"
type AccountSettingsTicketFormObject {
  raw_ticket_forms_instructions: String
  ticket_forms_instructions: String
}

"Ticket sharing partners settings. See [Ticket Sharing Partners](#ticket-sharing-partners)"
type AccountSettingsTicketSharingPartnersObject {
  support_addresses: [String]
}

"Ticket settings. See [Tickets](#tickets)"
type AccountSettingsTicketObject {
  accepted_new_collaboration_tos: Boolean
  agent_collision: Boolean
  agent_invitation_enabled: Boolean
  agent_ticket_deletion: Boolean
  allow_group_reset: Boolean
  assign_default_organization: Boolean
  assign_tickets_upon_solve: Boolean
  auto_translation_enabled: Boolean
  auto_updated_ccs_followers_rules: Boolean
  chat_sla_enablement: Boolean
  collaboration: Boolean
  comments_public_by_default: Boolean
  email_attachments: Boolean
  emoji_autocompletion: Boolean
  follower_and_email_cc_collaborations: Boolean
  has_color_text: Boolean
  is_first_comment_private_enabled: Boolean
  light_agent_email_ccs_allowed: Boolean
  list_empty_views: Boolean
  list_newest_comments_first: Boolean
  markdown_ticket_comments: Boolean
  maximum_personal_views_to_list: Int
  private_attachments: Boolean
  rich_text_comments: Boolean
  status_hold: Boolean
  tagging: Boolean
  using_skill_based_routing: Boolean
}

"X (formerly Twitter) settings. See [X](#x-formerly-twitter)"
type AccountSettingsTwitterObject {
  shorten_url: String
}

"User settings. See [Users](#users)"
type AccountSettingsUserObject {
  agent_created_welcome_emails: Boolean
  end_user_phone_number_validation: Boolean
  have_gravatars_enabled: Boolean
  language_selection: Boolean
  multiple_organizations: Boolean
  tagging: Boolean
  time_zone_selection: Boolean
}

"Zendesk Talk settings. See [Voice](#voice)"
type AccountSettingsVoiceObject {
  agent_confirmation_when_forwarding: Boolean
  agent_wrap_up_after_calls: Boolean
  enabled: Boolean
  logging: Boolean
  maximum_queue_size: Int
  maximum_queue_wait_time: Int
  only_during_business_hours: Boolean
  outbound_enabled: Boolean
  recordings_public: Boolean
  uk_mobile_forwarding: Boolean
}

type VerifySubdomainAvailability_200_response {
  success: Boolean
}

type ActivitiesResponse {
  activities: [Ticket_Activities]
  actors: [AWSJSON]
  count: Int
  next_page: String
  previous_page: String
  users: [AWSJSON]
}

type Ticket_Activities {
  actor: UserObject
  "The id of the user responsible for the ticket activity. An `actor_id` of \"-1\" is a Zendesk system user, such as an automations action."
  actor_id: Int
  "When the record was created"
  created_at: String
  "Automatically assigned on creation"
  id: Int
  "The content of the activity. Can be a ticket, comment, or change."
  object: AWSJSON
  "The target of the activity, a ticket."
  target: AWSJSON
  "Description of the activity"
  title: String
  "When the record was last updated"
  updated_at: String
  "The API url of the activity"
  url: String
  user: UserObject
  "The id of the agent making the request"
  user_id: Int
  "The type of activity. Can be \"tickets.assignment\", \"tickets.comment\", or \"tickets.priority_increase\""
  verb: String
}

type ActivityResponse {
  activity: Ticket_Activities
}

type ActivitiesCountResponse {
  count: query_CountActivities_count
}

type query_CountActivities_count {
  refreshed_at: AWSDateTime
  value: Int
}

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar AWSDateTime

type AttachmentResponse {
  attachment: AttachmentObject
}

"A file represented as an [Attachment](/api-reference/ticketing/tickets/ticket-attachments/) object"
type AttachmentObject {
  "The content type of the image. Example value: \"image/png\""
  content_type: String
  "A full URL where the attachment image file can be downloaded. The file may be hosted externally so take care not to inadvertently send Zendesk authentication credentials. See [Working with url properties](/documentation/ticketing/managing-tickets/working-with-url-properties)"
  content_url: String
  "If true, the attachment has been deleted"
  deleted: Boolean
  "The name of the image file"
  file_name: String
  "The height of the image file in pixels. If height is unknown, returns null"
  height: String
  "Automatically assigned when created"
  id: Int
  "If true, the attachment is excluded from the attachment list and the attachment's URL\ncan be referenced within the comment of a ticket. Default is false"
  inline: Boolean
  "If true, you can download an attachment flagged as malware. If false, you can't download such an attachment."
  malware_access_override: Boolean
  "The result of the malware scan. There is a delay between the time the attachment is uploaded and when the malware scan is completed. Usually the scan is done within a few seconds, but high load conditions can delay the scan results. Possible values: \"malware_found\", \"malware_not_found\", \"failed_to_scan\", \"not_scanned\""
  malware_scan_result: String
  "The URL the attachment image file has been mapped to"
  mapped_content_url: String
  "The size of the image file in bytes"
  size: Int
  "A URL to access the attachment details"
  url: String
  "The width of the image file in pixels. If width is unknown, returns null"
  width: String
  "An array of attachment objects. Note that photo thumbnails do not have thumbnails"
  thumbnails: [AttachmentBaseObject]
}

type AttachmentBaseObject {
  "The content type of the image. Example value: \"image/png\""
  content_type: String
  "A full URL where the attachment image file can be downloaded. The file may be hosted externally so take care not to inadvertently send Zendesk authentication credentials. See [Working with url properties](/documentation/ticketing/managing-tickets/working-with-url-properties)"
  content_url: String
  "If true, the attachment has been deleted"
  deleted: Boolean
  "The name of the image file"
  file_name: String
  "The height of the image file in pixels. If height is unknown, returns null"
  height: String
  "Automatically assigned when created"
  id: Int
  "If true, the attachment is excluded from the attachment list and the attachment's URL\ncan be referenced within the comment of a ticket. Default is false"
  inline: Boolean
  "If true, you can download an attachment flagged as malware. If false, you can't download such an attachment."
  malware_access_override: Boolean
  "The result of the malware scan. There is a delay between the time the attachment is uploaded and when the malware scan is completed. Usually the scan is done within a few seconds, but high load conditions can delay the scan results. Possible values: \"malware_found\", \"malware_not_found\", \"failed_to_scan\", \"not_scanned\""
  malware_scan_result: String
  "The URL the attachment image file has been mapped to"
  mapped_content_url: String
  "The size of the image file in bytes"
  size: Int
  "A URL to access the attachment details"
  url: String
  "The width of the image file in pixels. If width is unknown, returns null"
  width: String
}

type AuditLogsResponse {
  audit_logs: [AuditLogObject]
}

type AuditLogObject {
  "Type of change made. Possible values are \"create\", \"destroy\", \"exported\", \"login\", and \"update\""
  action: String
  "Localized string of action field"
  action_label: String
  "id of the user or system that initiated the change"
  actor_id: Int
  "Name of the user or system that initiated the change"
  actor_name: String
  "The description of the change that occurred"
  change_description: String
  "The time the audit got created"
  created_at: AWSDateTime
  "The id automatically assigned upon creation"
  id: Int
  "The IP address of the user doing the audit"
  ip_address: String
  "The id of the item being audited"
  source_id: Int
  "The name of the item being audited"
  source_label: String
  "Item type being audited. Typically describes the system where the change\nwas initiated. Possible values vary based on your account's Zendesk\nproducts and activity. Common values include \"apitoken\", \"rule\", \"ticket\",\n\"user\", and \"zendesk/app_market/app\". The \"rule\" value is used for\n[automations](https://support.zendesk.com/hc/en-us/articles/4408832701850),\n[macros](https://support.zendesk.com/hc/en-us/articles/4408844187034),\n[triggers](https://support.zendesk.com/hc/en-us/articles/4408822236058),\n[views](https://support.zendesk.com/hc/en-us/articles/4408888828570),\nand other automated business rules"
  source_type: String
  "The URL to access the audit log"
  url: String
}

type AuditLogResponse {
  audit_log: AuditLogObject
}

type TagsByObjectIdResponse {
  "An array of strings"
  tags: [String]!
}

type AutomationsResponse {
  automations: [AutomationObject]
  count: Int
  next_page: String
  previous_page: String
}

type AutomationObject {
  "An object describing what the automation will do. See [Actions reference](/documentation/ticketing/reference-guides/actions-reference)"
  actions: [ActionObject]
  "Whether the automation is active"
  active: Boolean
  conditions: ConditionsObject
  "The time the automation was created"
  created_at: AWSDateTime
  "If true, the automation is a default automation"
  default: Boolean
  "Automatically assigned when created"
  id: Int
  "The position of the automation which specifies the order it will be executed"
  position: Int
  "The raw title of the automation"
  raw_title: String
  "The title of the automation"
  title: String
  "The time of the last update of the automation"
  updated_at: AWSDateTime
}

type ActionObject {
  "The name of a ticket field to modify"
  field: String
  "The new value of the field"
  value: String
}

"An object that describes the conditions under which the automation will execute. See [Conditions reference](/documentation/ticketing/reference-guides/conditions-reference)"
type ConditionsObject {
  "Logical AND. Tickets must fulfill all of the conditions to be considered matching"
  all: [ConditionObject]
  "Logical OR. Tickets may satisfy any of the conditions to be considered matching"
  any: [ConditionObject]
}

type ConditionObject {
  "The name of a ticket field"
  field: String
  "A comparison operator"
  operator: String
  "The value of a ticket field"
  value: String
}

type AutomationResponse {
  automation: AutomationObject
}

type BookmarksResponse {
  "the total record count"
  count: Int
  "the URL of the next page"
  next_page: String
  "the URL of the previous page"
  previous_page: String
  bookmarks: [BookmarkObject]
}

type BookmarkObject {
  "The time the bookmark was created"
  created_at: AWSDateTime
  "Automatically assigned when the bookmark is created"
  id: Int
  ticket: TicketObject
  "The API url of this bookmark"
  url: String
}

type TicketObject {
  "Permission for agents to add add attachments to a comment. Defaults to true"
  allow_attachments: Boolean
  "Is false if channelback is disabled, true otherwise. Only applicable for channels framework ticket"
  allow_channelback: Boolean
  "Write only. The email address of the agent to assign the ticket to"
  assignee_email: String
  "The agent currently assigned to the ticket"
  assignee_id: Int
  "Write only. An array of the IDs of attribute values to be associated with the ticket"
  attribute_value_ids: [Int]
  "The id of the brand this ticket is associated with. See [Setting up multiple brands](https://support.zendesk.com/hc/en-us/articles/4408829476378)"
  brand_id: Int
  "The ids of users currently CC'ed on the ticket"
  collaborator_ids: [Int]
  "POST requests only. Users to add as cc's when creating a ticket. See [Setting Collaborators](/documentation/ticketing/managing-tickets/creating-and-updating-tickets#setting-collaborators)"
  collaborators: [CollaboratorObject]
  comment: AWSJSON
  "When this record was created"
  created_at: AWSDateTime
  "Custom fields for the ticket. See [Setting custom field values](/documentation/ticketing/managing-tickets/creating-and-updating-tickets#setting-custom-field-values)"
  custom_fields: [query_ListBookmarks_allOf_1_bookmarks_items_ticket_custom_fields_items]
  "The custom ticket status id of the ticket. See [custom ticket statuses](#custom-ticket-statuses)"
  custom_status_id: Int
  "Read-only first comment on the ticket. When [creating a ticket](#create-ticket), use `comment` to set the description. See [Description and first comment](#description-and-first-comment)"
  description: String
  "If this is a ticket of type \"task\" it has a due date.  Due date format uses [ISO 8601](http://en.wikipedia.org/wiki/ISO_8601) format"
  due_at: AWSDateTime
  "The ids of agents or end users currently CC'ed on the ticket. See [CCs and followers resources](https://support.zendesk.com/hc/en-us/articles/360020585233) in the Support Help Center"
  email_cc_ids: [Int]
  email_ccs: AWSJSON
  "An id you can use to link Zendesk Support tickets to local records"
  external_id: String
  "The ids of agents currently following the ticket. See [CCs and followers resources](https://support.zendesk.com/hc/en-us/articles/360020585233)"
  follower_ids: [Int]
  followers: AWSJSON
  "The ids of the followups created from this ticket. Ids are only visible once the ticket is closed"
  followup_ids: [Int]
  "The topic in the Zendesk Web portal this ticket originated from, if any. The Web portal is deprecated"
  forum_topic_id: Int
  "If true, the ticket's [via type](/documentation/ticketing/reference-guides/via-object-reference/) is a messaging channel."
  from_messaging_channel: Boolean
  "The group this ticket is assigned to"
  group_id: Int
  "Is true if a ticket is a problem type and has one or more incidents linked to it. Otherwise, the value is false."
  has_incidents: Boolean
  "Automatically assigned when the ticket is created"
  id: Int
  "Is true if any comments are public, false otherwise"
  is_public: Boolean
  "Write only. A macro ID to be recorded in the ticket audit"
  macro_id: Int
  "POST requests only. List of macro IDs to be recorded in the ticket audit"
  macro_ids: [Int]
  metadata: AWSJSON
  "The organization of the requester. You can only specify the ID of an organization associated with the requester. See [Organization Memberships](/api-reference/ticketing/organizations/organization_memberships/)"
  organization_id: Int
  priority: query_ListBookmarks_allOf_1_bookmarks_items_ticket_priority
  "For tickets of type \"incident\", the ID of the problem the incident is linked to"
  problem_id: Int
  "The dynamic content placeholder, if present, or the \"subject\" value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_subject: String
  "The original recipient e-mail address of the ticket. Notification emails for the ticket are sent from this address"
  recipient: String
  requester: AWSJSON
  "The user who requested this ticket"
  requester_id: Int!
  "Write only. Optional boolean. When true and an `update_stamp` date is included, protects against ticket update collisions and returns a message to let you know if one occurs. See [Protecting against ticket update collisions](/documentation/ticketing/managing-tickets/creating-and-updating-tickets/#protecting-against-ticket-update-collisions). A value of false has the same effect as true. Omit the property to force the updates to not be safe"
  safe_update: Boolean
  "The satisfaction rating of the ticket, if it exists, or the state of satisfaction, \"offered\" or \"unoffered\". The value is null for plan types that don't support CSAT"
  satisfaction_rating: AWSJSON
  "The ids of the sharing agreements used for this ticket"
  sharing_agreement_ids: [Int]
  status: query_ListBookmarks_allOf_1_bookmarks_items_ticket_status
  "The value of the subject field for this ticket. See [Subject](/api-reference/ticketing/tickets/tickets/#subject)"
  subject: String
  "The user who submitted the ticket. The submitter always becomes the author of the first comment on the ticket"
  submitter_id: Int
  "The array of tags applied to this ticket. Unless otherwise specified, the [set tag](/api-reference/ticketing/ticket-management/tags/#set-tags) behavior is used, which overwrites and replaces existing tags"
  tags: [String]
  "Enterprise only. The id of the ticket form to render for the ticket"
  ticket_form_id: Int
  type: query_ListBookmarks_allOf_1_bookmarks_items_ticket_type
  "When this record last got updated. It is updated only if the update generates a [ticket event](#incremental-ticket-event-export)"
  updated_at: AWSDateTime
  "Write only. Datetime of last update received from API. See the `safe_update` property"
  updated_stamp: String
  "The API url of this ticket"
  url: String
  via: query_ListBookmarks_allOf_1_bookmarks_items_ticket_via
  "POST requests only. The id of a closed ticket when creating a follow-up ticket. See [Creating a follow-up ticket](/documentation/ticketing/managing-tickets/creating-and-updating-tickets#creating-a-follow-up-ticket)"
  via_followup_source_id: Int
  "Write only. For more information, see the [Via object reference](/documentation/ticketing/reference-guides/via-object-reference/)"
  via_id: Int
  voice_comment: AWSJSON
}

type CollaboratorObject {
  email: AWSEmail
  name: String
}

"A field whose value conforms to the standard internet email address format as specified in HTML Spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address."
scalar AWSEmail

type query_ListBookmarks_allOf_1_bookmarks_items_ticket_custom_fields_items {
  "The id of the custom field"
  id: Int
  "The value of the custom field"
  value: String
}

"The urgency with which the ticket should be addressed"
enum query_ListBookmarks_allOf_1_bookmarks_items_ticket_priority {
  urgent
  high
  normal
  low
}

"The state of the ticket.\n\nIf your account has activated custom ticket statuses, this is the ticket's\nstatus category. See [custom ticket statuses](#custom-ticket-statuses)"
enum query_ListBookmarks_allOf_1_bookmarks_items_ticket_status {
  new
  open
  pending
  hold
  solved
  closed
}

"The type of this ticket"
enum query_ListBookmarks_allOf_1_bookmarks_items_ticket_type {
  problem
  incident
  question
  task
}

"For more information, see the [Via object reference](/documentation/ticketing/reference-guides/via-object-reference)"
type query_ListBookmarks_allOf_1_bookmarks_items_ticket_via {
  "This tells you how the ticket or event was created. Examples: \"web\", \"mobile\", \"rule\", \"system\""
  channel: String
  "For some channels a source object gives more information about how or why the ticket or event was created"
  source: AWSJSON
}

type BrandsResponse {
  "the total record count"
  count: Int
  "the URL of the next page"
  next_page: String
  "the URL of the previous page"
  previous_page: String
  "Array of brands"
  brands: [BrandObject]
}

type BrandObject {
  "If the brand is set as active"
  active: Boolean
  "The url of the brand"
  brand_url: String
  "The time the brand was created"
  created_at: AWSDateTime
  "Is the brand the default brand for this account"
  default: Boolean
  "If the brand has a Help Center"
  has_help_center: Boolean
  help_center_state: query_ListBrands_allOf_1_brands_items_help_center_state
  "The hostmapping to this brand, if any. Only admins view this property."
  host_mapping: String
  "The ID automatically assigned when the brand is created"
  id: Int
  "If the brand object is deleted or not"
  is_deleted: Boolean
  logo: AttachmentObject
  "The name of the brand"
  name: String!
  "The signature template for a brand"
  signature_template: String
  "The subdomain of the brand"
  subdomain: String!
  "The ids of ticket forms that are available for use by a brand"
  ticket_form_ids: [Int]
  "The time of the last update of the brand"
  updated_at: AWSDateTime
  "The API url of this brand"
  url: String
}

"The state of the Help Center"
enum query_ListBrands_allOf_1_brands_items_help_center_state {
  enabled
  disabled
  restricted
}

type BrandResponse {
  brand: BrandObject
}

type Host_Mapping {
  "The canonical name record for a host mapping"
  cname: String
  "Array of expected CNAME records for host mapping(s) of a given brand"
  expected_cnames: [String]
  "Whether a host mapping is valid or not for a given brand"
  is_valid: Boolean
  "Reason why a host mapping is valid or not"
  reason: String
}

type TwitterChannelsResponse {
  monitored_twitter_handles: [Monitored_X_handles]
}

type Monitored_X_handles {
  "If replies are allowed for this handle"
  allow_reply: Boolean
  "The profile image url of the handle"
  avatar_url: String
  "What brand the handle is associated with"
  brand_id: Int
  "If replies are allowed for this handle"
  can_reply: Boolean
  "The time the handle was created"
  created_at: AWSDateTime
  "Automatically assigned upon creation"
  id: Int!
  "The profile name of the handle"
  name: String
  "The X handle"
  screen_name: String!
  "The country's code"
  twitter_user_id: Int!
  "The time of the last update of the handle"
  updated_at: AWSDateTime
}

type TwitterChannelResponse {
  monitored_twitter_handle: Monitored_X_handles
}

type TwitterChannelTwicketStatusResponse {
  statuses: [query_GettingTwicketStatus_statuses_items]
}

type query_GettingTwicketStatus_statuses_items {
  favorited: Boolean
  id: Int
  retweeted: Boolean
  user_followed: Boolean
}

type CustomObjectsResponse {
  custom_objects: [CustomObject]
}

type CustomObject {
  "The time the object type was created"
  created_at: AWSDateTime
  "Id of a user who created the object"
  created_by_user_id: String
  "User-defined description of the object"
  description: String
  "A user-defined unique identifier. Writable on create only"
  key: String!
  "The dynamic content placeholder, if present, or the \"raw_description\" value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_description: String
  "The dynamic content placeholder, if present, or the \"title\" value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_title: String
  "The dynamic content placeholder, if present, or the \"raw_title_pluralized\" value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_title_pluralized: String
  "User-defined display name for the object"
  title: String!
  "User-defined pluralized version of the object's title"
  title_pluralized: String!
  "The time of the last update of the object"
  updated_at: AWSDateTime
  "Id of the last user who updated the object"
  updated_by_user_id: String
  "Direct link to the specific custom object"
  url: String
}

type CustomObjectResponse {
  custom_object: CustomObject
}

type CustomObjectFieldsResponse {
  custom_object_fields: [CustomObjectField]
}

type CustomObjectField {
  "If true, this field is available for use"
  active: Boolean
  "The time of the last update of the ticket field"
  created_at: AWSDateTime
  "Required and presented for a custom field of type \"dropdown\". Each option is represented by an object with a `name` and `value` property"
  custom_field_options: [CustomFieldOptionObject]
  "User-defined description of this field's purpose"
  description: String
  "Automatically assigned upon creation"
  id: Int
  "A unique key that identifies this custom field. This is used for updating the field and referencing in placeholders. The key must consist of only letters, numbers, and underscores. It can't be only numbers"
  key: String!
  "Ordering of the field relative to other fields"
  position: Int
  "The dynamic content placeholder, if present, or the `description` value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_description: String
  "The dynamic content placeholder, if present, or the `title` value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_title: String
  "Regular expression field only. The validation pattern for a field value to be deemed valid"
  regexp_for_validation: String
  relationship_filter: AWSJSON
  "A representation of what type of object the field references. Options are \"zen:user\", \"zen:organization\", \"zen:ticket\", and \"zen:custom_object:{key}\" where key is a custom object key. For example \"zen:custom_object:apartment\"."
  relationship_target_type: String
  "If true, only active and position values of this field can be changed"
  system: Boolean
  "Optional for custom field of type \"checkbox\"; not presented otherwise."
  tag: String
  "The title of the custom field"
  title: String!
  "The custom field type: \"checkbox\", \"date\", \"decimal\", \"dropdown\", \"integer\", [\"lookup\"](/api-reference/ticketing/lookup_relationships/lookup_relationships/), \"regexp\", \"text\", or \"textarea\""
  type: String!
  "The time of the last update of the ticket field"
  updated_at: AWSDateTime
  "The URL for this resource"
  url: String
}

type CustomFieldOptionObject {
  "Automatically assigned upon creation"
  id: Int
  "Name of the dropdown option"
  name: String!
  "Position of the dropdown option"
  position: Int
  "Raw name of the dropdown option"
  raw_name: String
  "URL of the dropdown option"
  url: String
  "Value of the dropdown option"
  value: String!
}

type CustomObjectFieldResponse {
  custom_object_field: CustomObjectField
}

type CustomObjectLimitsResponse {
  "The current numnber of the requested resource"
  count: Int
  "The maximum allowed number for the requested resource"
  limit: Int
}

type CustomObjectRecordsResponse {
  "The number of results returned for the current request"
  count: Int
  custom_object_records: [CustomObjectRecord]
  links: query_ListCustomObjectRecords_links
  meta: query_ListCustomObjectRecords_meta
}

type CustomObjectRecord {
  "The time the object was created"
  created_at: AWSDateTime
  "Id of a user who created the object"
  created_by_user_id: String
  custom_object_fields: AWSJSON
  "A user-defined unique identifier"
  custom_object_key: String
  "An id you can use to link custom object records to external data"
  external_id: String
  "Automatically assigned upon creation"
  id: String
  "User-defined display name for the object"
  name: String!
  "The time of the last update of the object"
  updated_at: AWSDateTime
  "Id of the last user who updated the object"
  updated_by_user_id: String
  "Direct link to the specific custom object"
  url: String
}

type query_ListCustomObjectRecords_links {
  next: String
  prev: String
}

type query_ListCustomObjectRecords_meta {
  after_cursor: String
  before_cursor: String
  has_more: Boolean!
}

type CustomObjectRecordResponse {
  custom_object_record: CustomObjectRecord
}

type CountCustomObjectRecords_200_response {
  count: query_CountCustomObjectRecords_count
}

type query_CountCustomObjectRecords_count {
  additionalProperties: [query_CountCustomObjectRecords_count_additionalProperties_entry]
}

type query_CountCustomObjectRecords_count_additionalProperties_entry {
  key: ID!
  value: query_CountCustomObjectRecords_count_additionalProperties
}

type query_CountCustomObjectRecords_count_additionalProperties {
  "The time the last count was performed"
  refreshed_at: AWSDateTime
  "Number of records at the time of the latest count operation"
  value: Int
}

type CustomRolesResponse {
  custom_roles: [Custom_Agent_Roles]
}

type Custom_Agent_Roles {
  configuration: CustomRoleConfigurationObject
  "The time the record was created"
  created_at: AWSDateTime
  "A description of the role"
  description: String
  "Automatically assigned on creation"
  id: Int
  "Name of the custom role"
  name: String!
  "The user's role. 0 stands for a custom agent, 1 for a light agent, 2 for a chat agent, 3 for a contributor, 4 for an admin and 5 for a billing admin. See [Understanding standard agent roles in Zendesk Support](https://support.zendesk.com/hc/en-us/articles/4409155971354-Understanding-standard-agent-roles-in-Zendesk-Support) in Zendesk help"
  role_type: Int!
  "The number of team members assigned to this role"
  team_member_count: Int
  "The time the record was last updated"
  updated_at: AWSDateTime
}

"Configuration settings for the role. See [Configuration](#configuration)"
type CustomRoleConfigurationObject {
  "Whether or not the agent can assign tickets to any group"
  assign_tickets_to_any_group: Boolean
  "Whether or not the agent has access to Chat"
  chat_access: Boolean
  "Whether or not the agent can view lists of user profiles. Allowed values: \"full\", \"none\""
  end_user_list_access: String
  "What the agent can do with end-user profiles. Allowed values: \"edit\", \"edit-within-org\", \"full\", \"readonly\""
  end_user_profile_access: String
  "Allowed values: \"edit\", \"full\", \"none\", \"readonly\""
  explore_access: String
  "The kind of access the agent has to Guide. Allowed values: \"edit-topics\", \"full\", \"readonly\""
  forum_access: String
  forum_access_restricted_content: Boolean
  "Whether or not the agent can add or modify groups"
  group_access: Boolean
  light_agent: Boolean
  "What the agent can do with macros. Allowed values: \"full\", \"manage-group\", \"manage-personal\", \"readonly\""
  macro_access: String
  "Whether or not the agent can manage business rules"
  manage_business_rules: Boolean
  "Whether or not the agent can view, add, and edit contextual workspaces"
  manage_contextual_workspaces: Boolean
  "Whether or not the agent can access dynamic content"
  manage_dynamic_content: Boolean
  "Whether or not the agent can manage channels and extensions"
  manage_extensions_and_channels: Boolean
  "Whether or not the agent can manage Facebook pages"
  manage_facebook: Boolean
  "Whether or not the agent can create and manage organization fields"
  manage_organization_fields: Boolean
  "Whether or not the agent can create and manage ticket fields"
  manage_ticket_fields: Boolean
  "Whether or not the agent can create and manage ticket forms"
  manage_ticket_forms: Boolean
  "Whether or not the agent can create and manage user fields"
  manage_user_fields: Boolean
  moderate_forums: Boolean
  "Whether or not the agent can add or modify organizations"
  organization_editing: Boolean
  "Whether or not the agent can add or modify organization notes"
  organization_notes_editing: Boolean
  "What the agent can do with reports. Allowed values: \"full\", \"none\", \"readonly\""
  report_access: String
  "Whether or not the agent can contribute to side conversations"
  side_conversation_create: Boolean
  "What kind of tickets the agent can access. Allowed values: \"all\", \"assigned-only\", \"within-groups\", \"within-groups-and-public-groups\", \"within-organization\""
  ticket_access: String
  "What type of comments the agent can make. Allowed values: \"public\", \"none\""
  ticket_comment_access: String
  "Whether or not the agent can delete tickets"
  ticket_deletion: Boolean
  "Whether or not the agent can edit ticket properties"
  ticket_editing: Boolean
  "Whether or not the agent can merge tickets"
  ticket_merge: Boolean
  "Whether or not the agent can edit ticket tags"
  ticket_tag_editing: Boolean
  twitter_search_access: Boolean
  "What the agent can do with customer lists. Allowed values: \"full\", \"manage-group\", \"manage-personal\", \"none\", \"readonly\""
  user_view_access: String
  "What the agent can do with views. Allowed values: \"full\", \"manage-group\", \"manage-personal\", \"playonly\", \"readonly\""
  view_access: String
  "Whether or not the agent can view deleted tickets"
  view_deleted_tickets: Boolean
  "Whether or not the agent can answer and place calls to end users"
  voice_access: Boolean
  "Whether or not the agent can view details about calls on the Talk dashboard"
  voice_dashboard_access: Boolean
}

type CustomRoleResponse {
  custom_role: Custom_Agent_Roles
}

type CustomStatusesResponse {
  custom_statuses: [CustomStatusObject]
}

type CustomStatusObject {
  "If true, the custom status is set to active, If false, the custom status is set to inactive"
  active: Boolean
  "The label displayed to agents. Maximum length is 48 characters"
  agent_label: String!
  "The date and time the custom ticket status was created"
  created_at: AWSDateTime
  "If true, the custom status is set to default. If false, the custom status is set to non-default"
  default: Boolean
  "The description of when the user should select this custom ticket status"
  description: String
  "The description displayed to end users"
  end_user_description: String
  "The label displayed to end users. Maximum length is 48 characters"
  end_user_label: String
  "Automatically assigned when the custom ticket status is created"
  id: Int
  "The dynamic content placeholder. If the dynamic content placeholder is not available, this is the \"agent_label\" value. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_agent_label: String
  "The dynamic content placeholder. If the dynamic content placeholder is not available, this is the \"description\" value. [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_description: String
  "The dynamic content placeholder. If the dynamic content placeholder is not available, this is the \"end_user_description\" value. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_end_user_description: String
  "The dynamic content placeholder. If the dynamic content placeholder is not available, this is the \"end_user_label\" value. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_end_user_label: String
  status_category: query_ListCustomStatuses_custom_statuses_items_status_category!
  "The date and time the custom ticket status was last updated"
  updated_at: AWSDateTime
}

"The status category the custom ticket status belongs to"
enum query_ListCustomStatuses_custom_statuses_items_status_category {
  new
  open
  pending
  hold
  solved
}

type CustomStatusResponse {
  custom_status: CustomStatusObject
}

type ListDeletedTicketsResponse {
  deleted_tickets: [query_ListDeletedTickets_allOf_0_deleted_tickets_items]
  "the total record count"
  count: Int
  "the URL of the next page"
  next_page: String
  "the URL of the previous page"
  previous_page: String
}

type query_ListDeletedTickets_allOf_0_deleted_tickets_items {
  actor: query_ListDeletedTickets_allOf_0_deleted_tickets_items_actor
  deleted_at: String
  id: Int
  previous_state: String
  subject: String
}

type query_ListDeletedTickets_allOf_0_deleted_tickets_items_actor {
  id: Int
  name: String
}

"Sort by"
enum TicketSortBy_parameter {
  id
  subject
  deleted_at
}

"Sort order. Defaults to \"asc\""
enum TicketSortOrder_parameter {
  asc
  desc
}

type DeletedUsersResponse {
  deleted_users: [DeletedUserObject]
}

type DeletedUserObject {
  active: Boolean!
  created_at: String!
  email: String!
  id: Int!
  locale: String!
  locale_id: Int!
  name: String!
  organization_id: Int!
  phone: String
  photo: AWSJSON
  role: String!
  shared_phone_number: String
  time_zone: String!
  updated_at: String!
  url: String!
}

type DeletedUserResponse {
  deleted_user: DeletedUserObject
}

type CountResponse {
  count: query_CountDeletedUsers_count
}

type query_CountDeletedUsers_count {
  refreshed_at: String
  value: Int
}

type DynamicContentsResponse {
  items: [Dynamic_Content_Items]
}

type Dynamic_Content_Items {
  "When this record was created"
  created_at: AWSDateTime
  "The default locale for the item. Must be one of the [locales the account has active](/api-reference/ticketing/account-configuration/locales/#list-locales)."
  default_locale_id: Int!
  "Automatically assigned when creating items"
  id: Int
  "The unique name of the item"
  name: String!
  "Indicates the item has outdated variants within it"
  outdated: Boolean
  "Automatically generated placeholder for the item, derived from name"
  placeholder: String
  "When this record was last updated"
  updated_at: AWSDateTime
  "The API url of this item"
  url: String
  "All variants within this item. See [Dynamic Content Item Variants](/api-reference/ticketing/ticket-management/dynamic_content_item_variants/)"
  variants: [DynamicContentVariantObject]!
}

type DynamicContentVariantObject {
  "If the variant is active and useable"
  active: Boolean
  "The content of the variant"
  content: String!
  "When the variant was created"
  created_at: AWSDateTime
  "If the variant is the default for the item it belongs to"
  default: Boolean
  "Automatically assigned when the variant is created"
  id: Int
  "An active locale"
  locale_id: Int!
  "If the variant is outdated"
  outdated: Boolean
  "When the variant was last updated"
  updated_at: AWSDateTime
  "The API url of the variant"
  url: String
}

type DynamicContentResponse {
  item: Dynamic_Content_Items
}

type DynamicContentVariantsResponse {
  variants: [DynamicContentVariantObject]
}

type DynamicContentVariantResponse {
  variant: DynamicContentVariantObject
}

type GroupMembershipsResponse {
  group_memberships: [GroupMembershipObject]
}

type GroupMembershipObject {
  "The time the group was created"
  created_at: AWSDateTime
  "If true, tickets assigned directly to the agent will assume this membership's group"
  default: Boolean
  "The id of a group"
  group_id: Int!
  "Automatically assigned upon creation"
  id: Int
  "The time of the last update of the group"
  updated_at: AWSDateTime
  "The API url of this record"
  url: String
  "The id of an agent"
  user_id: Int!
}

type GroupMembershipResponse {
  group_membership: GroupMembershipObject
}

type GroupSLAPoliciesResponse {
  count: Int
  group_sla_policies: [GroupSLAPolicyObject]
  next_page: String
  previous_page: String
}

type GroupSLAPolicyObject {
  "The time the Group SLA policy was created"
  created_at: AWSDateTime
  "The description of the Group SLA policy"
  description: String
  filter: GroupSLAPolicyFilterObject!
  "Automatically assigned when created"
  id: String
  "Array of [policy metric](#policy-metric) objects"
  policy_metrics: [GroupSLAPolicyMetricObject]
  "Position of the Group SLA policy. This position determines the order in which policies are matched to tickets. If not specified, the Group SLA policy is added at the last position"
  position: Int
  "The title of the Group SLA policy"
  title: String!
  "The time of the last update of the Group SLA policy"
  updated_at: AWSDateTime
  "URL of the Group SLA policy record"
  url: String
}

"An object that describes the conditions a ticket must match for a Group SLA policy to be applied to the ticket. See [Filter](#filter)."
type GroupSLAPolicyFilterObject {
  all: [GroupSLAPolicyFilterConditionObject]
}

type GroupSLAPolicyFilterConditionObject {
  "The name of a ticket field"
  field: String
  "A comparison operator"
  operator: String
  "The value of a ticket field"
  value: [query_ListGroupSLAPolicies_group_sla_policies_items_filter_all_items_value_items]
}

union query_ListGroupSLAPolicies_group_sla_policies_items_filter_all_items_value_items = String_container | Int_container

type String_container {
  String: String
}

type Int_container {
  Int: Int
}

type GroupSLAPolicyMetricObject {
  "Whether the metric targets are being measured in business hours or calendar hours"
  business_hours: Boolean
  "The definition of the time that is being measured"
  metric: String
  "Priority that a ticket must match"
  priority: String
  "The time within which the end-state for a metric should be met"
  target: Int
}

type GroupSLAPolicyResponse {
  group_sla_policy: GroupSLAPolicyObject
}

type GroupSLAPolicyFilterDefinitionResponse {
  definitions: query_RetrieveGroupSLAPolicyFilterDefinitionItems_definitions
}

type query_RetrieveGroupSLAPolicyFilterDefinitionItems_definitions {
  all: [properties_all_items]
}

type properties_all_items {
  group: String
  operators: [properties_all_items_operators_items]
  title: String
  value: String
  values: properties_all_items_values
}

type properties_all_items_operators_items {
  title: String
  value: String
}

type properties_all_items_values {
  list: [properties_all_items_values_list_items]
  type: String
}

type properties_all_items_values_list_items {
  title: String
  value: Int
}

type GroupsResponse {
  groups: [GroupObject]
}

type GroupObject {
  "The time the group was created"
  created_at: AWSDateTime
  "If the group is the default one for the account"
  default: Boolean
  "Deleted groups get marked as such"
  deleted: Boolean
  "The description of the group"
  description: String
  "Automatically assigned when creating groups"
  id: Int
  "If true, the group is public.\nIf false, the group is private.\nYou can't change a private group to a public group"
  is_public: Boolean
  "The name of the group"
  name: String!
  "The time of the last update of the group"
  updated_at: AWSDateTime
  "The API url of the group"
  url: String
}

type GroupResponse {
  group: GroupObject
}

type GroupsCountObject {
  count: query_CountGroups_count
}

type query_CountGroups_count {
  "Timestamp that indicates when the count was last updated"
  refreshed_at: AWSDateTime
  "Approximate count of groups"
  value: Int
}

"See [Tickets](/api-reference/ticketing/tickets/tickets/) for a detailed example."
type TimeBasedExportIncrementalTicketsResponse {
  count: Int
  end_of_stream: Boolean
  end_time: Int
  next_page: String
  tickets: [TicketObject]
}

type ExportIncrementalOrganizationsResponse {
  count: Int
  end_of_stream: Boolean
  end_time: Int
  next_page: String
  organizations: [OrganizationObject]
}

type OrganizationObject {
  "The time the organization was created"
  created_at: String
  "Any details obout the organization, such as the address"
  details: String
  "An array of domain names associated with this organization"
  domain_names: [String]
  "A unique external id to associate organizations to an external record. The id is case-insensitive. For example, \"company1\" and \"Company1\" are considered the same"
  external_id: String
  "New tickets from users in this organization are automatically put in this group"
  group_id: Int
  "Automatically assigned when the organization is created"
  id: Int
  "A unique name for the organization"
  name: String!
  "Any notes you have about the organization"
  notes: String
  "Custom fields for this organization. See [Custom organization fields](/api-reference/ticketing/organizations/organizations/#custom-organization-fields)"
  organization_fields: AWSJSON
  "End users in this organization are able to comment on each other's tickets"
  shared_comments: Boolean
  "End users in this organization are able to see each other's tickets"
  shared_tickets: Boolean
  "The tags of the organization"
  tags: [String]
  "The time of the last update of the organization"
  updated_at: String
  "The API url of this organization"
  url: String
}

type Incremental_Skill_based_Routing {
  "Routing attribute values"
  attribute_values: [IncrementalSkillBasedRoutingAttributeValue]
  "Routing attributes"
  attributes: [IncrementalSkillBasedRoutingAttribute]
  "The number of results returned for the current request"
  count: Int
  "The most recent resource creation time present in this result set in Unix epoch time"
  end_time: Int
  "Routing instance values"
  instance_values: [IncrementalSkillBasedRoutingInstanceValue]
  "The URL that should be called to get the next set of results"
  next_page: String
}

type IncrementalSkillBasedRoutingAttributeValue {
  "Id of the associated attribute"
  attribute_id: String
  "Automatically assigned when an attribute value is created"
  id: String
  "The name of the attribute value"
  name: String
  "The time the attribute value was created, updated, or deleted"
  time: AWSDateTime
  "One of \"create\", \"update\", or \"delete\""
  type: String
}

type IncrementalSkillBasedRoutingAttribute {
  "Automatically assigned when an attribute is created"
  id: String
  "The name of the attribute"
  name: String
  "The time the attribute was created, updated, or deleted"
  time: AWSDateTime
  "One of \"create\", \"update\", or \"delete\""
  type: String
}

type IncrementalSkillBasedRoutingInstanceValue {
  "Id of the associated attribute value"
  attribute_value_id: String
  "Automatically assigned when an instance value is created"
  id: String
  "Id of the associated agent or ticket"
  instance_id: String
  "The time the instance value was created or deleted"
  time: AWSDateTime
  "One of \"associate_agent\", \"unassociate_agent\", \"associate_ticket\", or \"unassociate_ticket\""
  type: String
}

type ExportIncrementalTicketEventsResponse {
  count: Int
  end_of_stream: Boolean
  end_time: Int
  next_page: String
  ticket_events: [Ticket_Metric_Events]
}

type Ticket_Metric_Events {
  "Automatically assigned when the record is created"
  id: Int
  "The instance of the metric associated with the event. See [instance_id](#instance_id)"
  instance_id: Int
  metric: query_IncrementalTicketEvents_ticket_events_items_metric
  "Id of the associated ticket"
  ticket_id: Int
  "The time the event occurred"
  time: AWSDateTime
  type: query_IncrementalTicketEvents_ticket_events_items_type
}

"The metric being tracked"
enum query_IncrementalTicketEvents_ticket_events_items_metric {
  agent_work_time
  pausable_update_time
  periodic_update_time
  reply_time
  requester_wait_time
  resolution_time
  group_ownership_time
}

"The type of the metric event. See [Ticket metric event types reference](/documentation/ticketing/reference-guides/ticket-metric-event-types-reference)"
enum query_IncrementalTicketEvents_ticket_events_items_type {
  activate
  pause
  fulfill
  apply_sla
  apply_group_sla
  breach
  update_status
  measure
}

type TicketMetricEventsResponse {
  ticket_metric_events: [Ticket_Metric_Events]
  count: Int
  end_time: Int
  next_page: String
}

"See [Tickets](/api-reference/ticketing/tickets/tickets/) for a detailed example."
type CursorBasedExportIncrementalTicketsResponse {
  after_cursor: String
  after_url: String
  before_cursor: String
  before_url: String
  end_of_stream: Boolean
  tickets: [TicketObject]
}

type TimeBasedExportIncrementalUsersResponse {
  count: Int
  end_of_stream: Boolean
  end_time: Int
  next_page: String
  users: [UserObject]
}

type CursorBasedExportIncrementalUsersResponse {
  after_cursor: String
  after_url: String
  before_cursor: String
  before_url: String
  end_of_stream: Boolean
  users: [UserObject]
}

type JobStatusesResponse {
  job_statuses: [JobStatusObject]!
}

type JobStatusObject {
  "Automatically assigned when the job is queued"
  id: String
  "The type of the job"
  job_type: String
  "Message from the job worker, if any"
  message: String
  "Number of tasks that have already been completed"
  progress: Int
  results: [query_ListJobStatuses_job_statuses_items_results]
  "The current status. One of the following: \"queued\", \"working\", \"failed\", \"completed\""
  status: String
  "The total number of tasks this job is batching through"
  total: Int
  "The URL to poll for status updates"
  url: String
}

"Result data from processed tasks. See [Results](#results) below"
union query_ListJobStatuses_job_statuses_items_results = CreateResourceResult | UpdateResourceResult | query_ListJobStatuses_job_statuses_items_results_oneOf_1

type CreateResourceResult {
  "the id of the new resource"
  id: Int!
  "the index number of the resul"
  index: Int!
}

type UpdateResourceResult {
  "the action the job attempted (`\"action\": \"update\"`)"
  action: String!
  "the id of the resource the job attempted to update"
  id: Int!
  "the status (`\"status\": \"Updated\"`)"
  status: String!
  "whether the action was successful or not (`\"success\": true`)"
  success: Boolean!
}

type query_ListJobStatuses_job_statuses_items_results_oneOf_1 {
  "Whether the action was successful or not"
  success: Boolean!
}

type JobStatusResponse {
  job_status: JobStatusObject
}

type LocalesResponse {
  locales: [LocaleObject]
}

type LocaleObject {
  "The ISO 8601 formatted date-time the locale was created"
  created_at: AWSDateTime
  "The unique ID of the locale"
  id: Int
  "The name of the locale"
  locale: String
  "The name of the language"
  name: String
  "The ISO 8601 formatted date-time when the locale was last updated"
  updated_at: AWSDateTime
  "The URL of the locale record"
  url: String
}

type LocaleResponse {
  locale: LocaleObject
}

type MacrosResponse {
  macros: [MacroObject]
  "the total record count"
  count: Int
  "the URL of the next page"
  next_page: String
  "the URL of the previous page"
  previous_page: String
}

type MacroObject {
  "Each action describes what the macro will do. See [Actions reference](/documentation/ticketing/reference-guides/actions-reference)"
  actions: [ActionObject]!
  "Useful for determining if the macro should be displayed"
  active: Boolean
  "The time the macro was created"
  created_at: AWSDateTime
  "If true, the macro is a default macro"
  default: Boolean
  "The description of the macro"
  description: String
  "The ID automatically assigned when a macro is created"
  id: Int
  "The position of the macro"
  position: Int
  "Access to this macro. A null value allows unrestricted access for all users in the account"
  restriction: AWSJSON
  "The title of the macro"
  title: String!
  "The time of the last update of the macro"
  updated_at: AWSDateTime
  "A URL to access the macro's details"
  url: String
  "The app installation that requires each macro, if present"
  app_installation: String
  "The macro categories"
  categories: String
  "Permissions for each macro"
  permissions: String
  "The number of times each macro has been used in the past hour"
  usage_1h: Int
  "The number of times each macro has been used in the past week"
  usage_7d: Int
  "The number of times each macro has been used in the past day"
  usage_24h: Int
  "The number of times each macro has been used in the past thirty days"
  usage_30d: Int
}

type MacroResponse {
  macro: MacroObject
}

type MacroApplyTicketResponse {
  result: query_ShowChangesToTicket_result
}

type query_ShowChangesToTicket_result {
  ticket: query_ShowChangesToTicket_result_ticket
}

type query_ShowChangesToTicket_result_ticket {
  assignee_id: Int
  comment: query_ShowChangesToTicket_result_ticket_comment
  fields: query_ShowChangesToTicket_result_ticket_fields
  group_id: Int
  id: Int
  url: String
}

type query_ShowChangesToTicket_result_ticket_comment {
  body: String
  public: Boolean
  scoped_body: [[String]]
}

type query_ShowChangesToTicket_result_ticket_fields {
  id: Int
  value: String
}

type MacroAttachmentsResponse {
  macro_attachments: [MacroAttachmentObject]
}

type MacroAttachmentObject {
  "The content type of the image. Example value: \"image/png\""
  content_type: String
  "A full URL where the attachment image file can be downloaded"
  content_url: String
  "The time when this attachment was created"
  created_at: AWSDateTime
  "The name of the image file"
  filename: String
  "Automatically assigned when created"
  id: Int
  "The size of the image file in bytes"
  size: Int
}

type ListMacrosActions_200_response {
  actions: [AWSJSON]
}

type MacroAttachmentResponse {
  macro_attachment: MacroAttachmentObject
}

type MacroCategoriesResponse {
  categories: [String]
}

type ListMacroActionDefinitions_200_response {
  definitions: query_ListMacroActionDefinitions_definitions
}

type query_ListMacroActionDefinitions_definitions {
  actions: [AWSJSON]
}

type EssentialsCardResponse {
  object_layout: EssentialsCardObject
}

type EssentialsCardObject {
  "Date and time the essentials card were created"
  created_at: AWSDateTime
  "If true, the system has used the first twenty fields for the custom object type as the essentials card."
  default: Boolean
  "Fields that are displayed in the essentials card details. The order is defined by the order of the fields in the array"
  fields: [AWSJSON]!
  "id of the essentials card"
  id: String
  "Object type. Example: `zen:user` refers to `User` type"
  key: String
  "layout type"
  layout: String
  "Maximum number of fields allowed in the essentials card"
  max_count: Int
  "Date and time the essentials card were last updated"
  updated_at: AWSDateTime
}

type EssentialsCardsResponse {
  object_layouts: [EssentialsCardObject]
}

type OrganizationFieldsResponse {
  "Total count of records retrieved"
  count: Int
  "URL of the next page"
  next_page: String
  organization_fields: [OrganizationFieldObject]
  "URL of the previous page"
  previous_page: String
}

type OrganizationFieldObject {
  "If true, this field is available for use"
  active: Boolean
  "The time of the last update of the ticket field"
  created_at: AWSDateTime
  "Required and presented for a custom field of type \"dropdown\". Each option is represented by an object with a `name` and `value` property"
  custom_field_options: [CustomFieldOptionObject]
  "User-defined description of this field's purpose"
  description: String
  "Automatically assigned upon creation"
  id: Int
  "A unique key that identifies this custom field. This is used for updating the field and referencing in placeholders. The key must consist of only letters, numbers, and underscores. It can't be only numbers"
  key: String!
  "Ordering of the field relative to other fields"
  position: Int
  "The dynamic content placeholder, if present, or the `description` value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_description: String
  "The dynamic content placeholder, if present, or the `title` value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_title: String
  "Regular expression field only. The validation pattern for a field value to be deemed valid"
  regexp_for_validation: String
  relationship_filter: AWSJSON
  "A representation of what type of object the field references. Options are \"zen:user\", \"zen:organization\", \"zen:ticket\", and \"zen:custom_object:{key}\" where key is a custom object key. For example \"zen:custom_object:apartment\"."
  relationship_target_type: String
  "If true, only active and position values of this field can be changed"
  system: Boolean
  "Optional for custom field of type \"checkbox\"; not presented otherwise."
  tag: String
  "The title of the custom field"
  title: String!
  "The custom field type: \"checkbox\", \"date\", \"decimal\", \"dropdown\", \"integer\", [\"lookup\"](/api-reference/ticketing/lookup_relationships/lookup_relationships/), \"regexp\", \"text\", or \"textarea\""
  type: String!
  "The time of the last update of the ticket field"
  updated_at: AWSDateTime
  "The URL for this resource"
  url: String
}

type OrganizationFieldResponse {
  organization_field: OrganizationFieldObject
}

input OrganizationFieldId_parameter_Input {
  Int: Int
  String: String
}

type OrganizationMembershipsResponse {
  organization_memberships: [OrganizationMembershipObject]
}

type OrganizationMembershipObject {
  "When this record was created"
  created_at: AWSDateTime
  "Denotes whether this is the default organization membership for the user. If false, returns `null`"
  default: Boolean
  "Automatically assigned when the membership is created"
  id: Int
  "The ID of the organization associated with this user, in this membership"
  organization_id: Int!
  "The name of the organization associated with this user, in this membership"
  organization_name: String
  "When this record last got updated"
  updated_at: AWSDateTime
  "The API url of this membership"
  url: String
  "The ID of the user for whom this memberships belongs"
  user_id: Int!
  "Denotes whether the user can or cannot have access to all organization's tickets."
  view_tickets: Boolean
}

type OrganizationMembershipResponse {
  organization_membership: OrganizationMembershipObject
}

type OrganizationMergeResponse {
  organization_merge: query_ShowOrganizationMerge_organization_merge
}

type query_ShowOrganizationMerge_organization_merge {
  id: String!
  loser_id: Int!
  status: query_ShowOrganizationMerge_organization_merge_status!
  url: String!
  winner_id: Int!
}

enum query_ShowOrganizationMerge_organization_merge_status {
  new
  in_progress
  error
  complete
}

type OrganizationSubscriptionsResponse {
  "the total record count"
  count: Int
  "the URL of the next page"
  next_page: String
  "the URL of the previous page"
  previous_page: String
  "An array of organization subscriptions"
  organization_subscriptions: [Organization_Subscriptions]
}

type Organization_Subscriptions {
  "The date the organization subscription was created"
  created_at: AWSDateTime
  "The ID of the organization subscription"
  id: Int
  "The ID of the organization"
  organization_id: Int
  "The ID of the user"
  user_id: Int
}

type OrganizationSubscriptionResponse {
  organization_subscription: Organization_Subscriptions
}

type OrganizationsResponse {
  count: Int
  next_page: String
  organizations: [OrganizationObject]
  previous_page: String
}

type OrganizationResponse {
  organization: OrganizationObject
}

type OrganizationMergeListResponse {
  organization_merges: [query_ListOrganizationMerges_organization_merges_items]
}

type query_ListOrganizationMerges_organization_merges_items {
  id: String
  loser_id: Int
  status: query_ListOrganizationMerges_organization_merges_items_status
  url: String
  winner_id: Int
}

enum query_ListOrganizationMerges_organization_merges_items_status {
  new
  in_progress
  error
  complete
}

type OrganizationsRelatedResponse {
  organization_related: OrganizationMetadataObject
}

type OrganizationMetadataObject {
  "The number of tickets for the organization"
  tickets_count: Int
  "The number of users for the organization"
  users_count: Int
}

union AutocompleteOrganizations_response = OrganizationsResponse | Errors

type Errors {
  errors: [Error]
}

type Error {
  code: String!
  detail: String
  id: String
  links: AWSJSON
  source: AWSJSON
  status: String
  title: String!
}

type CountOrganizationResponse {
  count: CountOrganizationObject
}

type CountOrganizationObject {
  refreshed_at: String
  value: Int
}

type QueuesResponse {
  queues: [QueueObject]
}

type QueueObject {
  "The time the queue was created"
  created_at: AWSDateTime
  definition: query_ListQueues_queues_items_definition
  "The description of the queue"
  description: String
  "Automatically assigned when creating queue"
  id: String
  "The name of the queue"
  name: String
  "The queue-applied order"
  order: Int
  primary_groups: query_ListQueues_queues_items_primary_groups
  "The queue-applied priority"
  priority: Int
  secondary_groups: query_ListQueues_queues_items_secondary_groups
  "The time of the queue's last update"
  updated_at: AWSDateTime
  "The API URL of the queue"
  url: String
}

"Conditions when queue could be applied"
type query_ListQueues_queues_items_definition {
  all: [query_ListQueues_queues_items_definition_all_items]
  any: [query_ListQueues_queues_items_definition_any_items]
}

type query_ListQueues_queues_items_definition_all_items {
  field: String
  operator: String
  value: String
}

type query_ListQueues_queues_items_definition_any_items {
  field: String
  operator: String
  value: String
}

"Primary group ids linked to the queue"
type query_ListQueues_queues_items_primary_groups {
  count: Int
  groups: [query_ListQueues_queues_items_primary_groups_groups_items]
}

type query_ListQueues_queues_items_primary_groups_groups_items {
  id: Int
  name: String
}

"Secondary group ids linked to the queue"
type query_ListQueues_queues_items_secondary_groups {
  count: Int
  groups: [query_ListQueues_queues_items_secondary_groups_groups_items]
}

type query_ListQueues_queues_items_secondary_groups_groups_items {
  id: Int
  name: String
}

type QueueResponse {
  queue: QueueObject
}

type DefinitionsResponse {
  definitions: query_ListQueueDefinitions_definitions
}

type query_ListQueueDefinitions_definitions {
  conditions_all: [properties_conditions_all_items]
  conditions_any: [properties_conditions_any_items]
}

type properties_conditions_all_items {
  group: String
  nullable: Boolean
  operators: [properties_conditions_all_items_operators_items]
  repeatable: Boolean
  subject: String
  title: String
  type: String
  values: [properties_conditions_all_items_values_items]
}

type properties_conditions_all_items_operators_items {
  terminal: Boolean
  title: String
  value: String
}

type properties_conditions_all_items_values_items {
  enabled: Boolean
  title: String
  value: String
}

type properties_conditions_any_items {
  group: String
  nullable: Boolean
  operators: [properties_conditions_any_items_operators_items]
  repeatable: Boolean
  subject: String
  title: String
  type: String
  values: [properties_conditions_any_items_values_items]
}

type properties_conditions_any_items_operators_items {
  terminal: Boolean
  title: String
  value: String
}

type properties_conditions_any_items_values_items {
  enabled: Boolean
  title: String
  value: String
}

type SupportAddressesResponse {
  recipient_addresses: [SupportAddressObject]
}

type SupportAddressObject {
  "The ID of the [brand](/api-reference/ticketing/account-configuration/brands/)"
  brand_id: Int
  cname_status: query_ListSupportAddresses_recipient_addresses_items_cname_status
  "When the address was created"
  created_at: AWSDateTime
  "Whether the address is the account's default support address"
  default: Boolean
  dns_results: query_ListSupportAddresses_recipient_addresses_items_dns_results
  "Verification string to be added as a TXT record to the domain. Possible types: string or null."
  domain_verification_code: String
  domain_verification_status: query_ListSupportAddresses_recipient_addresses_items_domain_verification_status
  "The email address. You can't change the email address of an existing support address."
  email: String!
  forwarding_status: query_ListSupportAddresses_recipient_addresses_items_forwarding_status
  "Automatically assigned when created"
  id: Int
  "The name for the address"
  name: String
  spf_status: query_ListSupportAddresses_recipient_addresses_items_spf_status
  "When the address was updated"
  updated_at: AWSDateTime
}

"Whether all of the required CNAME records are set. Possible values: \"unknown\", \"verified\", \"failed\""
enum query_ListSupportAddresses_recipient_addresses_items_cname_status {
  unknown
  verified
  failed
}

"Verification statuses for the domain and CNAME records. Possible types: \"verified\", \"failed\""
enum query_ListSupportAddresses_recipient_addresses_items_dns_results {
  verified
  failed
}

"Whether the domain verification record is valid. Possible values: \"unknown\", \"verified\", \"failed\""
enum query_ListSupportAddresses_recipient_addresses_items_domain_verification_status {
  unknown
  verified
  failed
}

"Status of email forwarding. Possible values: \"unknown\", \"waiting\", \"verified\", or \"failed\""
enum query_ListSupportAddresses_recipient_addresses_items_forwarding_status {
  unknown
  waiting
  verified
  failed
}

"Whether the SPF record is set up correctly. Possible values: \"unknown\", \"verified\", \"failed\""
enum query_ListSupportAddresses_recipient_addresses_items_spf_status {
  unknown
  verified
  failed
}

type SupportAddressResponse {
  recipient_address: SupportAddressObject
}

type RelationshipFilterDefinitionResponse {
  definitions: RelationshipFilterDefinition
}

type RelationshipFilterDefinition {
  conditions_all: [TriggerConditionDefinitionObjectAll]
  conditions_any: [TriggerConditionDefinitionObjectAny]
}

type TriggerConditionDefinitionObjectAll {
  group: String
  nullable: Boolean
  operators: [properties_conditions_all_items_operators_items2]
  repeatable: Boolean
  subject: String
  title: String
  type: String
  values: [properties_conditions_all_items_values_items2]
}

type properties_conditions_all_items_operators_items2 {
  terminal: Boolean
  title: String
  value: String
}

type properties_conditions_all_items_values_items2 {
  enabled: Boolean
  title: String
  value: String
}

type TriggerConditionDefinitionObjectAny {
  group: String
  nullable: Boolean
  operators: [properties_conditions_any_items_operators_items2]
  repeatable: Boolean
  subject: String
  title: String
  type: String
}

type properties_conditions_any_items_operators_items2 {
  terminal: Boolean
  title: String
  value: String
}

type RequestsResponse {
  requests: [RequestObject]
}

type RequestObject {
  "The id of the assignee if the field is visible to end users"
  assignee_id: Int
  "If true, an end user can mark the request as solved. See [Update Request](/api-reference/ticketing/tickets/ticket-requests/#update-request)"
  can_be_solved_by_me: Boolean
  "The ids of users currently CC'ed on the ticket"
  collaborator_ids: [Int]
  "When this record was created"
  created_at: AWSDateTime
  "Custom fields for the request. See [Setting custom field values](/api-reference/ticketing/tickets/tickets/#setting-custom-field-values) in the Tickets doc"
  custom_fields: [query_ListRequests_requests_items_custom_fields_items]
  "The custom ticket status id of the ticket"
  custom_status_id: Int
  "Read-only first comment on the request. When [creating a request](#create-request), use `comment` to set the description"
  description: String
  "When the task is due (only applies if the request is of type \"task\")"
  due_at: AWSDateTime
  "The ids of users who are currently email CCs on the ticket. See [CCs and followers resources](https://support.zendesk.com/hc/en-us/articles/360020585233) in the Support Help Center"
  email_cc_ids: [Int]
  "The id of the original ticket if this request is a follow-up ticket. See [Create Request](#create-request)"
  followup_source_id: Int
  "The id of the assigned group if the field is visible to end users"
  group_id: Int
  "Automatically assigned when creating requests"
  id: Int
  "Is true if any comments are public, false otherwise"
  is_public: Boolean
  "The organization of the requester"
  organization_id: Int
  "The priority of the request, \"low\", \"normal\", \"high\", \"urgent\""
  priority: String
  "The original recipient e-mail address of the request"
  recipient: String
  "The id of the requester"
  requester_id: Int
  "Whether or not request is solved (an end user can set this if \"can_be_solved_by_me\", above, is true for that user)"
  solved: Boolean
  "The state of the request, \"new\", \"open\", \"pending\", \"hold\", \"solved\", \"closed\""
  status: String
  "The value of the subject field for this request if the subject field is visible to end users; a truncated version of the description otherwise"
  subject: String!
  "The numeric id of the ticket form associated with this request if the form is visible to end users - only applicable for enterprise accounts"
  ticket_form_id: Int
  "The type of the request, \"question\", \"incident\", \"problem\", \"task\""
  type: String
  "When this record last got updated"
  updated_at: AWSDateTime
  "The API url of this request"
  url: String
  via: TicketAuditViaObject
}

type query_ListRequests_requests_items_custom_fields_items {
  id: Int
  value: String
}

"Describes how the object was created. See the [Via object reference](/documentation/ticketing/reference-guides/via-object-reference)"
type TicketAuditViaObject {
  "This tells you how the ticket or event was created. Examples: \"web\", \"mobile\", \"rule\", \"system\""
  channel: String
  "For some channels a source object gives more information about how or why the ticket or event was created"
  source: AWSJSON
}

type RequestResponse {
  request: RequestObject
}

type TicketCommentsResponse {
  comments: [TicketCommentObject]
}

type TicketCommentObject {
  "Attachments, if any. See [Attachment](/api-reference/ticketing/tickets/ticket-attachments/)"
  attachments: [AttachmentObject]
  "The id of the ticket audit record. See [Show Audit](/api-reference/ticketing/tickets/ticket_audits/#show-audit)"
  audit_id: Int
  "The id of the comment author. See [Author id](#author-id)"
  author_id: Int
  "The comment string. See [Bodies](#bodies)"
  body: String
  "The time the comment was created"
  created_at: AWSDateTime
  "The comment formatted as HTML. See [Bodies](#bodies)"
  html_body: String
  "Automatically assigned when the comment is created"
  id: Int
  "System information (web client, IP address, etc.) and comment flags, if any. See [Comment flags](#comment-flags)"
  metadata: AWSJSON
  "The comment presented as plain text. See [Bodies](#bodies)"
  plain_body: String
  "true if a public comment; false if an internal note. The initial value set on ticket creation persists for any additional comment unless you change it"
  public: Boolean
  "`Comment` or `VoiceComment`. The JSON object for adding voice comments to tickets is different. See [Adding voice comments to tickets](/documentation/ticketing/managing-tickets/adding-voice-comments-to-tickets)"
  type: String
  "List of tokens received from [uploading files](/api-reference/ticketing/tickets/ticket-attachments/#upload-files) for comment attachments. The files are attached by creating or updating tickets with the tokens. See [Attaching files](/api-reference/ticketing/tickets/tickets/#attaching-files) in Tickets"
  uploads: [String]
  via: TicketAuditViaObject
}

type TicketCommentResponse {
  comment: TicketCommentObject
}

type ResourceCollectionsResponse {
  count: Int
  next_page: String
  previous_page: String
  resource_collections: [ResourceCollectionObject]
}

type ResourceCollectionObject {
  "When the resource collection was created"
  created_at: AWSDateTime
  "id for the resource collection. Automatically assigned upon creation"
  id: Int
  "Array of resource metadata objects. See [Resource objects](#resource-objects)"
  resources: [query_ListResourceCollections_resource_collections_items_resources_items]
  "Last time the resource collection was updated"
  updated_at: AWSDateTime
}

type query_ListResourceCollections_resource_collections_items_resources_items {
  deleted: Boolean
  identifier: String
  resource_id: Int
  type: String
}

type ResourceCollectionResponse {
  resource_collection: ResourceCollectionObject
}

type SkillBasedRoutingAttributeValuesResponse {
  attribute_values: [SkillBasedRoutingAttributeValueObject]
}

type SkillBasedRoutingAttributeValueObject {
  "Id of the associated attribute"
  attribute_id: String
  "When this record was created"
  created_at: AWSDateTime
  "Automatically assigned when an attribute value is created"
  id: String
  "The name of the attribute value"
  name: String
  "When this record was last updated"
  updated_at: AWSDateTime
  "URL of the attribute value"
  url: String
}

type SkillBasedRoutingAttributesResponse {
  attributes: [SkillBasedRoutingAttributeObject]
  count: Int
  next_page: String
  previous_page: String
}

type SkillBasedRoutingAttributeObject {
  "When this record was created"
  created_at: AWSDateTime
  "Automatically assigned when an attribute is created"
  id: String
  "The name of the attribute"
  name: String!
  "When this record was last updated"
  updated_at: AWSDateTime
  "URL of the attribute"
  url: String
}

type SkillBasedRoutingAttributeResponse {
  attribute: SkillBasedRoutingAttributeObject
}

type SkillBasedRoutingAttributeValueResponse {
  attribute_value: SkillBasedRoutingAttributeValueObject
}

type SkillBasedRoutingAttributeDefinitions {
  definitions: query_ListRoutingAttributeDefinitions_definitions
}

type query_ListRoutingAttributeDefinitions_definitions {
  conditions_all: [properties_conditions_all_items2]
  conditions_any: [properties_conditions_any_items2]
}

type properties_conditions_all_items2 {
  subject: String
  title: String
}

type properties_conditions_any_items2 {
  subject: String
  title: String
}

type SkillBasedRoutingTicketFulfilledResponse {
  fulfilled_ticket_ids: [Int]
}

type SatisfactionRatingsResponse {
  satisfaction_ratings: [SatisfactionRatingObject]
}

type SatisfactionRatingObject {
  "The id of agent assigned to at the time of rating"
  assignee_id: Int!
  "The comment received with this rating, if available"
  comment: String
  "The time the satisfaction rating got created"
  created_at: AWSDateTime
  "The id of group assigned to at the time of rating"
  group_id: Int!
  "Automatically assigned upon creation"
  id: Int
  "The reason for a bad rating given by the requester in a follow-up question. Satisfaction reasons must be [enabled](https://support.zendesk.com/hc/en-us/articles/223152967)"
  reason: String
  "The default reasons the user can select from a list menu for giving a negative rating. See [Reason codes](/api-reference/ticketing/ticket-management/satisfaction_reasons/#reason-codes) in the Satisfaction Reasons API. Can only be set on ratings with a `score` of \"bad\". Responses don't include this property"
  reason_code: Int
  "id for the reason the user gave a negative rating. Can only be set on ratings with a `score` of \"bad\". To get a descriptive value for the id, use the [Show Reason for Satisfaction Rating](/api-reference/ticketing/ticket-management/satisfaction_reasons/#show-reason-for-satisfaction-rating) endpoint"
  reason_id: Int
  "The id of ticket requester submitting the rating"
  requester_id: Int!
  "The rating \"offered\", \"unoffered\", \"good\" or \"bad\""
  score: String!
  "The id of ticket being rated"
  ticket_id: Int!
  "The time the satisfaction rating got updated"
  updated_at: AWSDateTime
  "The API url of this rating"
  url: String
}

type SatisfactionRatingResponse {
  satisfaction_rating: [SatisfactionRatingObject]
}

type SatisfactionRatingsCountResponse {
  count: query_CountSatisfactionRatings_count
}

type query_CountSatisfactionRatings_count {
  refreshed_at: AWSDateTime
  value: Int
}

type SatisfactionReasonsResponse {
  reasons: [SatisfactionReasonObject]
}

type SatisfactionReasonObject {
  "The time the reason was created"
  created_at: AWSDateTime
  "The time the reason was deleted"
  deleted_at: AWSDateTime
  "Automatically assigned upon creation"
  id: Int
  "The dynamic content placeholder, if present, or the current \"value\", if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_value: String
  "An account-level code for referencing the reason. Custom reasons are assigned an auto-incrementing integer (non-system reason codes begin at 1000). See [Reason codes](#reason-codes)"
  reason_code: Int
  "The time the reason was updated"
  updated_at: AWSDateTime
  "API URL for the resource"
  url: String
  "Translated value of the reason in the account locale"
  value: String!
}

type SatisfactionReasonResponse {
  reason: [SatisfactionReasonObject]
}

type SearchResponse {
  "The number of resources returned by the query corresponding to this page of results in the paginated response"
  count: Int
  "The facets corresponding to the search query"
  facets: String
  "URL to the next page of results"
  next_page: String
  "URL to the previous page of results"
  previous_page: String
  "May consist of tickets, users, groups, or organizations, as specified by the `result_type` property in each result object"
  results: [SearchResultObject]
}

type SearchResultObject {
  "When the resource was created"
  created_at: String
  "Flag to indicate whether this is the default resource"
  default: Boolean
  "Flag to indicate whether or not resource has been deleted"
  deleted: Boolean
  "The description of the resource"
  description: String
  "The ID of the resource"
  id: Int
  "The name of the resource"
  name: String
  "The type of the resource"
  result_type: String
  "When the resource was last updated"
  updated_at: String
  "The url of the resource"
  url: String
}

type SearchCountResponse {
  count: Int
}

type SearchExportResponse {
  "The facets corresponding to the search query"
  facets: String
  links: query_ExportSearchResults_links
  meta: query_ExportSearchResults_meta
  "May consist of tickets, users, groups, or organizations, as specified by the `result_type` property in each result object"
  results: [SearchResultObject]
}

"The links to the previous and next entries via the cursor ids in the metadata."
type query_ExportSearchResults_links {
  "The url to the next entry via the cursor."
  next: String
  "The url to the previous entry via the cursor."
  prev: String
}

"Metadata for the export query response."
type query_ExportSearchResults_meta {
  "The cursor id for the next object."
  after_cursor: String
  "The cursor id for the previous object."
  before_cursor: String
  "Whether there are more items yet to be returned by the cursor."
  has_more: Boolean
}

type SessionsResponse {
  sessions: [SessionObject]
}

type SessionObject {
  "When the session was created"
  authenticated_at: String
  "Automatically assigned when the session is created"
  id: Int!
  "The last approximate time this session was seen. This does not update on every request."
  last_seen_at: String
  "The API URL of this session"
  url: String
  "The id of the user"
  user_id: Int
}

type SharingAgreementsResponse {
  sharing_agreements: [SharingAgreementObject]
}

type SharingAgreementObject {
  "The time the record was created"
  created_at: AWSDateTime
  "Automatically assigned upon creation"
  id: Int
  "Name of this sharing agreement"
  name: String
  "Can be one of the following: \"jira\", null"
  partner_name: String
  "Subdomain of the remote account or null if not associated with an account"
  remote_subdomain: String
  "Can be one of the following: \"accepted\", \"declined\", \"pending\", \"inactive\", \"failed\", \"ssl_error\", \"configuration_error\""
  status: String
  "Can be one of the following: \"inbound\", \"outbound\""
  type: String
  "The time the record was updated"
  updated_at: AWSDateTime
  "URL of the sharing agreement record"
  url: String
}

type SharingAgreementResponse {
  sharing_agreement: SharingAgreementObject
}

type SLAPoliciesResponse {
  count: Int
  next_page: String
  previous_page: String
  sla_policies: [SLAPolicyObject]
}

type SLAPolicyObject {
  "The time the SLA policy was created"
  created_at: AWSDateTime
  "The description of the SLA policy"
  description: String
  filter: SLAPolicyFilterObject!
  "Automatically assigned when created"
  id: Int
  "Array of [Policy Metric](#policy-metric) objects"
  policy_metrics: [SLAPolicyMetricObject]
  "Position of the SLA policy that determines the order they will be matched. If not specified, the SLA policy is added as the last position"
  position: Int
  "The title of the SLA policy"
  title: String!
  "The time of the last update of the SLA policy"
  updated_at: AWSDateTime
  "URL of the SLA Policy reacord"
  url: String
}

"An object that describes the conditions that a ticket must match in order for an SLA policy to be applied to that ticket. See [Filter](#filter)."
type SLAPolicyFilterObject {
  all: [SLAPolicyFilterConditionObject]
  any: [SLAPolicyFilterConditionObject]
}

type SLAPolicyFilterConditionObject {
  "The name of a ticket field"
  field: String
  "A comparison operator"
  operator: String
  value: [query_ListSLAPolicies_sla_policies_items_filter_all_items_value]
}

"The value of a ticket field"
union query_ListSLAPolicies_sla_policies_items_filter_all_items_value = String_container | Int_container

type SLAPolicyMetricObject {
  "Whether the metric targets are being measured in business hours or calendar hours"
  business_hours: Boolean
  "The definition of the time that is being measured"
  metric: String
  "Priority that a ticket must match"
  priority: String
  "The time within which the end-state for a metric should be met"
  target: Int
}

type SLAPolicyResponse {
  sla_policy: SLAPolicyObject
}

type SLAPolicyFilterDefinitionResponse {
  definitions: query_RetrieveSLAPolicyFilterDefinitionItems_definitions
}

type query_RetrieveSLAPolicyFilterDefinitionItems_definitions {
  all: [properties_all_items2]
  any: [properties_any_items]
}

type properties_all_items2 {
  group: String
  operators: [properties_all_items_operators_items2]
  target: String
  title: String
  value: String
  values: properties_all_items_values2
}

type properties_all_items_operators_items2 {
  title: String
  value: String
}

type properties_all_items_values2 {
  list: [properties_all_items_values_list_items2]
  type: String
}

type properties_all_items_values_list_items2 {
  title: String
  value: String
}

type properties_any_items {
  group: String
  operators: [properties_any_items_operators_items]
  target: String
  title: String
  value: String
  values: properties_any_items_values
}

type properties_any_items_operators_items {
  title: String
  value: String
}

type properties_any_items_values {
  list: [properties_any_items_values_list_items]
  type: String
}

type properties_any_items_values_list_items {
  title: String
  value: String
}

type SuspendedTicketsResponse {
  suspended_tickets: [SuspendedTicketObject]
}

type SuspendedTicketObject {
  "The attachments, if any associated to this suspended ticket. See [Attachments](/api-reference/ticketing/tickets/ticket-attachments/)"
  attachments: [AttachmentObject]
  author: AuthorObject
  "The id of the brand this ticket is associated with. Only applicable for Enterprise accounts"
  brand_id: Int
  "Why the ticket was suspended"
  cause: String
  "The ID of the cause"
  cause_id: Int
  "The content that was flagged"
  content: String
  "The ticket ID this suspended email is associated with, if available"
  created_at: AWSDateTime
  "The error messages if any associated to this suspended ticket"
  error_messages: [AWSJSON]
  "Automatically assigned"
  id: Int
  "The ID of the email, if available"
  message_id: String
  "The original recipient e-mail address of the ticket"
  recipient: String
  "The value of the subject field for this ticket"
  subject: String
  "The ticket ID this suspended email is associated with, if available"
  ticket_id: Int
  "When the ticket was assigned"
  updated_at: AWSDateTime
  "The API url of this ticket"
  url: String
  via: ViaObject
}

type AuthorObject {
  "The author email"
  email: String
  "The author id"
  id: Int
  "The author name"
  name: String
}

"An object explaining how the ticket was created. See the [Via object reference](/documentation/ticketing/reference-guides/via-object-reference)"
type ViaObject {
  "This tells you how the ticket or event was created. Examples: \"web\", \"mobile\", \"rule\", \"system\""
  channel: String
  source: query_ListSuspendedTickets_suspended_tickets_items_via_source
}

"For some channels a source object gives more information about how or why the ticket or event was created"
type query_ListSuspendedTickets_suspended_tickets_items_via_source {
  from: query_ListSuspendedTickets_suspended_tickets_items_via_source_from
  rel: String
  to: query_ListSuspendedTickets_suspended_tickets_items_via_source_to
  additionalProperties: AWSJSON
}

type query_ListSuspendedTickets_suspended_tickets_items_via_source_from {
  address: String
  id: Int
  name: String
  title: String
}

type query_ListSuspendedTickets_suspended_tickets_items_via_source_to {
  address: String
  name: String
}

type TagsResponse {
  "The number of pages"
  count: Int
  "The url of the previous page"
  next_page: String
  "The url of the next page"
  previous_page: String
  tags: [TagListTagObject]
}

type TagListTagObject {
  "The number of tags"
  count: Int
  "A name for the tag"
  name: String
}

type TagCountResponse {
  count: TagCountObject
}

type TagCountObject {
  "The time that the count value was last refreshed"
  refreshed_at: String
  "The count of tags created in the last 24 hours"
  value: Int
}

type TargetFailuresResponse {
  target_failures: [TargetFailureObject]
}

type TargetFailureObject {
  "Number of times the target failed consecutively"
  consecutive_failure_count: Int
  "Time of the failure"
  created_at: AWSDateTime
  "The ID of the target failure"
  id: Int
  "The raw message of the target request"
  raw_request: String
  "The raw response of the failure"
  raw_response: String
  "HTTP status code of the target failure"
  status_code: Int
  "Name of the target failure"
  target_name: String
  "The API url of the failure record"
  url: String
}

type TargetFailureResponse {
  target_failure: TargetFailureObject
}

type TargetsResponse {
  targets: [TargetObject]
}

type TargetObject {
  "Whether or not the target is activated"
  active: Boolean
  "The time the target was created"
  created_at: AWSDateTime
  "Automatically assigned when created"
  id: Int
  "A name for the target"
  title: String!
  "A pre-defined target, such as \"basecamp_target\". See the additional attributes for the type that follow"
  type: String!
  "Can be filled if it is a \"message\" resource"
  message_id: String
  "only writable"
  password: String
  project_id: String!
  "\"todo\" or \"message\""
  resource: String!
  target_url: String!
  "Can be filled if it is a \"todo\" resource"
  todo_list_id: String
  token: String
  username: String
  preserve_format: Boolean
  room: String!
  ssl: Boolean
  subdomain: String!
  api_id: String!
  attribute: String!
  from: String
  "\"get\", \"patch\", \"put\", \"post\", or \"delete\""
  method: String!
  to: String!
  us_small_business_account: String
  email: String!
  subject: String!
  api_token: String!
  account_name: String!
  owner_by: String
  requested_by: String
  story_labels: String
  story_title: String!
  story_type: String!
  "only writable"
  secret: String
  "\"application/json\", \"application/xml\", or \"application/x-www-form-urlencoded\""
  content_type: String!
  group_id: String
  additionalProperties: AWSJSON
}

type TargetResponse {
  target: TargetObject
}

type TicketAuditsResponse {
  after_cursor: String
  after_url: String
  audits: [TicketAuditObject]
  before_cursor: String
  before_url: String
}

type TicketAuditObject {
  "The user who created the audit"
  author_id: Int
  "The time the audit was created"
  created_at: AWSDateTime
  "An array of the events that happened in this audit. See the [Ticket Audit events reference](/documentation/ticketing/reference-guides/ticket-audit-events-reference)"
  events: [AWSJSON]
  "Automatically assigned when creating audits"
  id: Int
  "Metadata for the audit, custom and system data"
  metadata: AWSJSON
  "The ID of the associated ticket"
  ticket_id: Int
  via: TicketAuditViaObject
}

type TicketFieldsResponse {
  ticket_fields: [TicketFieldObject]
}

type TicketFieldObject {
  "Whether this field is available"
  active: Boolean
  "A description of the ticket field that only agents can see"
  agent_description: String
  "If true, the field is shown to agents by default. If false, the field is hidden alongside infrequently used fields. Classic interface only"
  collapsed_for_agents: Boolean
  "The time the custom ticket field was created"
  created_at: AWSDateTime
  "Name of the app that created the ticket field, or a null value if no app created the ticket field"
  creator_app_name: String
  "The id of the user that created the ticket field, or a value of \"-1\" if an app created the ticket field"
  creator_user_id: Int
  "Required and presented for a custom ticket field of type \"multiselect\" or \"tagger\""
  custom_field_options: [CustomFieldOptionObject]
  "List of customized ticket statuses. Only presented for a system ticket field of type \"custom_status\""
  custom_statuses: [TicketFieldCustomStatusObject]
  "Describes the purpose of the ticket field to users"
  description: String
  "Whether this field is editable by end users in Help Center"
  editable_in_portal: Boolean
  "Automatically assigned when created"
  id: Int
  "The relative position of the ticket field on a ticket. Note that for accounts with ticket forms, positions are controlled by the different forms"
  position: Int
  "The dynamic content placeholder if present, or the `description` value if not. See [Dynamic Content](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_description: String
  "The dynamic content placeholder if present, or the `title` value if not. See [Dynamic Content](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_title: String
  "The dynamic content placeholder if present, or the \"title_in_portal\" value if not. See [Dynamic Content](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_title_in_portal: String
  "For \"regexp\" fields only. The validation pattern for a field value to be deemed valid"
  regexp_for_validation: String
  relationship_filter: AWSJSON
  "A representation of what type of object the field references. Options are \"zen:user\", \"zen:organization\", \"zen:ticket\", or \"zen:custom_object:{key}\" where key is a custom object key. For example \"zen:custom_object:apartment\"."
  relationship_target_type: String
  "If false, this field is a system field that must be present on all tickets"
  removable: Boolean
  "If true, agents must enter a value in the field to change the ticket status to solved"
  required: Boolean
  "If true, end users must enter a value in the field to create the request"
  required_in_portal: Boolean
  "For system ticket fields of type \"priority\" and \"status\". Defaults to 0. A \"priority\" sub type of 1 removes the \"Low\" and \"Urgent\" options. A \"status\" sub type of 1 adds the \"On-Hold\" option"
  sub_type_id: Int
  "Presented for a system ticket field of type \"tickettype\", \"priority\" or \"status\""
  system_field_options: [SystemFieldOptionObject]
  "For \"checkbox\" fields only. A tag added to tickets when the checkbox field is selected"
  tag: String
  "The title of the ticket field"
  title: String!
  "The title of the ticket field for end users in Help Center"
  title_in_portal: String
  "System or custom field type. Editable for custom field types and only on creation. See [Create Ticket Field](#create-ticket-field)"
  type: String!
  "The time the custom ticket field was last updated"
  updated_at: AWSDateTime
  "The URL for this resource"
  url: String
  "Whether this field is visible to end users in Help Center"
  visible_in_portal: Boolean
}

type TicketFieldCustomStatusObject {
  "If true, if the custom status is set to active. If false, the custom status is set to inactive"
  active: Boolean
  "The label displayed to agents"
  agent_label: String
  "The date and time at which the custom ticket status was created"
  created_at: AWSDateTime
  "If true, the custom status is set to default. If false, the custom status is set to non-default"
  default: Boolean
  "The description of when the user should select this custom ticket status"
  description: String
  "The description displayed to end users"
  end_user_description: String
  "The label displayed to end users"
  end_user_label: String
  "Automatically assigned when the custom ticket status is created"
  id: Int
  status_category: query_ListTicketFields_ticket_fields_items_custom_statuses_items_status_category
  "The date and time at which the custom ticket status was last updated"
  updated_at: AWSDateTime
}

"The status category the custom ticket status belongs to"
enum query_ListTicketFields_ticket_fields_items_custom_statuses_items_status_category {
  new
  open
  pending
  hold
  solved
}

type SystemFieldOptionObject {
  "Name of the system field option"
  name: String
  "Value of the system field option"
  value: String
}

type TicketFieldResponse {
  ticket_field: TicketFieldObject
}

type CustomFieldOptionsResponse {
  "Total count of records retrieved"
  count: Int
  custom_field_options: [CustomFieldOptionObject]
  "URL of the next page"
  next_page: String
  "URL of the previous page"
  previous_page: String
}

type CustomFieldOptionResponse {
  custom_field_option: CustomFieldOptionObject
}

type TicketFieldCountResponse {
  count: query_CountTicketFields_count
}

type query_CountTicketFields_count {
  refreshed_at: AWSDateTime
  value: Int
}

type TicketFormsResponse {
  ticket_forms: [TicketFormObject]
}

type TicketFormObject {
  "If the form is set as active"
  active: Boolean
  "Array of condition sets for agent workspaces"
  agent_conditions: [AWSJSON]
  "The time the ticket form was created"
  created_at: AWSDateTime
  "Is the form the default form for this account"
  default: Boolean
  "The name of the form that is displayed to an end user"
  display_name: String
  "Array of condition sets for end user products"
  end_user_conditions: [AWSJSON]
  "Is the form visible to the end user"
  end_user_visible: Boolean
  "Automatically assigned when creating ticket form"
  id: Int
  "Is the form available for use in all brands on this account"
  in_all_brands: Boolean
  "The name of the form"
  name: String!
  "The position of this form among other forms in the account, i.e. dropdown"
  position: Int
  "The dynamic content placeholder, if present, or the \"display_name\" value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_display_name: String
  "The dynamic content placeholder, if present, or the \"name\" value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_name: String
  "ids of all brands that this ticket form is restricted to"
  restricted_brand_ids: [Int]
  "ids of all ticket fields which are in this ticket form. The products use the order of the ids to show the field values in the tickets"
  ticket_field_ids: [Int]
  "The time of the last update of the ticket form"
  updated_at: AWSDateTime
  "URL of the ticket form"
  url: String
}

type TicketFormResponse {
  ticket_form: TicketFormObject
}

type TicketMetricsResponse {
  ticket_metrics: [TicketMetricObject]
}

type TicketMetricObject {
  agent_wait_time_in_minutes: TicketMetricTimeObject
  "When the ticket was assigned"
  assigned_at: AWSDateTime
  "Number of assignees the ticket had"
  assignee_stations: Int
  "When the assignee last updated the ticket"
  assignee_updated_at: AWSDateTime
  "When the record was created"
  created_at: AWSDateTime
  "The date and time the ticket's custom status was last updated"
  custom_status_updated_at: AWSDateTime
  first_resolution_time_in_minutes: TicketMetricTimeObject
  full_resolution_time_in_minutes: TicketMetricTimeObject
  "Number of groups the ticket passed through"
  group_stations: Int
  "Automatically assigned when the client is created"
  id: Int
  "When the ticket was initially assigned"
  initially_assigned_at: AWSDateTime
  "When the latest comment was added"
  latest_comment_added_at: AWSDateTime
  on_hold_time_in_minutes: TicketMetricTimeObject
  "Total number of times the ticket was reopened"
  reopens: Int
  "The number of public replies added to a ticket by an agent"
  replies: Int
  reply_time_in_minutes: TicketMetricTimeObject
  reply_time_in_seconds: TicketMetricTimeObject
  "When the requester last updated the ticket"
  requester_updated_at: AWSDateTime
  requester_wait_time_in_minutes: TicketMetricTimeObject
  "When the ticket was solved"
  solved_at: AWSDateTime
  "When the status of the ticket was last updated"
  status_updated_at: AWSDateTime
  "Id of the associated ticket"
  ticket_id: Int
  "When the record was last updated"
  updated_at: AWSDateTime
  "The API url of the ticket metric"
  url: String
}

type TicketMetricTimeObject {
  "Time in business hours"
  business: Int
  "Time in calendar hours"
  calendar: Int
}

type TicketMetricsByTicketMetricIdResponse {
  ticket_metric: [TicketMetricObject]
}

type TicketsResponse {
  tickets: [TicketObject]
}

type TicketResponse {
  ticket: TicketObject
}

type TicketAuditsResponseNoneCursor {
  audits: [TicketAuditObject]
  count: Int
  next_page: String
  previous_page: String
}

type TicketAuditResponse {
  audit: TicketAuditObject
}

type TicketAuditsCountResponse {
  count: query_CountAuditsForTicket_count
}

type query_CountAuditsForTicket_count {
  refreshed_at: AWSDateTime
  value: Int
}

type TicketCommentsCountResponse {
  count: query_CountTicketComments_count
}

type query_CountTicketComments_count {
  refreshed_at: AWSDateTime
  value: Int
}

type TicketRelatedInformation {
  followup_source_ids: [String]
  "Is true if the current ticket is archived"
  from_archive: Boolean
  "A count of related incident occurrences"
  incidents: Int
  "Related topic in the Web portal (deprecated feature)"
  topic_id: String
  "X (formerly Twitter) information associated with the ticket"
  twitter: AWSJSON
}

type CountTickets_200_response {
  count: query_CountTickets_count
}

type query_CountTickets_count {
  refreshed_at: AWSDateTime
  value: Int
}

union ListTriggerCategories_response = ListTriggerCategories_200_response | Errors

type ListTriggerCategories_200_response {
  trigger_categories: [query_ListTriggerCategories_oneOf_0_allOf_0_trigger_categories_items]
  links: query_ListTriggerCategories_oneOf_0_allOf_1_links
  meta: query_ListTriggerCategories_oneOf_0_allOf_1_meta
}

type query_ListTriggerCategories_oneOf_0_allOf_0_trigger_categories_items {
  created_at: String
  id: String
  name: String
  position: Int
  updated_at: String
  active_count: Int
  inactive_count: Int
}

"The `BigInt` scalar type represents non-fractional signed whole numeric values."
scalar Int

type query_ListTriggerCategories_oneOf_0_allOf_1_links {
  next: String
  prev: String
}

type query_ListTriggerCategories_oneOf_0_allOf_1_meta {
  after_cursor: String
  before_cursor: String
  has_more: Boolean
}

"Pagination parameters"
input queryInput_ListTriggerCategories_page_Input {
  after: String
  before: String
  size: Int
}

"Sort parameters"
enum queryInput_ListTriggerCategories_sort {
  position
  _position
  name
  _name
  created_at
  _created_at
  updated_at
  _updated_at
}

enum rule_counts_const {
  rule_counts
}

union ShowTriggerCategoryById_response = TriggerCategoryResponse | Errors

type TriggerCategoryResponse {
  trigger_category: TriggerCategory
}

type TriggerCategory {
  created_at: String
  id: String
  name: String
  position: Int
  updated_at: String
}

type TriggersResponse {
  count: Int
  next_page: String
  previous_page: String
  triggers: [TriggerObject]
}

type TriggerObject {
  "An array of actions describing what the trigger will do. See [Actions reference](/documentation/ticketing/reference-guides/actions-reference)"
  actions: [TriggerActionObject]!
  "Whether the trigger is active"
  active: Boolean
  "The ID of the category the trigger belongs to"
  category_id: String
  conditions: TriggerConditionsObject!
  "The time the trigger was created"
  created_at: String
  "If true, the trigger is a default trigger"
  default: Boolean
  "The description of the trigger"
  description: String
  "Automatically assigned when created"
  id: Int
  "Position of the trigger, determines the order they will execute in"
  position: Int
  "The raw format of the title of the trigger"
  raw_title: String
  "The title of the trigger"
  title: String!
  "The time of the last update of the trigger"
  updated_at: String
  "The url of the trigger"
  url: String
}

type TriggerActionObject {
  field: String
  value: [query_ListTriggers_triggers_items_actions_items_value]
}

union query_ListTriggers_triggers_items_actions_items_value = String_container | Int_container

"An object that describes the conditions under which the trigger will execute. See [Conditions reference](/documentation/ticketing/reference-guides/conditions-reference)"
type TriggerConditionsObject {
  all: [TriggerConditionObject]
  any: [TriggerConditionObject]
}

type TriggerConditionObject {
  field: String
  operator: String
  value: [query_ListTriggers_triggers_items_conditions_all_items_value]
}

union query_ListTriggers_triggers_items_conditions_all_items_value = String_container | Int_container

type TriggerResponse {
  trigger: TriggerObject
}

type TriggerRevisionsResponse {
  after_cursor: String
  after_url: String
  before_cursor: String
  before_url: String
  count: Int
  trigger_revisions: [query_ListTriggerRevisions_trigger_revisions_items]
}

type query_ListTriggerRevisions_trigger_revisions_items {
  author_id: Int
  created_at: String
  diff: query_ListTriggerRevisions_trigger_revisions_items_diff
  id: Int
  snapshot: TriggerSnapshotObject
  url: String
}

type query_ListTriggerRevisions_trigger_revisions_items_diff {
  "An array that contain [action diff objects](#Action Diffs)"
  actions: [TriggerActionDiffObject]
  "An array of [change](#change) objects"
  active: [TriggerChangeObject]
  conditions: TriggerConditionDiffObject
  "An array of [change](#change) objects"
  description: [TriggerChangeObject]
  "ID of the source revision"
  source_id: Int
  "ID of the target revision"
  target_id: Int
  "An array of [change](#change) objects"
  title: [TriggerChangeObject]
}

type TriggerActionDiffObject {
  "An array of [change](#change) objects."
  field: [TriggerChangeObject]
  "An array of [change](#change) objects."
  value: [TriggerChangeObject]
}

type TriggerChangeObject {
  "One of `-`, `+`, `=` representing the type of change"
  change: String
  content: [query_ListTriggerRevisions_trigger_revisions_items_diff_actions_items_field_items_content]
}

"The value of the item it represents"
union query_ListTriggerRevisions_trigger_revisions_items_diff_actions_items_field_items_content = String_container | Int_container | Boolean_container

type Boolean_container {
  Boolean: Boolean
}

type TriggerConditionDiffObject {
  "An array of [change](#change) objects"
  field: [TriggerChangeObject]
  "An array of [change](#change) objects"
  operator: [TriggerChangeObject]
  "An array of [change](#change) objects"
  value: [TriggerChangeObject]
}

type TriggerSnapshotObject {
  "An array of [Actions](#actions) describing what the trigger will do"
  actions: [TriggerActionObject]
  "Whether the trigger is active"
  active: Boolean
  conditions: TriggerConditionsObject
  "The description of the trigger"
  description: String
  "The title of the trigger"
  title: String
}

type TriggerRevisionResponse {
  trigger_revision: query_TriggerRevision_trigger_revision
}

type query_TriggerRevision_trigger_revision {
  author_id: Int
  created_at: String
  id: Int
  snapshot: query_TriggerRevision_trigger_revision_snapshot
  url: String
}

type query_TriggerRevision_trigger_revision_snapshot {
  actions: [TriggerActionObject]
  active: Boolean
  conditions: TriggerConditionsObject
  description: String
  title: String
}

type TriggerDefinitionResponse {
  definitions: TriggerDefinitionObject
}

type TriggerDefinitionObject {
  actions: [TriggerActionDefinitionObject]
  conditions_all: [TriggerConditionDefinitionObjectAll]
  conditions_any: [TriggerConditionDefinitionObjectAny]
}

type TriggerActionDefinitionObject {
  group: String
  nullable: Boolean
  repeatable: Boolean
  subject: String
  title: String
  type: String
  values: [properties_actions_items_values_items]
}

type properties_actions_items_values_items {
  enabled: Boolean
  title: String
  value: String
}

"Trigger attribute filters for the search. See [Filter](#filter)"
input TriggerSearchFilter_parameter_Input {
  json: TriggerObject_Input
}

input TriggerObject_Input {
  "An array of actions describing what the trigger will do. See [Actions reference](/documentation/ticketing/reference-guides/actions-reference)"
  actions: [TriggerActionObject_Input]!
  "Whether the trigger is active"
  active: Boolean
  "The ID of the category the trigger belongs to"
  category_id: String
  conditions: TriggerConditionsObject_Input!
  "The time the trigger was created"
  created_at: String
  "If true, the trigger is a default trigger"
  default: Boolean
  "The description of the trigger"
  description: String
  "Automatically assigned when created"
  id: Int
  "Position of the trigger, determines the order they will execute in"
  position: Int
  "The raw format of the title of the trigger"
  raw_title: String
  "The title of the trigger"
  title: String!
  "The time of the last update of the trigger"
  updated_at: String
  "The url of the trigger"
  url: String
}

input TriggerActionObject_Input {
  field: String
  value: [query_ListTriggers_triggers_items_actions_items_value_Input]
}

input query_ListTriggers_triggers_items_actions_items_value_Input {
  String: String
  Int: Int
  query_ListTriggers_triggers_items_actions_items_value_oneOf_2_items_Input: query_ListTriggers_triggers_items_actions_items_value_oneOf_2_items_Input
}

input query_ListTriggers_triggers_items_actions_items_value_oneOf_2_items_Input {
  String: String
  Int: Int
}

"An object that describes the conditions under which the trigger will execute. See [Conditions reference](/documentation/ticketing/reference-guides/conditions-reference)"
input TriggerConditionsObject_Input {
  all: [TriggerConditionObject_Input]
  any: [TriggerConditionObject_Input]
}

input TriggerConditionObject_Input {
  field: String
  operator: String
  value: [query_ListTriggers_triggers_items_conditions_all_items_value_Input]
}

input query_ListTriggers_triggers_items_conditions_all_items_value_Input {
  String: String
  Int: Int
  query_ListTriggers_triggers_items_conditions_all_items_value_oneOf_2_items_Input: query_ListTriggers_triggers_items_conditions_all_items_value_oneOf_2_items_Input
}

input query_ListTriggers_triggers_items_conditions_all_items_value_oneOf_2_items_Input {
  String: String
  Int: Int
}

type UserFieldsResponse {
  "Total count of records retrieved"
  count: Int
  "URL of the next page"
  next_page: String
  "URL of the previous page"
  previous_page: String
  user_fields: [UserFieldObject]
}

type UserFieldObject {
  "If true, this field is available for use"
  active: Boolean
  "The time of the last update of the ticket field"
  created_at: AWSDateTime
  "Required and presented for a custom field of type \"dropdown\". Each option is represented by an object with a `name` and `value` property"
  custom_field_options: [CustomFieldOptionObject]
  "User-defined description of this field's purpose"
  description: String
  "Automatically assigned upon creation"
  id: Int
  "A unique key that identifies this custom field. This is used for updating the field and referencing in placeholders. The key must consist of only letters, numbers, and underscores. It can't be only numbers"
  key: String!
  "Ordering of the field relative to other fields"
  position: Int
  "The dynamic content placeholder, if present, or the `description` value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_description: String
  "The dynamic content placeholder, if present, or the `title` value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_title: String
  "Regular expression field only. The validation pattern for a field value to be deemed valid"
  regexp_for_validation: String
  relationship_filter: AWSJSON
  "A representation of what type of object the field references. Options are \"zen:user\", \"zen:organization\", \"zen:ticket\", and \"zen:custom_object:{key}\" where key is a custom object key. For example \"zen:custom_object:apartment\"."
  relationship_target_type: String
  "If true, only active and position values of this field can be changed"
  system: Boolean
  "Optional for custom field of type \"checkbox\"; not presented otherwise."
  tag: String
  "The title of the custom field"
  title: String!
  "The custom field type: \"checkbox\", \"date\", \"decimal\", \"dropdown\", \"integer\", [\"lookup\"](/api-reference/ticketing/lookup_relationships/lookup_relationships/), \"regexp\", \"text\", or \"textarea\""
  type: String!
  "The time of the last update of the ticket field"
  updated_at: AWSDateTime
  "The URL for this resource"
  url: String
}

type UserFieldResponse {
  user_field: UserFieldObject
}

input UserFieldId_parameter_Input {
  Int: Int
  String: String
}

type UsersResponse {
  users: [UserObject]
}

"Filters the results by role. Possible values are \"end-user\", \"agent\", or \"admin\""
enum UserRoleFilter_parameter {
  end_user
  agent
  admin
}

type UserResponse {
  user: UserObject
}

type ComplianceDeletionStatusesResponse {
  compliance_deletion_statuses: [ComplianceDeletionStatusObject]
}

type ComplianceDeletionStatusObject {
  account_subdomain: String!
  action: String!
  application: String!
  created_at: String!
  executer_id: Int
  user_id: Int!
}

type UserIdentitiesResponse {
  identities: [UserIdentityObject]
}

type UserIdentityObject {
  "The time the identity was created"
  created_at: AWSDateTime
  "Email identity type only. Indicates if Zendesk sends notifications to the email address. See [Deliverable state](#deliverable-state)"
  deliverable_state: String
  "Automatically assigned on creation"
  id: Int
  "If the identity is the primary identity. *Writable only when creating, not when updating. Use the [Make Identity Primary](#make-identity-primary) endpoint instead"
  primary: Boolean
  type: query_ListUserIdentities_identities_items_type!
  "The number of times a soft-bounce response was received at that address"
  undeliverable_count: Int
  "The time the identity was updated"
  updated_at: AWSDateTime
  "The API url of this identity"
  url: String
  "The id of the user"
  user_id: Int!
  "The identifier for this identity, such as an email address"
  value: String!
  "If the identity has been verified"
  verified: Boolean
}

"The type of this identity"
enum query_ListUserIdentities_identities_items_type {
  email
  twitter
  facebook
  google
  phone_number
  agent_forwarding
  any_channel
  foreign
  sdk
}

type UserIdentityResponse {
  identity: UserIdentityObject
}

type UserPasswordRequirementsResponse {
  requirements: [String]
}

type UserRelatedResponse {
  user_related: UserRelatedObject
}

type UserRelatedObject {
  "Count of assigned tickets"
  assigned_tickets: Int
  "Count of collaborated tickets"
  ccd_tickets: Int
  "Count of organization subscriptions"
  organization_subscriptions: Int
  "Count of requested tickets"
  requested_tickets: Int
}

type SessionResponse {
  session: [SessionObject]
}

type TicketSkipsResponse {
  skips: [TicketSkipObject]
}

type TicketSkipObject {
  "Time the skip was created"
  created_at: AWSDateTime
  "Automatically assigned upon creation"
  id: Int
  "Reason for skipping the ticket"
  reason: String
  ticket: TicketObject
  "ID of the skipped ticket"
  ticket_id: Int
  "Time the skip was last updated"
  updated_at: AWSDateTime
  "ID of the skipping agent"
  user_id: Int
}

type CurrentUserResponse {
  user: query_ShowCurrentUser_user
}

type query_ShowCurrentUser_user {
  "false if the user has been deleted"
  active: Boolean
  "An alias displayed to end users"
  alias: String
  "Whether or not the user is a chat-only agent"
  chat_only: Boolean
  "The time the user was created"
  created_at: String
  "A custom role if the user is an agent on the Enterprise plan or above"
  custom_role_id: Int
  "The id of the user's default group"
  default_group_id: Int
  "Any details you want to store about the user, such as an address"
  details: String
  "The primary email address of this user. If the primary email address is not [verified](https://support.zendesk.com/hc/en-us/articles/4408886752410), the secondary email address is used"
  email: String
  "A unique identifier from another system. The API treats the id as case insensitive. Example: \"ian1\" and \"IAN1\" are the same value."
  external_id: String
  "The time zone for the user"
  iana_time_zone: String
  "Automatically assigned when creating users"
  id: Int
  "Last time the user signed in to Zendesk Support or made an API request\nusing an API token or basic authentication"
  last_login_at: String
  "The locale for this user"
  locale: String
  "The language identifier for this user"
  locale_id: Int
  "Designates whether the user has forum moderation capabilities"
  moderator: Boolean
  "The name of the user"
  name: String!
  "Any notes you want to store about the user"
  notes: String
  "true if the user can only create private comments"
  only_private_comments: Boolean
  "The id of the user's organization. If the user has more than one [organization memberships](/api-reference/ticketing/organizations/organization_memberships/), the id of the user's default organization. If updating, see [Organization ID](/api-reference/ticketing/users/users/#organization-id)"
  organization_id: Int
  "The primary phone number of this user. See [Phone Number](/api-reference/ticketing/users/users/#phone-number) in the Users API"
  phone: String
  "The user's profile picture represented as an [Attachment](/api-reference/ticketing/tickets/ticket-attachments/) object"
  photo: AWSJSON
  "A URL pointing to the user's profile picture."
  remote_photo_url: String
  "This parameter is inert and has no effect. It may be deprecated in the\nfuture.\n\nPreviously, this parameter determined whether a user could access a CSV\nreport in a legacy Guide dashboard. This dashboard has been removed. See\n[Announcing Guide legacy reporting upgrade to\nExplore](https://support.zendesk.com/hc/en-us/articles/4762263171610-Announcing-Guide-legacy-reporting-upgrade-to-Explore-)"
  report_csv: Boolean
  "If the agent has any restrictions; false for admins and unrestricted agents, true for other agents"
  restricted_agent: Boolean
  "The role of the user. Possible values: `\"end-user\"`, `\"agent\"`, `\"admin\"`"
  role: String
  "The user's role id. 0 for a custom agent, 1 for a light agent, 2 for a chat agent, 3 for a chat agent added to the Support account as a contributor ([Chat Phase 4](https://support.zendesk.com/hc/en-us/articles/360022365373#topic_djh_1zk_4fb)), 4 for an admin, and 5 for a billing admin"
  role_type: Int
  "If the user is shared from a different Zendesk Support instance. Ticket sharing accounts only"
  shared: Boolean
  "If the user is a shared agent from a different Zendesk Support instance. Ticket sharing accounts only"
  shared_agent: Boolean
  "Whether the `phone` number is shared or not. See [Phone Number](/api-reference/ticketing/users/users/#phone-number) in the Users API"
  shared_phone_number: Boolean
  "The user's signature. Only agents and admins can have signatures"
  signature: String
  "If the agent is suspended. Tickets from suspended users are also suspended, and these users cannot sign in to the end user portal"
  suspended: Boolean
  "The user's tags. Only present if your account has user tagging enabled"
  tags: [String]
  "Specifies which tickets the user has access to. Possible values are: \"organization\", \"groups\", \"assigned\", \"requested\", null. \"groups\" and \"assigned\" are valid only for agents. If you pass an invalid value to an end user (for example, \"groups\"), they will be assigned to \"requested\", regardless of their previous access"
  ticket_restriction: String
  "The time-zone of this user"
  time_zone: String
  "If two factor authentication is enabled"
  two_factor_auth_enabled: Boolean
  "The time of the last update of the user"
  updated_at: String
  "The API url of this user"
  url: String
  "Values of custom fields in the user's profile. See [User Fields](#user-fields)"
  user_fields: AWSJSON
  "Any of the user's identities is verified. See [User Identities](/api-reference/ticketing/users/user_identities)"
  verified: Boolean
  additionalProperties: AWSJSON
  "CSRF token required by some Zendesk APIs."
  authenticity_token: String
}

type RenewSessionResponse {
  "A token of authenticity for the request"
  authenticity_token: String
}

type ViewsResponse {
  count: Int
  next_page: String
  previous_page: String
  views: [ViewObject]
}

type ViewObject {
  "Whether the view is active"
  active: Boolean
  "Describes how the view is constructed. See [Conditions reference](/documentation/ticketing/reference-guides/conditions-reference)"
  conditions: AWSJSON
  "The time the view was created"
  created_at: AWSDateTime
  "If true, the view is a default view"
  default: Boolean
  "The description of the view"
  description: String
  "Describes how the view should be executed. See [Execution](#execution)"
  execution: AWSJSON
  "Automatically assigned when created"
  id: Int
  "The position of the view"
  position: Int
  "Who may access this account. Is null when everyone in the account can access it"
  restriction: AWSJSON
  "The title of the view"
  title: String
  "The time the view was last updated"
  updated_at: AWSDateTime
}

type ViewResponse {
  columns: [AWSJSON]
  groups: [AWSJSON]
  rows: [AWSJSON]
  view: ViewObject
}

type ViewCountResponse {
  view_count: ViewCountObject
}

type ViewCountObject {
  "Only active views if true, inactive views if false, all views if null."
  active: Boolean
  "false if the cached data is stale and the system is still loading and caching new data"
  fresh: Boolean
  "A pretty-printed text approximation of the view count"
  pretty: String
  "The API url of the count"
  url: String
  "The cached number of tickets in the view. Can also be null if the system is loading and caching new data. Not to be confused with 0 tickets"
  value: Int
  "The id of the view"
  view_id: Int
}

type ViewExportResponse {
  export: query_ExportView_export
}

type query_ExportView_export {
  status: String
  view_id: Int
}

type ViewsCountResponse {
  count: query_CountViews_count
}

type query_CountViews_count {
  refreshed_at: AWSDateTime
  value: Int
}

type ViewCountsResponse {
  view_counts: [ViewCountObject]
}

type WorkspaceResponse {
  workspaces: [WorkspaceObject]
  "the total record count"
  count: Int
  "the URL of the next page"
  next_page: String
  "the URL of the previous page"
  previous_page: String
}

type WorkspaceObject {
  "If true, this workspace is available for use"
  activated: Boolean
  "The apps associated to this workspace"
  apps: [AWSJSON]
  conditions: ConditionsObject
  "The time the workspace was created"
  created_at: AWSDateTime
  "User-defined description of this workspace's purpose"
  description: String
  "Automatically assigned upon creation"
  id: Int
  "The ids of the macros associated to this workspace"
  macro_ids: [Int]
  "The ids of the macros associated to this workspace"
  macros: [Int]
  "Ordering of the workspace relative to other workspaces"
  position: Int
  "If true, the order of apps within the workspace will be preserved"
  prefer_workspace_app_order: Boolean
  "An array of the macro objects that will be used in this workspace. See [Macros](/api-reference/ticketing/business-rules/macros/)"
  selected_macros: [MacroObject]
  "The id of the ticket web form associated to this workspace"
  ticket_form_id: Int
  "The title of the workspace"
  title: String
  "The time of the last update of the workspace"
  updated_at: AWSDateTime
  "The URL for this resource"
  url: String
}

type ShowWorkspace_200_response {
  workspace: WorkspaceObject
}

type Mutation {
  "Updates settings for the account. See [JSON Format](#json-format) above for the settings you can update.\n\n#### Allowed For\n\n* Admins\n"
  UpdateAccountSettings(subdomain: String = "example", domain: String = "zendesk"): AccountSettingsResponse
  "Create Trial Account"
  CreateTrialAccount(subdomain: String = "example", domain: String = "zendesk"): TrialAccountResponse
  "#### Allowed For\n\n* Admins\n\n#### Request parameters\n\nThe POST request takes a JSON object parameter which contains information about the\nproblematic [channelback](/documentation/channel_framework/understanding-the-channel-framework/channelback/).\n\n| Name               | Type      | Required  | Comments\n| ------------------ | ----------| --------- | -------------------\n| instance_push_id   | string    | yes       | The ID of the account to which data will be pushed.  This was passed to the integration service when the administrator set up the account\n| external_id        | string    | yes       | Unique identifier of the external resource from the original channelback (string)\n| description        | string    | no        | A human readable description of the error\n| request_id         | string    | no        | A unique identifier for the request\n\n\n#### Response format\n\nThe response does not include a response body\n"
  ReportChannelbackError(subdomain: String = "example", domain: String = "zendesk"): String
  "Pushes Channel framework content to Zendesk.\n\n#### Allowed For\n\n* Admins\n\n#### Request parameters\n\nThe POST request takes a JSON object parameter which contains data about all\nthe resources that the client is pushing.\n\n| Name               | Type      | Required  | Comments\n| ------------------ | ----------| --------- | -------------------\n| instance_push_id   | string    | yes       | The account ID where data will be pushed. This was passed to the integration service when the administrator set up the account\n| request_id         | string    | no        | A unique identifier for the push request\n| external_resources | array     | yes       | The [resources](#external_resource-object) to push\n\n#### external_resource object\n\n| Name               | Type                               | Max length | Mandatory | Comments\n|------------------- | ---------------------------------- |------------| --------- | ----------\n| external_id        | string                             | 255        | yes       | Unique identifier of the external resource. Must be ASCII characters\n| internal_note      | boolean                            |            | no        | If true creates a new internal note comment\n| message            | string                             | 65535      | yes       | Text to be converted to a ticket or comment\n| html_message       | string                             | 65535      | no        | HTML version of message\n| parent_id          | string                             | 511        | no        | Unique identifier of the external resource for which this is a response. Used to choose the correct thread. Responses may include `parent_id` or `thread_id`, but not both. See [Conversation threads](/documentation/channel_framework/understanding-the-channel-framework/pull_endpoint/#conversation-threads)\n| thread_id          | string                             | 255        | no        | Arbitrary identifier of the thread to which this item should belong. Responses may include `parent_id` or `thread_id`, but not both. See [Conversation threads](/documentation/channel_framework/understanding-the-channel-framework/pull_endpoint/#conversation-threads)\n| created_at         | string                             |            | yes       | When the resource was created in the origin system, as an ISO 8601 extended format date-time. Example: '2015-09-08T22:48:09Z'\n| author             | object                             |            | yes       | See [author object](#author-object) below\n| display_info       | array                              |            | no        | Array of integration-specific data used by apps to modify the agent UI. See [display_info object](#display_info-object) below\n| allow_channelback  | boolean                            |            | no        | If false, prevents the agent from making additional comments on the message in the Zendesk interface\n| fields             | array                              |            | no        | Array of ticket fields to set in Zendesk and their values. See [fields array](#fields-array)\n| file_urls          | array                              | 10         | no        | Array of files to be imported into Zendesk. See [file urls](/documentation/channel_framework/understanding-the-channel-framework/pull_endpoint/#file-urls) in the Channel framework docs\n\n#### author object\n\n| Name        | Type   | Max chars | Mandatory | Comments\n|------------ | ------ |---------- |---------- |-----------\n| external_id | string | 255       | yes       | Unique identifier of the user in the origin service\n| name        | string | 255       | no        | If not supplied, defaults to external id\n| image_url   | string | 255       | no        | URL to an image for the user\n| locale      | String | 255       | no        | The user's locale. Must be one of the supported [locales](/api-reference/ticketing/account-configuration/locales/#list-available-public-locales) in Zendesk\n| fields      | array  |           | no        | Array of items containing user field identifier ('id') and value of field ('value'.)  For system fields ('notes' or 'details'), the identifier is the English name. For custom fields, the identifier may be the ID or the name\n\n#### display_info object\n\n| Name | Type   | Max chars | Mandatory | Comments\n|----- | ------ |---------- |---------- |-----------\n| type | string | 255       | yes       | Globally unique type identifier defined by the integration origin service. Examples: a GUID or URI\n| data | string | 65535     | yes       | JSON data containing display hints\n\n#### fields array\n\nThe `fields` array lists ticket fields to set in Zendesk and their values. Each item consists of a field identifier (`id`) and a value (`value`) for the field. For Zendesk system fields such as `subject`, the identifier is the English name. For custom fields, the identifier may be a field ID or a name. See [Ticket Fields](/api-reference/ticketing/tickets/ticket_fields/).\n\nThe `fields` array can only set ticket values on ticket creation, not on ticket updates.\n\n#### Response format\n\nThe response is a JSON object containing a single key:\n\n| Name      | Type     | Comments\n| --------- | -------- | -------------------\n| results   | array    | An array of [result objects](#result-object)\n\nThe `results` array contains an entry for each item in the incoming `external_resources` array, in the\nsame order.  For example, if you call `push` with 3 external resources, a successful response will include\n`results` with three entries, corresponding to your 3 resources.\n\n#### result object\n\n| Name                 | Type                           | Comments\n| -------------------- | ------------------------------ | -------------------\n| external_resource_id | string                         | The external ID of the resource, as passed in\n| status               | object                         | The status of the import for the indicated resource. See [status object](#status-object)\n\n#### status object\n\n| Name        | Type   | Comments\n| ----------- | ------ | -------------------\n| code        | string | A code indicating the status of the import of the resource, as described in [status codes](#status-codes)\n| description | string | In the case of an exception, a description of the exception. Otherwise, not present.\n\n#### status codes\n\n| Key                                       | Description\n| ----------------------------------------- | ----------------\n| success                                   | The external resource was successfully converted to a ticket or comment\n| already_imported                          | Reimport of the external resource was skipped due to a pre-existing ticket or comment for the resource\n| could_not_locate_parent_external_resource | The parent resource, as identified by parent_id in the [request](#request-parameters), could not be found. The unrecognized parent ID is returned in the description of the [status](#status-object)\n| processing_error                          | An internal exception occurred while processing the resource. See `description` in the [status object](#status-object)\n| halted                                    | This resource was not processed because processing of previous resources failed\n"
  PushContentToSupport(subdomain: String = "example", domain: String = "zendesk"): ChannelFrameworkPushResultsResponse
  "#### Allowed For\n\n* Admins\n\n#### Request parameters\n\nThe POST request takes a JSON object parameter which contains the token to be validated.\n\n| Name               | Type      | Required  | Comments\n| ------------------ | ----------| --------- | -------------------\n| instance_push_id   | string    | yes       | The ID of the account to which data will be pushed. This was passed to the integration service when the administrator set up the account\n| request_id         | string    | no        | A unique identifier for the push request\n\n#### Response format\n\nThe response body is empty.\n"
  ValidateToken(subdomain: String = "example", domain: String = "zendesk"): String
  "Toggles enabling or restricting agent access to attachments with detected malware.\n\n#### Allowed For\n\n* Admins\n"
  UpdateAttachment(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the attachment"
    attachment_id: Int!
    input: AttachmentUpdateRequest_Input
  ): AttachmentResponse
  "#### Allowed For\n\n* Admins on accounts that have audit log access\n"
  ExportAuditLogs(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Filter audit logs by the source type. For example, user or rule"
    filter_LEFT_SQUARE_BRACE_source_type_RIGHT_SQUARE_BRACE_: String
    "Filter audit logs by the source id. Requires `filter[source_type]` to also be set."
    filter_LEFT_SQUARE_BRACE_source_id_RIGHT_SQUARE_BRACE_: Int
    "Filter audit logs by the actor id"
    filter_LEFT_SQUARE_BRACE_actor_id_RIGHT_SQUARE_BRACE_: Int
    "Filter audit logs by the ip address"
    filter_LEFT_SQUARE_BRACE_ip_address_RIGHT_SQUARE_BRACE_: String
    "Filter audit logs by the time of creation. When used, you must specify `filter[created_at]` twice in your request, first with the start time and again with an end time"
    filter_LEFT_SQUARE_BRACE_created_at_RIGHT_SQUARE_BRACE_: String
    "Filter audit logs by the action"
    filter_LEFT_SQUARE_BRACE_action_RIGHT_SQUARE_BRACE_: String
  ): String
  "Creates an automation.\n\nNew automations must be unique and have at least one condition that is true only once or an action that nullifies at least one of the conditions. Active automations can have overlapping conditions but can't be identical.\n\nThe request must include the following conditions in the `all` array:\n\n- At least one time-based condition\n- At least one condition that checks one of the following fields: `status`, `type`, `group_id`, `assignee_id`, or `requester_id`.\n\n#### Allowed For\n\n* Agents\n"
  CreateAutomation(subdomain: String = "example", domain: String = "zendesk"): AutomationResponse
  "Updates an automation.\n\nUpdated automations must be unique and have at least one condition that is true only once or an action that nullifies at least one of the conditions. Active automations can have overlapping conditions but can't be identical.\n\nThe request must include the following conditions in the `all` array:\n- At least one time-based condition\n- At least one condition that checks one of the following fields: 'status', 'type', 'group_id', 'assignee_id', or 'requester_id'\n\n**Note**: Updating a condition or action updates both the `conditions` and `actions` arrays, clearing all existing values of both arrays. Include all your conditions and actions when updating any condition or action.\n**Note**: You might be restricted from updating some default automations.\n\n#### Allowed For\n\n* Agents\n"
  UpdateAutomation(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the automation"
    automation_id: Int!
  ): AutomationResponse
  "**Note**: You might be restricted from deleting some default automations.\n\n#### Allowed For\n\n* Agents\n"
  DeleteAutomation(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the automation"
    automation_id: Int!
  ): Boolean
  "Deletes the automations corresponding to the provided comma-separated list of IDs.\n\n**Note**: You might be restricted from deleting some default automations. If included in a bulk deletion, the unrestricted automations will be deleted.\n\n#### Allowed For\n\n* Agents\n\n#### Request Parameters\n\nThe DELETE request takes one parameter, an `ids` object that lists the automations to delete.\n\n| Name | Description\n| ---- | -----------\n| ids  | The IDs of the automations to delete\n\n#### Example request\n\n```js\n{\n  \"ids\": \"25,23,27,22\"\n}\n```\n"
  BulkDeleteAutomations(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The IDs of the automations to delete"
    ids: [Int]
  ): Boolean
  "**Note**: You might be restricted from updating some default automations. If included in a bulk update, the unrestricted automations will be updated.\n\n#### Allowed For\n\n* Agents\n\n#### Request Parameters\n\nThe PUT request expects an `automations` object that lists the automations to update.\n\nEach automation may have the following properties:\n\n| Name     | Mandatory | Description\n| -------- | --------- | -----------\n| id       | yes       | The ID of the automation to update\n| position | no        | The new position of the automation\n| active   | no        | The active status of the automation (true or false)\n\n#### Example Request\n\n```js\n{\n  \"automations\": [\n    {\"id\": 25, \"position\": 3},\n    {\"id\": 23, \"position\": 5},\n    {\"id\": 27, \"position\": 9},\n    {\"id\": 22, \"position\": 7}\n  ]\n}\n```\n"
  UpdateManyAutomations(subdomain: String = "example", domain: String = "zendesk"): AutomationsResponse
  "#### Allowed For\n- Agents"
  CreateBookmark(subdomain: String = "example", domain: String = "zendesk", input: BookmarkCreateRequest_Input): BookmarkResponse
  "#### Allowed For\n- Agents (own bookmarks only)\n\nIf the bookmark already exists with a specified ticket id, the response status will be `http Status: 200 OK`."
  DeleteBookmark(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the bookmark"
    bookmark_id: Int!
  ): Boolean
  "#### Allowed for\n- Admins"
  CreateBrand(subdomain: String = "example", domain: String = "zendesk", input: BrandCreateRequest_Input): BrandResponse
  "Returns an updated brand.\n\n#### Allowed for\n* Admins\n\n#### Updating a Brand's Image\nA brand image can be updated by uploading a local file using the update brand endpoint. See the **Using curl** sections below for more information."
  UpdateBrand(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the brand"
    brand_id: Int!
    input: BrandUpdateRequest_Input
  ): BrandResponse
  "Deletes a brand.\n\n#### Allowed for\n- Admins"
  DeleteBrand(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the brand"
    brand_id: Int!
  ): Boolean
  "Turns a tweet into a ticket. You must provide the tweet id as well as the id of a monitored X (formerly Twitter) handle configured for your account.\n\nThe submitter of the ticket is set to be the user submitting the API request.\n\n#### Allowed For\n\n* Agents\n"
  CreateTicketFromTweet(subdomain: String = "example", domain: String = "zendesk"): String
  "Allows you to instruct an agent's browser to open a ticket.\n\nWhen the message is successfully delivered to an agent's browser:\n\n```http\nStatus: 200 OK\n```\n\nWhen `agent_id` or `ticket_id` is invalid:\n\n```http\nStatus: 404 Not Found\n```\n\n#### Allowed For\n* Agents"
  OpenTicketInAgentBrowser(
    subdomain: String = "example"
    domain: String = "zendesk"
    "ID of an agent"
    agent_id: Int!
    "The ID of the ticket"
    ticket_id: Int!
  ): String
  "Allows you to instruct an agent's browser to open a user's profile.\n\nWhen the message is successfully delivered to an agent's browser:\n\n```http\nStatus: 200 OK\n```\n\nWhen `agent_id` or `user_id` is invalid:\n\n```http\nStatus: 404 Not Found\n```\n\n#### Allowed For\n* Agents"
  OpenUsersProfileInAgentBrowser(
    subdomain: String = "example"
    domain: String = "zendesk"
    "ID of an agent"
    agent_id: Int!
    "The id of the user"
    user_id: Int!
  ): String
  "#### Allowed For\n* Agents\n\n### Creating tickets\n\n#### Introduction\n\nCreating tickets using Talk Partner Edition follows the same conventions as the Create Ticket endpoint. See [Create Ticket](/api-reference/ticketing/tickets/tickets/#create-ticket).\n\n#### Request parameters\n\nThe POST request takes a mandatory `ticket` object that lists the values to set when the ticket is created.\nYou may also include an optional `display_to_agent` value such as the ID of the agent that will see the newly created ticket.\n\nTickets created using this endpoint must have a `via_id` parameter. See the following\nsection for possible values.\n\n#### Zendesk Talk Integration Via IDs\n\nTickets created using this endpoint must have one of the following `via_id` parameters:\n\n| ID       | Description\n| ---------| -------------\n| 44       | Voicemail\n| 45       | Phone call (inbound)\n| 46       | Phone call (outbound)\n\n### Creating voicemail tickets\n#### Request parameters\n\nThe POST request takes a mandatory `ticket` object that lists the values to set when the ticket is created.\nThe ticket must have a `voice_comment` with the following values:\n\n| Name               | Type                  | Comment\n| ------------------ | ----------------------| -------\n| from               | string                | Incoming phone number\n| to                 | string                | Dialed phone number\n| recording_url      | string                | URL of the recording\n| started_at         | date                  | [ISO 8601](http://en.wikipedia.org/wiki/ISO_8601) timestamp of the call starting time\n| call_duration      | integer               | Duration in seconds of the call\n| answered_by_id     | integer               | The agent who answered the call\n| transcription_text | string                | Transcription of the call (optional)\n| location           | string                | Location of the caller (optional)"
  CreateTicketOrVoicemailTicket(subdomain: String = "example", domain: String = "zendesk", input: TicketCreateVoicemailTicketRequest_Input): CreateTicketOrVoicemailTicket_response
  "Permanently removes one or more chat attachments from a chat ticket.\n\n**Note**: This does not work on active chats. For chat tickets that predate March 2020, consider using [Redact Ticket Comment In Agent Workspace](#redact-ticket-comment-in-agent-workspace).\n\n#### Allowed For\n\n- Agents\n\n[Agent Workspace](https://support.zendesk.com/hc/en-us/articles/360024218473) must enabled for the account. Deleting tickets must be enabled for agents.\n\n#### Request Body Properties\n\n| Name         | Type    | Required | Description                                                                                                                                          |\n| ------------ | ------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\n| chat_id      | string  | true     | The `chat_id` in the `ChatStartedEvent` event in the ticket audit. See [Ticket Audits](/api-reference/ticketing/tickets/ticket_audits)               |\n| chat_indexes | array   | true     | The array of `chat_index` in the `ChatFileAttachment` event in the ticket audit. See [Ticket Audits](/api-reference/ticketing/tickets/ticket_audits) |\n\nTo get the required body properties, make a request to the [Ticket Audits](/api-reference/ticketing/tickets/ticket_audits) endpoint. Example response:\n\n```http\nStatus 200 OK\n{\n  \"audits\": [\n    \"events\": [\n      {\n        \"id\": 1932802680168,\n        \"type\": \"ChatStartedEvent\",\n        \"value\": {\n          \"visitor_id\": \"10502823-16EkM3T6VNq7KMd\",\n          \"chat_id\": \"2109.10502823.Sjuj2YrBpXwei\",\n          \"history\": [\n            {\n              \"chat_index\": 0,\n              \"type\": \"ChatFileAttachment\",\n              \"filename\": \"image1.jpg\"\n            },\n            {\n              \"chat_index\": 1,\n              \"type\": \"ChatFileAttachment\",\n              \"filename\": \"image2.jpg\"\n            }\n          ]\n        }\n      }\n    ]\n  ]\n}\n```\n"
  RedactChatCommentAttachment(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): TicketChatCommentRedactionResponse
  "Permanently removes words or strings from a chat ticket's comment. \n\nWrap `<redact>` tags around the content in the chat comment you want redacted. Example: \n\n```json\n{\n  \"text\": \"My ID number is <redact>847564</redact>!\"\n}\n```\n\nThe characters contained in the tag will be replaced by the â–‡ symbol.\n\n**Note**: This does not work on active chats. For chat tickets that predate March 2020, consider using [Redact Ticket Comment In Agent Workspace](#redact-ticket-comment-in-agent-workspace).\n\n#### Allowed For\n\n- Agents\n\n[Agent Workspace](https://support.zendesk.com/hc/en-us/articles/360024218473) must enabled for the account. Deleting tickets must be enabled for agents.\n\n#### Request Body Properties\n\n| Name                     | Type    | Required | Description                                                                                                                                                             |\n| ------------------------ | ------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| chat_id                  | string  | true     | The `chat_id` in the `ChatStartedEvent` event in the ticket audit. See [Ticket Audits](/api-reference/ticketing/tickets/ticket_audits)                                  |\n| chat_index               | integer | true     | The `chat_index` in the `ChatMessage` event in the ticket audit. See [Ticket Audits](/api-reference/ticketing/tickets/ticket_audits)                                    |\n| text                     | string  | true     | The `message` in the `ChatMessage` event in the ticket audit. See [Ticket Audits](/api-reference/ticketing/tickets/ticket_audits).  Wrap `message` with `<redact>` tags |\n\nTo get the required body properties, make a request to the [Ticket Audit](/api-reference/ticketing/tickets/ticket_audits) endpoint. Example response:\n\n```http\nStatus 200 OK\n{\n  \"audits\": [\n    \"events\": [\n      {\n        \"id\": 1932802680168,\n        \"type\": \"ChatStartedEvent\",\n        \"value\": {\n          \"visitor_id\": \"10502823-16EkM3T6VNq7KMd\",\n          \"chat_id\": \"2109.10502823.Sjuj2YrBpXwei\",\n          \"history\": [\n            {\n              \"chat_index\": 0,\n              \"type\": \"ChatMessage\",\n              \"message\": \"My ID number is 847564!\"\n            }\n          ]\n        }\n      }\n    ]\n  ]\n}\n```\n"
  RedactChatComment(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): TicketChatCommentRedactionResponse
  "Redaction allows you to permanently remove words, strings, or attachments from a ticket comment.\n\nIn the `html_body` of the comment, wrap the content you want redacted in `<redact>` tags. Example:\n\n```json\n{\n  \"html_body\": \"<div class=\\\"zd-comment\\\" dir=\\\"auto\\\">My ID number is <redact>847564</redact>!</div>\",\n  \"ticket_id\":100\n}\n```\n\nThe characters in the redact tag will be replaced by the â–‡ symbol.\n\nTo redact HTML elements such inline images, anchor tags, and links, add the `redact` tag attribute to the element as well as the `<redact>` tag to inner text, if any. Example: \n\n`<a href=\"http://example.com\" redact><redact>some link</redact></a>`\n\nThe `redact` attribute only redacts the tag. Any inner text will be left behind if not enclosed in a `<redact>` tag.\n\nRedaction is permanent and can not be undone. Data is permanently deleted from Zendesk servers with no way to recover it.\n\nThis endpoint provides all the same functionality that the [Redact String in Comment](/api-reference/ticketing/tickets/ticket_comments/#redact-string-in-comment) endpoint provides, plus:\n\n- Redaction of comments in closed tickets\n\n- Redaction of comments in archived tickets\n\n- Redaction of formatted text (bold, italics, hyperlinks)\n\n**Limitations**: When content is redacted from an email comment, the content is also redacted from the original email through a background job. It may take a while for the changes to be completed.\n\n**Note**: We recommend using this endpoint instead of the [Redact String in Comment](/api-reference/ticketing/tickets/ticket_comments/#redact-string-in-comment) endpoint, which will eventually be deprecated.\n\n#### Allowed For\n\n- Agents\n\n[Agent Workspace](https://support.zendesk.com/hc/en-us/articles/360024218473) must be enabled on the account. For professional accounts, deleting tickets must be enabled for agents. On Enterprise accounts, you can assign agents to a custom role with permissions to redact ticket content.\n\n#### Request Body Properties\n\n| Name                     | Type    | Required | Description                                                                                                                                      |\n| -------------------------| ------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ticket_id                | integer | true     | The ID of the ticket                                                                                                                             |\n| html_body                | string  | false    | The `html_body` of the comment containing `<redact>` tags or `redact` attributes                                           |\n| external_attachment_urls | array   | false    | Array of attachment URLs belonging to the comment to be redacted. See [`content_url` property of Attachment](/api-reference/ticketing/tickets/ticket-attachments/) |\n"
  RedactTicketCommentInAgentWorkspace(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket comment"
    ticket_comment_id: Int!
  ): TicketCommentResponse
  "Creates an object describing all the properties required to create a custom object record\n#### Allowed For\n* Admins\n"
  CreateCustomObject(subdomain: String = "example", domain: String = "zendesk", input: CustomObjectsCreateRequest_Input): CustomObjectResponse
  "Updates an individual custom object. The updating rules are as follows:\n* Takes a `custom_object` object that specifies the properties to update\n* The `key` property cannot be updated\n#### Allowed For\n* Admins"
  UpdateCustomObject(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
  ): CustomObjectResponse
  "Permanently deletes the custom object with the specified key\n#### Allowed For\n* Admins"
  DeleteCustomObject(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
  ): Boolean
  "Creates any of the following custom field types:\n\n* text (default when no \"type\" is specified)\n* textarea\n* checkbox\n* date\n* integer\n* decimal\n* regexp\n* dropdown\n* lookup\n\nSee [About custom field types](https://support.zendesk.com/hc/en-us/articles/203661866) in Zendesk help.\n\n#### Allowed For\n\n* Admins\n"
  CreateCustomObjectField(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
    input: CustomObjectFieldsCreateRequest_Input
  ): CustomObjectFieldResponse
  "Updates individual custom object fields. The updating rules are as follows:\n* Takes a `custom_object_field` object that specifies the properties to update\n* The `key` property cannot be updated\n* If updating a standard field, only the `title` and `description` properties can be updated.\n#### Allowed For\n* Admins"
  UpdateCustomObjectField(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
    "The key or id of a custom object field"
    custom_object_field_key_or_id: String!
  ): CustomObjectFieldResponse
  "Deletes a field with the specified key. Note: You can't delete standard fields.\n#### Allowed For\n* Admins"
  DeleteCustomObjectField(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
    "The key or id of a custom object field"
    custom_object_field_key_or_id: String!
  ): Boolean
  "Sets a preferred order of custom fields for a specific object by providing field ids in the desired order.\n#### Allowed For\n\n* Admins\n"
  ReorderCustomObjectFields(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
  ): String
  "Queues a background job to perform bulk actions on up to 100 custom object records per single request.\nTakes a `job` object with two nested fields:\n* `action`, one of:\n    * `\"create\"`\n    * `\"delete\"`\n    * `\"delete_by_external_id\"`\n    * `\"create_or_update_by_external_id\"`\n    * `\"update\"`\n* `items`\n    * For a `\"create\"` action, an array of JSON objects representing the custom object records being created\n    * For a `\"delete\"` action, an array of strings representing Zendesk record ids\n    * For a `\"delete_by_external_id\"` action, an array of strings representing external ids\n    * For a `\"create_or_update_by_external_id\"` action, an array of JSON objects representing the custom object records being created or updated\n    * For an `\"update\"` action, an array of JSON objects representing the custom object records being updated\n\n#### Allowed For\n* Agents\n\n#### Response ###\nThis endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work. Use the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion. Only a certain number of jobs can be queued or running at the same time. See [Job limit](/api-reference/introduction/rate-limits/#job-limit) for more information.\n"
  CustomObjectRecordBulkJobs(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
    input: CustomObjectRecordsBulkCreateRequest_Input
  ): CustomObjectRecordsJobsResponse
  "Creates a custom object record according to all the properties described by a custom object definition\n#### Allowed For\n* Agents\n"
  CreateCustomObjectRecord(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
    input: CustomObjectRecordsCreateRequest_Input
  ): CustomObjectRecordResponse
  "If a record exists for the given external id, updates it. Only the specified attributes are updated. Otherwise, creates a new record with the provided external id and attributes.\n#### Allowed For\n* Agents\n"
  UpsertCustomObjectRecord(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
    "The external id of a custom object record"
    external_id: String!
    input: CustomObjectRecordsUpsertRequest_Input
  ): CustomObjectRecordResponse
  "Deletes a record with the specified external id.\n#### Allowed For\n* Agents\n"
  DeleteCustomObjectRecordByExternalId(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
    "The external id of a custom object record"
    external_id: String!
  ): Boolean
  "Updates an individual custom object record. The updating rules are as follows:\n* Takes a `custom_object_record` object that specifies the properties to update\n* The custom object fields should be nested inside a `custom_object_fields` object\n#### Allowed For\n* Agents"
  UpdateCustomObjectRecord(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
    "The id of a custom object record"
    custom_object_record_id: String!
  ): CustomObjectRecordResponse
  "Deletes a record with the specified id\n#### Allowed For\n* Agents"
  DeleteCustomObjectRecord(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The key of a custom object"
    custom_object_key: String!
    "The id of a custom object record"
    custom_object_record_id: String!
  ): Boolean
  "#### Availability\n\n* Accounts on the Enterprise plan or above\n\n#### Allowed for\n\n* Administrators\n* Agents with the `manage_roles` permission\n"
  CreateCustomRole(subdomain: String = "example", domain: String = "zendesk"): CustomRoleResponse
  "#### Availability\n\n* Accounts on the Enterprise plan or above\n\n#### Allowed for\n\n* Administrators\nAgents with the `manage_roles` permission\n"
  UpdateCustomRoleById(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the custom agent role"
    custom_role_id: Int!
  ): CustomRoleResponse
  "#### Availability\n\n* Accounts on the Enterprise plan or above\n\n#### Allowed for\n\n* Administrators\n* Agents with the `manage_roles` permission\n"
  DeleteCustomRoleById(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the custom agent role"
    custom_role_id: Int!
  ): Boolean
  "Updates the default values for many custom ticket statuses at once.\n\n#### Allowed For\n\n* Admins\n"
  BulkUpdateDefaultCustomStatus(subdomain: String = "example", domain: String = "zendesk", input: BulkUpdateDefaultCustomStatusRequest_Input): AWSJSON
  "Takes a `custom_status` object that specifies the custom ticket status properties to create.\n\n#### Allowed For\n\n* Admins\n"
  CreateCustomStatus(subdomain: String = "example", domain: String = "zendesk", input: CustomStatusCreateRequest_Input): CustomStatusResponse
  "Takes a `custom_status` object that specifies the properties to update.\n\n#### Allowed For\n\n* Admins\n"
  UpdateCustomStatus(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the custom status"
    custom_status_id: Int!
    input: CustomStatusUpdateRequest_Input
  ): CustomStatusResponse
  "Permanently deletes a soft-deleted ticket. See [Soft delete](https://support.zendesk.com/hc/en-us/articles/4408834005530#topic_zrm_wbj_1db)\nin the Zendesk GDPR docs. To soft delete a ticket, use the [Delete Ticket](#delete-ticket) endpoint.\n\nThis endpoint enqueues a ticket deletion job and returns a payload with the jobs status.\n\nIf the job succeeds, the ticket is permanently deleted. This operation can't be undone.\n\nThis endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work.\nUse the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion.\n\n#### Allowed For\n\n* Agents"
  DeleteTicketPermanently(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): JobStatusResponse
  "#### Allowed For\n\n* Agents"
  RestoreDeletedTicket(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): String
  "Permanently deletes up to 100 soft-deleted tickets. See [Soft delete](https://support.zendesk.com/hc/en-us/articles/4408834005530#topic_zrm_wbj_1db)\nin the Zendesk GDPR docs. To soft delete tickets, use the [Bulk Delete Tickets](#bulk-delete-tickets) endpoint.\n\nThis endpoint accepts a comma-separated list of up to 100 ticket ids. It enqueues\na ticket deletion job and returns a payload with the jobs status.\n\nIf one ticket fails to be deleted, the endpoint still attempts to delete the others. If the job succeeds,\nthe tickets that were successfully deleted are permanently deleted. This operation can't be undone.\n\nThis endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work. Use the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion. Only a certain number of jobs can be queued or running at the same time. See [Job limit](/api-reference/introduction/rate-limits/#job-limit) for more information.\n\n#### Allowed For\n\n* Agents"
  BulkPermanentlyDeleteTickets(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Comma-separated list of ticket ids"
    ids: String!
  ): JobStatusResponse
  "#### Allowed For\n\n* Agents"
  BulkRestoreDeletedTickets(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Comma-separated list of ticket ids"
    ids: String!
  ): String
  "Before permanently deleting a user, you must delete the user first. See [Delete User](/api-reference/ticketing/users/users/#delete-user).\n\nWARNING: Permanently deleting a user deletes all of their information. This information is not recoverable.\n\n#### Permanent user deletion rate limit\n\nYou can permanently delete 700 users every 10 minutes.\nThe rate limiting mechanism behaves as described in\n[Rates Limits](/api-reference/introduction/rate-limits/#monitoring-your-request-activity) in the API introduction.\nZendesk recommends that you obey the Retry-After header values.\n\n#### Allowed For\n\n* Admins and [agents in custom roles with permission](https://support.zendesk.com/hc/en-us/articles/4408882153882#topic_cxn_hig_bd) to manage end users or team members\n"
  PermanentlyDeleteUser(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the deleted user"
    deleted_user_id: Int!
  ): DeletedUserResponse
  "Create a new content item, with one or more variants in the item's `variants` array. See [Specifying item variants](#specifying-item-variants).\n\nThe `default_locale_id` and variant `locale_id` values must be one of the locales the account has active. You can get the list with the [List Locales](/api-reference/ticketing/account-configuration/locales/#list-locales) endpoint.\n\n#### Allowed For\n\n* Admins, Agents\n"
  CreateDynamicContent(subdomain: String = "example", domain: String = "zendesk"): DynamicContentResponse
  "The only attribute you can change is the name.\n\nTo add a variant to the item, or to update or delete the variants of the item, use the [Item Variants API](/api-reference/ticketing/ticket-management/dynamic_content_item_variants/#update-many-variants).\n\n#### Allowed For\n\n* Admins, Agents\n"
  UpdateDynamicContentItem(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the dynamic content item"
    dynamic_content_item_id: Int!
  ): DynamicContentResponse
  "#### Allowed For\n\n* Admins, Agents\n"
  DeleteDynamicContentItem(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the dynamic content item"
    dynamic_content_item_id: Int!
  ): Boolean
  "You can only create one variant for each locale id. If a locale variant already exists, the request is rejected.\n\n#### Allowed For\n\n* Admins, Agents\n"
  CreateDynamicContentVariant(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the dynamic content item"
    dynamic_content_item_id: Int!
  ): DynamicContentVariantResponse
  "Updates the specified variant. You don't need to include all the properties. If you just want to update content, for example, then include just that.\n\nYou can't switch the active state of the default variant of an item. Similarly, you can't switch the default to false if the variant is the default. You must make another variant default instead.\n\n#### Allowed For\n\n* Admins, Agents\n"
  UpdateDynamicContentVariant(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the dynamic content item"
    dynamic_content_item_id: Int!
    "The ID of the variant"
    dynammic_content_variant_id: Int!
  ): DynamicContentVariantResponse
  "#### Allowed For\n\n* Admins, Agents\n"
  DeleteDynamicContentVariant(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the dynamic content item"
    dynamic_content_item_id: Int!
    "The ID of the variant"
    dynammic_content_variant_id: Int!
  ): Boolean
  "#### Allowed For\n\n* Admins, Agents\n"
  CreateManyDynamicContentVariants(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the dynamic content item"
    dynamic_content_item_id: Int!
  ): DynamicContentVariantsResponse
  "Updates one or more variants. See [Update Variant](/api-reference/ticketing/ticket-management/dynamic_content_item_variants/#update-variant).\n\nYou must specify the variants by id in the body. To get the variant ids, see [List Variants](/api-reference/ticketing/ticket-management/dynamic_content_item_variants/#list-variants).\n\n#### Allowed For\n\n* Admins, Agents\n"
  UpdateManyDynamicContentVariants(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the dynamic content item"
    dynamic_content_item_id: Int!
  ): DynamicContentVariantsResponse
  "Assigns an agent to a given group.\n\n#### Allowed For\n\n* Admins\n* Agents assigned to a custom role with permissions to manage group memberships (Enterprise only)\n"
  CreateGroupMembership(subdomain: String = "example", domain: String = "zendesk"): GroupMembershipResponse
  "Immediately removes a user from a group and schedules a job to unassign all working tickets that are assigned to the given user and group combination.\n\n#### Allowed For\n\n* Admins\n* Agents assigned to a custom role with permissions to manage group memberships (Enterprise only)\n"
  DeleteGroupMembership(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the group membership"
    group_membership_id: Int!
  ): Boolean
  "Assigns up to 100 agents to given groups.\n\n#### Allowed For\n\n* Admins\n* Agents assigned to a custom role with permissions to manage group memberships (Enterprise only)\n\n#### Response\n\nThis endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work. Use the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion.\n"
  GroupMembershipBulkCreate(subdomain: String = "example", domain: String = "zendesk"): JobStatusResponse
  "Immediately removes users from groups and schedules a job to unassign all working tickets that are assigned to the given user and group combinations.\n\n#### Allowed For\n\n* Admins\n* Agents assigned to a custom role with permissions to manage group memberships (Enterprise only)\n"
  GroupMembershipBulkDelete(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Id of the group memberships to delete. Comma separated"
    ids: String
  ): JobStatusResponse
  "#### Allowed For\n\n* Admins\n"
  CreateGroupSLAPolicy(subdomain: String = "example", domain: String = "zendesk"): GroupSLAPolicyResponse
  "Updates the specified policy.\n\n#### Allowed For\n\n* Admins\n"
  UpdateGroupSLAPolicy(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the Group SLA policy"
    group_sla_policy_id: Int!
  ): GroupSLAPolicyResponse
  "#### Allowed For\n\n* Admins\n"
  DeleteGroupSLAPolicy(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the Group SLA policy"
    group_sla_policy_id: Int!
  ): Boolean
  "#### Allowed For\n\n* Admins\n"
  ReorderGroupSLAPolicies(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ids of the Group SLA policies to reorder"
    group_sla_policy_ids: [String]
  ): String
  "#### Allowed For\n\n* Admins\n* Agents assigned to a custom role with permissions to manage groups (Enterprise only)\n"
  CreateGroup(subdomain: String = "example", domain: String = "zendesk"): GroupResponse
  "#### Allowed For\n\n* Admins\n"
  UpdateGroup(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the group"
    group_id: Int!
  ): GroupResponse
  "#### Allowed For\n\n* Admins\n* Agents assigned to a custom role with permissions to manage groups (Enterprise only)\n"
  DeleteGroup(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the group"
    group_id: Int!
  ): Boolean
  "#### Allowed For\n\n* Admins"
  TicketImport(
    subdomain: String = "example"
    domain: String = "zendesk"
    "If `true`, any ticket created with a `closed` status bypasses the normal ticket lifecycle and will be created directly in your ticket archive"
    archive_immediately: Boolean
    input: TicketImportRequest_Input
  ): TicketResponse
  "Accepts an array of up to 100 ticket objects.\n\n#### Allowed For\n\n* Admins"
  TicketBulkImport(
    subdomain: String = "example"
    domain: String = "zendesk"
    "If `true`, any ticket created with a `closed` status bypasses the normal ticket lifecycle and will be created directly in your ticket archive"
    archive_immediately: Boolean
    input: TicketBulkImportRequest_Input
  ): JobStatusResponse
  "#### Allowed For\n* Agents\n"
  CreateMacro(subdomain: String = "example", domain: String = "zendesk", input: CreateMacro_request_Input): CreateMacro_200_response
  "#### Allowed For\n* Agents\n"
  UpdateMacro(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the macro"
    macro_id: Int!
    input: UpdateMacro_request_Input
  ): UpdateMacro_200_response
  "#### Allowed For\n* Agents, with restrictions applying on certain actions\n"
  DeleteMacro(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the macro"
    macro_id: Int!
  ): Boolean
  "Allows an attachment to be uploaded and associated with a macro at the same time.\n\n**Note:** A macro can be associated with up to five attachments.\n\n#### Allowed For\n\n* Agents\n"
  CreateAssociatedMacroAttachment(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the macro"
    macro_id: Int!
  ): MacroAttachmentResponse
  "Allows an attachment to be uploaded that can be associated with a macro at a later time.\n\n**Note:** To ensure an uploaded attachment is not lost, associate it with a macro as soon as possible. From time to time, old attachments that are not not associated with any macro are purged.\n\n#### Allowed For\n\n* Agents\n"
  CreateMacroAttachment(subdomain: String = "example", domain: String = "zendesk"): MacroAttachmentResponse
  "Deletes the macros corresponding to the provided comma-separated list of IDs.\n\n#### Allowed For\n* Agents\n"
  DeleteManyMacros(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The IDs of the macros to delete"
    ids: [Int]!
  ): Boolean
  "Updates the provided macros with the specified changes.\n\n#### Allowed For\n* Agents\n"
  UpdateManyMacros(subdomain: String = "example", domain: String = "zendesk", input: MacroUpdateManyInput_Input): MacrosResponse
  "Updates the essentials card for an object type.\n#### Allowed For\n* Admins\n"
  UpdateEssentialsCard(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Essentials card type. Example: `zen:user` refers user type"
    object_type: String!
  ): EssentialsCardResponse
  "Delete the essentials card for an object type.\n#### Allowed For\n* Admins and agents\n"
  DeleteEssentialsCard(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Essentials card type. Example: `zen:user` refers user type"
    object_type: String!
  ): Boolean
  "Creates any of the following custom field types:\n\n* text (default when no \"type\" is specified)\n* textarea\n* checkbox\n* date\n* integer\n* decimal\n* regexp\n* dropdown\n* lookup\n\nSee [About custom field types](https://support.zendesk.com/hc/en-us/articles/203661866) in Zendesk help.\n\n#### Allowed For\n\n* Admins\n"
  CreateOrganizationField(subdomain: String = "example", domain: String = "zendesk"): OrganizationFieldResponse
  "#### Updating a Drop-down (Tagger) Field\n\nDrop-down fields return an array of `custom_field_options` which specify the name, value, and order of drop-down options. When updating a drop-down field, note the following information:\n\n- All options must be passed on update. Options that are not passed will be removed. As a result, these values will be removed from any organizations\n- To create a new option, pass a null `id` along with the `name` and `value`\n- To update an existing option, pass its `id` along with the `name` and `value`\n- To reorder an option, reposition it in the `custom_field_options` array relative to the other options\n- To remove an option, omit it from the list of options upon update\n\n#### Example Request\n\n```bash\ncurl https://{subdomain}.zendesk.com/api/v2/organization_fields/{organization_field_id}.json \\\n  -H \"Content-Type: application/json\" -X PUT \\\n  -d '{\"organization_field\": {\"custom_field_options\": [{\"id\": 124, \"name\": \"Option 2\", \"value\": \"option_2\"}, {\"id\": 123, \"name\": \"Option 1\", \"value\": \"option_1\"}, {\"id\": 125, \"name\": \"Option 3\", \"value\": \"option_3\"}]}}' \\\n  -v -u {email_address}:{password}\n```\n#### Allowed for\n\n* Admins\n"
  UpdateOrganizationField(subdomain: String = "example", domain: String = "zendesk", organization_field_id: OrganizationFieldId_parameter_Input!): OrganizationFieldResponse
  "#### Allowed for\n\n* Admins\n"
  DeleteOrganizationField(subdomain: String = "example", domain: String = "zendesk", organization_field_id: OrganizationFieldId_parameter_Input!): Boolean
  "#### Allowed For\n\n* Admins\n"
  ReorderOrganizationField(subdomain: String = "example", domain: String = "zendesk"): String
  "Assigns a user to a given organization. Returns an error with status 422 if the user is already assigned to the organization.\n\n#### Allowed For\n\n* Admins\n* Agents when creating a new organization membership for an end user\n"
  CreateOrganizationMembership(subdomain: String = "example", domain: String = "zendesk"): OrganizationMembershipResponse
  "Immediately removes a user from an organization and schedules a job to unassign all working tickets currently assigned to the user and organization combination. The `organization_id` of the unassigned tickets is set to null.\n\n#### Allowed for\n\n* Admins\n* Agents when deleting an organization membership for an end user\n"
  DeleteOrganizationMembership(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the organization membership"
    organization_membership_id: Int!
  ): Boolean
  "This endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work. Use the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion. Only a certain number of jobs can be queued or running at the same time. See [Job limit](/api-reference/introduction/rate-limits/#job-limit) for more information.\n\n#### Allowed For\n* Admins\n* Agents\n"
  CreateManyOrganizationMemberships(subdomain: String = "example", domain: String = "zendesk"): JobStatusResponse
  "Immediately removes a user from an organization and schedules a job to unassign all working tickets currently assigned to the user and organization combination. The `organization_id` of the unassigned tickets is set to null.\n\n#### Response\n\nThis endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work. Use the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion. Only a certain number of jobs can be queued or running at the same time. See [Job limit](/api-reference/introduction/rate-limits/#job-limit) for more information.\n\n#### Allowed For\n\n* Agents\n"
  DeleteManyOrganizationMemberships(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The IDs of the organization memberships to delete"
    ids: [Int]
  ): JobStatusResponse
  "#### Allowed For:\n\n* Agents\n* End users\n\nEnd users can only subscribe to shared organizations in which they're members."
  CreateOrganizationSubscription(subdomain: String = "example", domain: String = "zendesk", input: OrganizationSubscriptionCreateRequest_Input): OrganizationSubscriptionResponse
  "#### Allowed For:\n\n* Agents\n* End users"
  DeleteOrganizationSubscription(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the organization subscription"
    organization_subscription_id: Int!
  ): Boolean
  "You must provide a unique `name` for each organization. Normally\nthe system doesn't allow records to be created with identical names.\nHowever, a race condition can occur if you make two or more identical\nPOSTs very close to each other, causing the records to have identical\norganization names.\n\n#### Allowed For\n\n* Admins\n* Agents assigned to a custom role with permissions to manage organizations (Enterprise only)\n"
  CreateOrganization(subdomain: String = "example", domain: String = "zendesk", input: CreateOrganizationRequest_Input): OrganizationResponse
  "#### Allowed For\n\n* Admins\n* Agents\n\nAgents with no permissions restrictions can only update \"notes\" on organizations.\n\n**Note:** Updating an organization's `domain_names` property overwrites all existing `domain_names` values. To prevent this, submit a complete list of `domain_names` for the organization in your request.\n\n#### Example Request\n\n```js\n{\n  \"organization\": {\n    \"notes\": \"Something interesting\"\n  }\n}\n```\n"
  UpdateOrganization(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of an organization"
    organization_id: Int!
  ): UpdateOrganization_response
  "#### Allowed For\n\n* Admins\n* Agents assigned to a custom role with permissions to manage organizations (Enterprise only)\n"
  DeleteOrganization(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of an organization"
    organization_id: Int!
  ): Boolean
  "Merges two organizations by moving all users, tickets, and domain names from the organization specified by `{organization_id}` to the organization specified by `winner_id`. After the merge:\n\n- The \"losing\" organization will be deleted.\n- Other organization fields and their values will not be carried over to the \"winning\" organization.\n- The merge operation creates an `Organization Merge` record which contains a status indicating the progress of the merge.\n\n**Note**: This operation is irreversible.\n\n#### Merge Statuses\n\n| Status | Description |\n|--------|-------------|\n| new | A job has been queued to merge the two organizations. |\n| in progress | The job to merge the two organizations has started. |\n| error | An error occurred during the merge job. The merge can be retried by repeating the API call. | \n| complete | The merge has been completed successfully. |\n\n#### Allowed For\n\n* Admins\n"
  CreateOrganizationMerge(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of an organization"
    organization_id: Int!
    input: OrganizationMergeRequest_Input
  ): OrganizationMergeResponse
  "Accepts an array of up to 100 organization objects.\n\n#### Response\n\nThis endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work. Use the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion. Only a certain number of jobs can be queued or running at the same time. See [Job limit](/api-reference/introduction/rate-limits/#job-limit) for more information.\n\n#### Allowed For\n\n* Agents, with restrictions applying on certain actions\n"
  CreateManyOrganizations(subdomain: String = "example", domain: String = "zendesk"): JobStatusResponse
  "Creates an organization if it doesn't already exist, or updates\nan existing organization. Using this method means one less call\nto check if an organization exists before creating it. You need\nto specify the id or external id when updating\nan organization to avoid a duplicate error response. Name is\nnot available as a matching criteria.\n\n#### Allowed For\n\n* Agents, with restrictions on certain actions\n"
  CreateOrUpdateOrganization(subdomain: String = "example", domain: String = "zendesk"): OrganizationResponse
  "Accepts a comma-separated list of up to 100 organization ids or external ids.\n\n#### Response\n\nThis endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work. Use the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion. Only a certain number of jobs can be queued or running at the same time. See [Job limit](/api-reference/introduction/rate-limits/#job-limit) for more information.\n\n#### Allowed For\n\n* Admins\n* Agents assigned to a custom role with permissions to manage organizations (Enterprise only)\n"
  DeleteManyOrganizations(
    subdomain: String = "example"
    domain: String = "zendesk"
    "A list of organization ids"
    ids: String
    "A list of external ids"
    external_ids: String
  ): JobStatusResponse
  "Bulk or batch updates up to 100 organizations.\n\n#### Bulk update\n\nTo make the same change to multiple organizations, use the following endpoint and data format:\n\n`https://{subdomain}.zendesk.com/api/v2/organizations/update_many.json?ids=1,2,3`\n\n```js\n{\n  \"organization\": {\n    \"notes\": \"Priority\"\n  }\n}\n```\n\n#### Batch update\n\nTo make different changes to multiple organizations, use the following endpoint and data format:\n\n`https://{subdomain}.zendesk.com/api/v2/organizations/update_many.json`\n\n```js\n{\n  \"organizations\": [\n    { \"id\": 1, \"notes\": \"Priority\" },\n    { \"id\": 2, \"notes\": \"Normal\" }\n  ]\n}\n```\n\n#### Response\n\nThis endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work. Use the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion. Only a certain number of jobs can be queued or running at the same time. See [Job limit](/api-reference/introduction/rate-limits/#job-limit) for more information.\n\n#### Allowed For\n\n* Admins\n* Agents\n\nAgents with no permissions restrictions can only update \"notes\" on organizations.\n"
  UpdateManyOrganizations(
    subdomain: String = "example"
    domain: String = "zendesk"
    "A list of organization ids"
    ids: String
    "A list of external ids"
    external_ids: String
  ): JobStatusResponse
  "Returns tickets whose type is \"problem\" and whose subject contains the string specified in the `text` parameter.\n\nYou can specify the `text` parameter in the request body rather than the query string. Example:\n\n`{\"text\": \"fire\"}`\n\n#### Allowed For\n\n* Agents"
  AutocompleteProblems(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The text to search for"
    text: String
    input: AutocompleteProblems_request_Input
  ): AWSJSON
  "Unregisters the mobile devices that are receiving push notifications. Specify the devices as an array of mobile device tokens.\n\n#### Allowed for\n\n* Admins"
  PushNotificationDevices(subdomain: String = "example", domain: String = "zendesk", input: PushNotificationDevicesRequest_Input): String
  "#### Allowed For\n\n* Admins\n"
  CreateQueue(subdomain: String = "example", domain: String = "zendesk"): QueueResponse
  "#### Allowed For\n\n* Admins\n"
  UpdateQueue(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the omnichannel routing queue"
    queue_id: String!
  ): QueueResponse
  "#### Allowed For\n\n* Admins\n"
  DeleteQueue(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the omnichannel routing queue"
    queue_id: String!
  ): Boolean
  "Adds a Zendesk or external support address to your account.\n\nTo add a Zendesk address, use the following syntax: `{local-part}@{accountname}.zendesk.com`.\nExample: 'sales-team@example.zendesk.com'. The [local-part](https://en.wikipedia.org/wiki/Email_address#Local-part) can be anything you like.\n\nTo add an external email address such as help@omniwearshop.com, the email must already exist and you must set up forwarding on your email server. The exact steps depend on your mail server. See [Forwarding incoming email to Zendesk Support](https://support.zendesk.com/hc/en-us/articles/203663266). After setting up forwarding, run the [Verify Support Address Forwarding](#verify-support-address-forwarding) endpoint. The address won't work in Zendesk Support until it's been verified.\n\n#### Allowed For\n\n* Admins\n* Agents with permission to manage channels and extensions. See the system permissions in [Creating custom roles and assigning agents (Enterprise)](https://support.zendesk.com/hc/en-us/articles/203662026-Creating-custom-roles-and-assigning-agents-Enterprise-#topic_cxn_hig_bd) in the Support Help Center\n"
  CreateSupportAddress(subdomain: String = "example", domain: String = "zendesk"): SupportAddressResponse
  "Updates an existing support address for your account.\n\nYou can't use this endpoint to update a support address's `email` property.\nInstead, you can create a new address using the [Create Support\nAddress](#create-support-address) endpoint.\n\n#### Allowed For\n\n* Admins\n* Agents with permission to manage channels and extensions. See the system permissions in [Creating custom roles and assigning agents (Enterprise)](https://support.zendesk.com/hc/en-us/articles/203662026-Creating-custom-roles-and-assigning-agents-Enterprise-#topic_cxn_hig_bd) in the Support Help Center\n"
  UpdateSupportAddress(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the support address"
    support_address_id: Int!
  ): SupportAddressResponse
  "Deletes a support address.\n\n#### Allowed For\n\n* Admins\n* Agents with permission to manage channels and extensions. See the system permissions in [Creating custom roles and assigning agents (Enterprise)](https://support.zendesk.com/hc/en-us/articles/203662026-Creating-custom-roles-and-assigning-agents-Enterprise-#topic_cxn_hig_bd) in the Support Help Center\n"
  DeleteRecipientAddress(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the support address"
    support_address_id: Int!
  ): Boolean
  "Sends a test email to the specified support address to verify that email forwarding for the address works. An external support address won't work in Zendesk Support until it's verified.\n\n**Note**: You don't need to verify Zendesk system support addresses.\n\nThe endpoint takes the following body: `{\"type\": \"forwarding\"}`. The value of the `type` property defaults to \"forwarding\" if none is specified, but the values \"spf\" and \"dns\" are also accepted.\n\nUse this endpoint after [adding](#create-support-address) an external support address to Zendesk Support and setting up forwarding on your email server. See [Forwarding incoming email to Zendesk Support](https://support.zendesk.com/hc/en-us/articles/203663266).\n\nThe endpoint doesn't return the results of the test. Instead, use the [Show Support Address](#show-support-address) endpoint to check that the `forwarding_status` property is \"verified\".\n\nOther verification checks can also be performed using this API. These include SPF checks and DNS checks.\n\nWhen calling the endpoint with `type` set to \"spf\", it will queries the DNS records to check that the SPF records for Zendesk are present for outbound emails.\n\nWhen calling the endpoint with `type` set to \"dns\", it runs checks on your CNAME records to make sure they are set up properly in your DNS.\n\n#### Allowed For\n\n* Admins\n* Agents with permission to manage channels and extensions. See the system permissions in [Creating custom roles and assigning agents (Enterprise)](https://support.zendesk.com/hc/en-us/articles/203662026-Creating-custom-roles-and-assigning-agents-Enterprise-#topic_cxn_hig_bd) in the Support Help Center\n"
  VerifySupportAddressForwarding(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the support address"
    support_address_id: Int!
  ): String
  "Accepts a `request` object that sets one or more properties.\n\n#### Allowed for\n\n* End users\n* Anonymous users (rate limit of 5 requests per hour for [trial accounts](/documentation/developer-tools/getting-started/getting-a-trial-or-sponsored-account-for-development/))\n\n#### Additional properties\n\nIn addition to the writable request properties in the [JSON Format table](#json-format) above, you can set the following properties when creating a request.\n\n| Name                | Type   | Mandatory | Comment\n| ----------------    | -------| --------- | -------\n| comment             | object | yes       | Describes the problem, incident, question, or task. See [Request comments](#request-comments)\n| collaborators       | array  | no        | Adds collaborators (cc's) to the request. An email notification is sent to them when the ticket is created. See [Setting collaborators](/documentation/ticketing/managing-tickets/creating-and-managing-requests#setting-collaborators)\n| requester           | object | yes*      | \\*Required for anonymous requests. Specifies the requester of the anonymous request. See [Creating anonymous requests](/documentation/ticketing/managing-tickets/creating-and-managing-requests#creating-anonymous-requests)\n\n#### Creating follow-up requests\n\nOnce a ticket is closed (as distinct from solved), it can't be reopened. However, you can create a new request that references the closed ticket. To create the follow-up request, include a `via_followup_source_id` property in the `request` object that specifies the closed ticket. The parameter only works with closed tickets. It has no effect with other tickets.\n"
  CreateRequest(subdomain: String = "example", domain: String = "zendesk"): RequestResponse
  "Updates a request with a comment or collaborators (cc's). The end user who created the request can also use it to mark the request as solved. The endpoint can't be used to update other request attributes.\n\n#### Writable properties\nThis endpoint can only update the following properties in the request.\n\n| Name                     | Type    | Required | Description                                          |\n| ------------------------ | ------- | -------- | ---------------------------------------------------- |\n| comment                  | object  | no       | Adds a comment to the request. See [Request comments](#request-comments) |\n| solved                   | boolean | no       | Marks the request as solved. Example: `{\"request\": {\"solved\": \"true\"}}`. End users can mark requests as solved only if the request's `can_be_solved_by_me` property is true. The property is true only when the ticket is assigned to an agent and the ticket type is not a problem but a question, task, or incident |\n| additional_collaborators | array   | no       | Adds collaborators to the request. An email notification is sent to them when the ticket is updated. See [Adding collaborators](/documentation/ticketing/managing-tickets/creating-and-managing-requests#adding-collaborators) |\n\n#### Allowed For\n\n* End users\n"
  UpdateRequest(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the request"
    request_id: Int!
  ): RequestResponse
  "Creates a resource collection from a provided `payload` object. The `payload` object is specified the same way as the content of a requirements.json file in a Zendesk app. See [Specifying Apps Requirements](/documentation/apps/app-developer-guide/apps_requirements/) in the Zendesk Apps framework docs.\n\nThe response includes a [job\nstatus](/api-reference/ticketing/ticket-management/job_statuses/) for creation of the specified resources.\n\n#### Allowed for\n\n* Admins\n"
  CreateResourceCollection(subdomain: String = "example", domain: String = "zendesk"): JobStatusResponse
  "Updates a resource collection using a provided `payload` object. The `payload` object  is specified the same way as the content of a requirements.json file in a Zendesk app. See [Specifying Apps Requirements](/documentation/apps/app-developer-guide/apps_requirements/) in the Zendesk Apps framework docs.\n\nThe response includes a [job\nstatus](/api-reference/ticketing/ticket-management/job_statuses/) for the resource updates.\n\n#### Allowed for\n\n* Admins\n"
  UpdateResourceCollection(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the resource collection"
    resource_collection_id: Int!
  ): JobStatusResponse
  "Deletes a specified resource collection.\n\nThe response includes a [job\nstatus](/api-reference/ticketing/ticket-management/job_statuses/) for deletion of the collection's resources.\n\n#### Allowed for\n\n* Admins\n"
  DeleteResourceCollection(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the resource collection"
    resource_collection_id: Int!
  ): JobStatusResponse
  "Adds the specified attributes if no attributes exists, or replaces all existing attributes with the specified attributes.\n\n#### Allowed For\n\n* Admins\n"
  SetAgentAttributeValues(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
  ): SkillBasedRoutingAttributeValuesResponse
  "Creates an attribute.\n\n#### Allowed For\n\n* Agents\n"
  CreateAttribute(subdomain: String = "example", domain: String = "zendesk"): SkillBasedRoutingAttributeResponse
  "Updates an attribute.\n\n#### Allowed For\n\n* Admins\n"
  UpdateAttribute(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the skill-based routing attribute"
    attribute_id: String!
  ): SkillBasedRoutingAttributeResponse
  "Deletes an attribute.\n\n#### Allowed For\n\n* Admins\n"
  DeleteAttribute(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the skill-based routing attribute"
    attribute_id: String!
  ): Boolean
  "Creates an attribute value.\n\n#### Allowed For\n\n* Admins\n"
  CreateAttributeValue(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the skill-based routing attribute"
    attribute_id: String!
  ): SkillBasedRoutingAttributeValueResponse
  "Updates an attribute value.\n\n#### Allowed For\n\n* Admins\n"
  UpdateAttributeValue(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the skill-based routing attribute"
    attribute_id: String!
    "The ID of the skill-based routing attribute value"
    attribute_value_id: String!
  ): SkillBasedRoutingAttributeValueResponse
  "Deletes an attribute value.\n\n#### Allowed For\n\n* Agents\n"
  DeleteAttributeValue(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the skill-based routing attribute"
    attribute_id: String!
    "The ID of the skill-based routing attribute value"
    attribute_value_id: String!
  ): Boolean
  "Adds the specified attributes if no attributes exists, or replaces all existing attributes with the specified attributes.\n\nInvalid or deleted attributes are ignored.\n\n#### Allowed For\n\n* Admins\n"
  SetTicketAttributeValues(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): SkillBasedRoutingAttributeValuesResponse
  "#### Allowed For\n\n* Admins\n"
  CreateSharingAgreement(subdomain: String = "example", domain: String = "zendesk"): SharingAgreementResponse
  "Returns an updated sharing agreement. Only `status` is allowed to be updated.\n\n#### Allowed For\n\n* Admins\n"
  UpdateSharingAgreement(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the sharing agreement"
    sharing_agreement_id: Int!
  ): SharingAgreementResponse
  "Deletes a sharing agreement.\n\n#### Allowed For\n\n* Admins\n"
  DeleteSharingAgreement(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the sharing agreement"
    sharing_agreement_id: Int!
  ): Boolean
  "Record a new ticket skip for the current user.\n\n#### Allowed For\n\n* Agents\n"
  RecordNewSkip(subdomain: String = "example", domain: String = "zendesk"): TicketSkipCreation
  "#### Availability\n\n* Accounts on the Support Professional or Suite Growth plan or above\n\n#### Allowed For\n\n* Admins\n"
  CreateSLAPolicy(subdomain: String = "example", domain: String = "zendesk"): SLAPolicyResponse
  "Updates the specified policy.\n\n#### Availability\n\n* Accounts on the Support Professional or Suite Growth plan or above\n\n#### Allowed For\n\n* Admins\n"
  UpdateSLAPolicy(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the SLA Policy"
    sla_policy_id: Int!
  ): SLAPolicyResponse
  "#### Availability\n\n* Accounts on the Support Professional or Suite Growth plan or above\n\n#### Allowed For\n\n* Admins\n"
  DeleteSLAPolicy(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the SLA Policy"
    sla_policy_id: Int!
  ): Boolean
  "#### Availability\n\n* Accounts on the Support Professional or Suite Growth plan or above\n\n#### Allowed For\n\n* Admins\n"
  ReorderSLAPolicies(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The IDs of the SLA Policies to reorder"
    sla_policy_ids: [Int]
  ): String
  "#### Allowed For\n\n* Unrestricted agents\n"
  DeleteSuspendedTicket(
    subdomain: String = "example"
    domain: String = "zendesk"
    "id of the suspended ticket"
    id: Float!
  ): Boolean
  "**Note**: During recovery, the API sets the requester to the authenticated agent who called the API, not the original requester. This prevents the ticket from being re-suspended after recovery. To preserve the original requester, use the [Recover Multiple Suspended Tickets](#recover-multiple-suspended-tickets) endpoint with the single ticket.\n\nThis endpoint does not queue an asynchronous job that can be tracked from [Job Statuses](/api-reference/ticketing/ticket-management/job_statuses/). Instead, it processes the request with a synchronous response.\n   - If all recoveries are successful, it returns a 200 with a `tickets` array in the response.\n   - If all recoveries fail, it returns a 422 with a `suspended_tickets` array in the response.\n   - If there is a mixture of successes and failures in a single call, it returns a 422 with a `suspended_tickets` array of the failures in the response.\n\n#### Allowed For\n\n* Admins and [agents in custom roles with permission](https://support.zendesk.com/hc/en-us/articles/4408882153882#topic_cxn_hig_bd) to manage suspended tickets on Enterprise plans\n* Unrestricted agents on all other plans\n"
  RecoverSuspendedTicket(
    subdomain: String = "example"
    domain: String = "zendesk"
    "id of the suspended ticket"
    id: Float!
  ): RecoverSuspendedTicket_response
  "Makes copies of any attachments on a suspended ticket and returns them as [attachment tokens](/api-reference/ticketing/tickets/ticket-attachments/). If the  ticket is manually recovered, you can include the attachment tokens on the new ticket.\n\n#### Allowed For\n\n* Admins and [agents in custom roles with permission](https://support.zendesk.com/hc/en-us/articles/4408882153882#topic_cxn_hig_bd) to manage suspended tickets on Enterprise plans\n* Unrestricted agents on all other plans\n"
  SuspendedTicketsAttachments(subdomain: String = "example", domain: String = "zendesk"): SuspendedTicketsAttachmentsResponse
  "Accepts up to 100 ids (the auto-generated id, not the ticket id.)\n\n#### Allowed For\n\n* Admins and [agents in custom roles with permission](https://support.zendesk.com/hc/en-us/articles/4408882153882#topic_cxn_hig_bd) to manage suspended tickets on Enterprise plans\n* Unrestricted agents on all other plans\n"
  DeleteSuspendedTickets(
    subdomain: String = "example"
    domain: String = "zendesk"
    "A comma separated list of ids of suspended tickets to delete."
    ids: String!
  ): Boolean
  "Exports a list of suspended tickets for the Zendesk Support instance. To export the list, the endpoint enqueues a job to create a CSV file with the data. When done, Zendesk sends the requester an email containing a link to the CSV file. In the CSV, tickets are sorted by the update timestamp in ascending order.\n\n #### Allowed For\n\n * Admins and [agents in custom roles with permission](https://support.zendesk.com/hc/en-us/articles/4408882153882#topic_cxn_hig_bd) to manage suspended tickets on Enterprise plans\n * Unrestricted agents on all other plans\n\n #### Rate limits\n\n Limited to one request per minute and up to one million records in return. The rate-limiting mechanism behaves identically to the one described in [Usage limits](/api-reference/ticketing/account-configuration/usage_limits/#monitoring-your-request-activity).\n We recommend using the `Retry-After` header value as described in [Catching errors caused by rate limiting](/documentation/ticketing/using-the-zendesk-api/best-practices-for-avoiding-rate-limiting#catch).\n"
  ExportSuspendedTickets(subdomain: String = "example", domain: String = "zendesk"): SuspendedTicketsExportResponse
  "Accepts up to 100 ids (the auto-generated id, not the ticket id.) Note that suspended tickets that fail to be recovered are still included in the response.\n\n#### Allowed For\n\n* Admins and [agents in custom roles with permission](https://support.zendesk.com/hc/en-us/articles/4408882153882#topic_cxn_hig_bd) to manage suspended tickets on Enterprise plans\n* Unrestricted agents on all other plans\n"
  RecoverSuspendedTickets(
    subdomain: String = "example"
    domain: String = "zendesk"
    "A comma separated list of ids of suspended tickets to recover."
    ids: String!
  ): RecoverSuspendedTicketsResponse
  "#### Allowed For\n\n* Admins\n"
  CreateTarget(subdomain: String = "example", domain: String = "zendesk"): TargetResponse
  "#### Allowed For\n* Admins\n"
  UpdateTarget(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the target"
    target_id: Int!
  ): TargetResponse
  "#### Allowed For\n* Admins\n"
  DeleteTarget(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the target"
    target_id: Int!
  ): Boolean
  "Creates any of the following custom field types:\n\n| Custom field type | Description                                                                                                                                                     |\n|-------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| text              | Default custom field type when `type` is not specified                                                                                                          |\n| textarea          | For multi-line text                                                                                                                                             |\n| checkbox          | To capture a boolean value. Allowed values are true or false                                                                                                    |\n| date              | Example: 2021-04-16                                                                                                                                   |\n| integer           | String composed of numbers. May contain an optional decimal point                                                                                               |\n| decimal           | For numbers containing decimals                                                                                                                                 |\n| regexp            | Matches the Regex pattern found in the custom field settings                                                                                                    |\n| partialcreditcard | A credit card number. Only the last 4 digits are retained                                                                                                                                      |\n| multiselect       | Enables users to choose multiple options from a dropdown menu                                                                                                |\n| tagger            | Single-select dropdown menu. It contains one or more tag values belonging to the field's options. Example: ( {\"id\": 21938362, \"value\": [\"hd_3000\", \"hd_5555\"]}) |\n| lookup            | A field to create a relationship (see [lookup relationships](/api-reference/ticketing/lookup_relationships/lookup_relationships/)) to another object such as a user, ticket, or organization |\n\nSee [About custom field types](https://support.zendesk.com/hc/en-us/articles/203661866) in the Zendesk Help Center.\n\n#### Allowed For\n\n* Admins\n\n#### Field limits\n\nWe recommend the following best practices for ticket fields limits. Creating more than these amounts can affect performance.\n\n* 400 ticket fields per account if your account doesn't have ticket forms\n* 400 ticket fields per ticket form if your account has ticket forms\n"
  CreateTicketField(subdomain: String = "example", domain: String = "zendesk"): TicketFieldResponse
  "#### Updating drop-down field options\n\nYou can also use the update endpoint to add, update, or remove options in a drop-down custom field. Updating field options for multi-select fields works exactly the same as drop-down field options.\n\n**Important**: Unless you want to remove some options, you must specify all existing options in any update request. Omitting an option removes it from the drop-down field, which removes its values from any tickets or macros.\n\nUse the `custom_field_options` attribute to update the options. The attribute consists of an array of option objects, with each object consisting of a `name` and `value` property. The properties correspond to the \"Title\" and \"Tag\" text boxes in the admin interface. Example request body:\n\n```json\n{\"ticket_field\": {\n    \"custom_field_options\": [\n      {\"name\": \"Apple Pie\", \"value\": \"apple\"},\n      {\"name\": \"Pecan Pie\", \"value\": \"pecan\"}\n    ]\n  }\n}\n```\n\n#### Example Request\n\n```bash\ncurl https://{subdomain}.zendesk.com/api/v2/ticket_fields/{id}.json \\\n  -d '{\"ticket_field\": {\"custom_field_options\": [{\"name\": \"Apple Pie\", \"value\": \"apple\"}, {\"name\": \"Pecan Pie\", \"value\": \"pecan\"}]}}' \\\n  -H \"Content-Type: application/json\" -X PUT \\\n  -v -u {email_address}:{password}\n```\n\n#### Example Response\n\n```http\nStatus: 200 OK\n\n{\n  \"ticket_field\": {\n    \"id\":21938362,\n    \"type\":\"tagger\",\n    \"title\":\"Pies\",\n    ...\n    \"custom_field_options\": [\n      {\n        \"id\":21029772,\n        \"name\":\"Apple Pie\",\n        \"raw_name\":\"Apple Pie\",\n        \"value\":\"apple\",\n        \"default\":false\n      },\n      ...\n    ]\n  }\n}\n```\n\n#### Allowed for\n\n* Admins\n"
  UpdateTicketField(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket field"
    ticket_field_id: Int!
    "If true, displays the `creator_user_id` and `creator_app_name` properties. If the ticket field is created\n by an app, `creator_app_name` is the name of the app and `creator_user_id` is `-1`. If the ticket field\n is not created by an app, then `creator_app_name` is null"
    creator: Boolean
  ): TicketFieldResponse
  "#### Allowed for\n\n* Admins\n"
  DeleteTicketField(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket field"
    ticket_field_id: Int!
    "If true, displays the `creator_user_id` and `creator_app_name` properties. If the ticket field is created\n by an app, `creator_app_name` is the name of the app and `creator_user_id` is `-1`. If the ticket field\n is not created by an app, then `creator_app_name` is null"
    creator: Boolean
  ): Boolean
  "Creates or updates an option for the given drop-down ticket field.\n\nTo update an option, include the id of the option in the `custom_field_option` object. Example:\n\n`{\"custom_field_option\": {\"id\": 10002, \"name\": \"Pineapples\", ... }`\n\nIf an option exists for the given ID, the option will be updated. Otherwise, a new option will be created.\n\n#### Response\n\nReturns one of the following status codes:\n\n- 200 with `Location: /api/v2/ticket_fields/{ticket_field_id}/options.json` if the ticket field option already exists in the database\n- 201 with `Location: /api/v2/ticket_fields/{ticket_field_id}/options.json` if the ticket field option is new\n\n#### Allowed For\n\n* Admins\n\n#### Rate Limit\nYou can make 100 requests every 1 minute using this endpoint.\nThe rate limiting mechanism behaves as described in\n[Monitoring your request activity](/api-reference/ticketing/account-configuration/usage_limits/#monitoring-your-request-activity) in the API introduction.\n\n#### Field Option Limits\n\n* 2000 options per ticket field\n"
  CreateOrUpdateTicketFieldOption(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket field"
    ticket_field_id: Int!
  ): CustomFieldOptionResponse
  "#### Allowed for\n* Admins\n"
  DeleteTicketFieldOption(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket field"
    ticket_field_id: Int!
    "The ID of the ticket field option"
    ticket_field_option_id: Int!
  ): Boolean
  "#### Allowed For\n\n* Admins\n"
  CreateTicketForm(subdomain: String = "example", domain: String = "zendesk"): TicketFormResponse
  "#### Allowed For\n* Admins\n"
  UpdateTicketForm(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket form"
    ticket_form_id: Int!
  ): TicketFormResponse
  "#### Allowed For\n* Admins\n"
  DeleteTicketForm(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket form"
    ticket_form_id: Int!
  ): Boolean
  "#### Allowed For\n\n* Admins\n"
  CloneTicketForm(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket form"
    ticket_form_id: Int!
  ): TicketFormResponse
  "#### Allowed For\n* Admins\n\n#### Request Parameters\n\nYou can pass in the following parameter in the payload:\n\n| Name                | Type   | Comment\n| ------------------- | ------ | --------\n| ticket_form_ids     | array  | An array of ticket form ids. Example: \"[2, 23, 46, 50]\"\n"
  ReorderTicketForms(subdomain: String = "example", domain: String = "zendesk"): TicketFormsResponse
  "Create Ticket"
  CreateTicket(subdomain: String = "example", domain: String = "zendesk", input: TicketCreateRequest_Input): TicketResponse
  "Update Ticket"
  UpdateTicket(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
    input: TicketUpdateRequest_Input
  ): TicketUpdateResponse
  "#### Allowed For\n\n* Admins\n* Agents with permission to delete tickets\n\nAgent delete permissions are set in Support. See\n[Deleting tickets](https://support.zendesk.com/hc/en-us/articles/203690936)\nin the Support Help Center.\n\n#### Ticket deletion rate limit\n\nYou can delete 400 tickets every 1 minute using this endpoint.\nThe rate limiting mechanism behaves as described in\n[Rate limits](/api-reference/introduction/rate-limits/) in the API introduction.\nZendesk recommends that you obey the Retry-After header values.\nTo delete many tickets, you may use [Bulk Delete Tickets](/api-reference/ticketing/tickets/tickets/#bulk-delete-tickets)."
  DeleteTicket(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): Boolean
  "#### Allowed for\n\n* Agents\n"
  MakeTicketCommentPrivateFromAudits(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
    "The ID of the ticket audit"
    ticket_audit_id: Int!
  ): String
  "Redaction allows you to permanently remove attachments from an existing comment on a ticket. Once removed from a comment, the attachment is replaced with an empty \"redacted.txt\" file.\n\nThe redaction is permanent. It is not possible to undo redaction or see what was removed. Once a ticket is closed, redacting its attachments is no longer possible.\n\nAlso, if you want to redact an inline attachment, you can use the `include_inline_images` parameter in the [List Comments](/api-reference/ticketing/tickets/ticket_comments/#list-comments) operation to obtain the inline attachment ID, and use it in the request URL.\n\n#### Allowed For\n\n* Admins\n* Agents when [deleting tickets is enabled for agents on professional accounts](https://support.zendesk.com/hc/en-us/articles/360002128107)\n* Agents assigned to a custom role with permissions to redact ticket content (Enterprise only)\n"
  RedactCommentAttachment(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
    "The ID of the comment"
    comment_id: Int!
    "The ID of the attachment"
    attachment_id: Int!
  ): AttachmentResponse
  "#### Allowed For\n\n* Agents\n"
  MakeTicketCommentPrivate(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
    "The ID of the ticket comment"
    ticket_comment_id: Int!
  ): String
  "Permanently removes words or strings from a ticket comment. Specify the string to redact in an object with a `text` property. Example: `'{\"text\": \"987-65-4320\"}'`. The characters of the word or string are replaced by the â–‡ symbol.\n\nIf the comment was made by email, the endpoint also attempts to redact the string from the original email retained by Zendesk for audit purposes.\n\n**Note**: If you use the rich text editor, support for redacting formatted text (bold, italics, hyperlinks) is limited.\n\nRedaction is permanent. You can't undo the redaction or see *what* was removed. Once a ticket is closed, you can no longer redact strings from its comments.\n\nTo use this endpoint, the \"Agents can delete tickets\" option must be enabled in the Zendesk Support admin interface at **Admin** > **Settings** > **Agents**.\n\n#### Allowed For\n\n* Agents\n"
  RedactStringInComment(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
    "The ID of the ticket comment"
    ticket_comment_id: Int!
  ): TicketCommentResponse
  "#### Allowed For\n\n* Agents"
  MarkTicketAsSpamAndSuspendRequester(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): String
  "Merges one or more tickets into the ticket with the specified id.\n\nSee [Merging tickets](https://support.zendesk.com/hc/en-us/articles/203690916)\nin the Support Help Center for ticket merging rules.\n\nAny attachment to the source ticket is copied to the target ticket.\n\nThis endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work. Use the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion. Only a certain number of jobs can be queued or running at the same time. See [Job limit](/api-reference/introduction/rate-limits/#job-limit) for more information.\n\n#### Allowed For\n\n* Agents\n\nAgents in the Enterprise account must have merge permissions.\nSee [Creating custom roles and assigning agents (Enterprise)](https://support.zendesk.com/hc/en-us/articles/203662026)\nin the Support Help Center.\n\n#### Available parameters\n\nThe request takes a data object with the following properties:\n\n| Name                     | Type    | Required | Comments                                                |\n| ------------------------ | ------- | -------- | ------------------------------------------------------- |\n| ids                      | array   | yes      | Ids of tickets to merge into the target ticket          |\n| target_comment           | string  | no       | Private comment to add to the target ticket. This comment is optional but strongly recommended |\n| source_comment           | string  | no       | Private comment to add to the source ticket. This comment is optional but strongly recommended |\n| target_comment_is_public | boolean | no       | Whether comments in the target ticket are public or private   |\n| source_comment_is_public | boolean | no       | Whether comments in the source tickets are public or private |\n\n`target_comment` and `source_comment` can be used to provide a reason for the merge for recordkeeping purposes. If the source ticket has attachments, they are included in `target_comment`.\n\nComments are private and can't be modified in the following cases:\n\n  * Any of the sources or target tickets are private\n  * Any of the sources or target tickets were created through X (formerly Twitter), Facebook or the Channel framework\n\nIn any other case, comments default to private but can be modified with the comment privacy parameters."
  MergeTicketsIntoTargetTicket(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
    input: TicketMergeInput_Input
  ): JobStatusResponse
  "Creates a CSAT rating for a solved ticket, or for a ticket that was previously\nsolved and then reopened.\n\nOnly the end user listed as the ticket requester can create a satisfaction rating for the ticket.\n\n#### Allowed For\n\n* End user who requested the ticket\n\nThe end user must be a verified user.\n"
  CreateTicketSatisfactionRating(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the ticket"
    ticket_id: Int!
  ): SatisfactionRatingResponse
  "#### Allowed For\n\n* Agents\n"
  SetTagsTicket(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): TagsByObjectIdResponse
  "You can also add tags to multiple tickets with the [Update Many\nTickets](/api-reference/ticketing/tickets/tickets/#update-many-tickets) endpoint.\n\n#### Safe Update\n\nIf the same ticket is updated by multiple API requests at\nthe same time, some tags could be lost because of ticket\nupdate collisions. Include `updated_stamp` and `safe_update`\nproperties in the request body to make a safe update.\n\nFor `updated_stamp`, retrieve and specify the ticket's\nlatest `updated_at` timestamp. The tag update only occurs\nif the `updated_stamp` timestamp matches the ticket's\nactual `updated_at` timestamp at the time of the request.\nIf the timestamps don't match (in other words, if the\nticket was updated since you retrieved the ticket's\nlast `updated_at` timestamp), the request returns a\n409 Conflict error.\n\n#### Example\n\n```js\n{\n  \"tags\": [\"customer\"],\n  \"updated_stamp\":\"2019-09-12T21:45:16Z\",\n  \"safe_update\":\"true\"\n}\n```\n\nFor details, see [Protecting against ticket update collisions](/api-reference/ticketing/tickets/tickets/#protecting-against-ticket-update-collisions).\n\n#### Allowed For\n\n* Agents\n"
  PutTagsTicket(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): TagsByObjectIdResponse
  "You can also delete tags from multiple tickets with the\n[Update Many Tickets](/api-reference/ticketing/tickets/tickets/#update-many-tickets) endpoint.\n\nThis endpoint supports safe updates. See [Safe Update](/api-reference/ticketing/ticket-management/tags/#safe-update).\n\n#### Allowed For\n\n* Agents\n"
  DeleteTagsTicket(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the ticket"
    ticket_id: Int!
  ): Boolean
  "Accepts an array of up to 100 ticket objects. **Note**: Every ticket created with this endpoint may be affected by your business rules, which can include sending email notifications to your end users. If you are importing historical tickets or creating more than 1000 tickets, consider using the [Ticket Bulk Import](/api-reference/ticketing/tickets/ticket_import/#ticket-bulk-import) endpoint.\n\nThis endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work. Use the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion. Only a certain number of jobs can be queued or running at the same time. See [Job limit](/api-reference/introduction/rate-limits/#job-limit) for more information.\n\n#### Allowed For\n* Agents"
  TicketsCreateMany(subdomain: String = "example", domain: String = "zendesk", input: TicketsCreateRequest_Input): JobStatusResponse
  "Accepts a comma-separated list of up to 100 ticket ids.\n\n#### Allowed For\n\n* Admins\n* Agents with permission to delete tickets\n\nAgent delete permissions are set in Support. See\n[Deleting tickets](https://support.zendesk.com/hc/en-us/articles/203690936)\nin the Support Help Center.\n\nThis endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work. Use the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion. Only a certain number of jobs can be queued or running at the same time. See [Job limit](/api-reference/introduction/rate-limits/#job-limit) for more information."
  BulkDeleteTickets(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Comma-separated list of ticket ids"
    ids: String!
  ): JobStatusResponse
  "Accepts a comma-separated list of up to 100 ticket ids.\n\nThis endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work. Use the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion. Only a certain number of jobs can be queued or running at the same time. See [Job limit](/api-reference/introduction/rate-limits/#job-limit) for more information.\n\n#### Allowed For\n\n* Agents"
  MarkManyTicketsAsSpam(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Comma-separated list of ticket ids"
    ids: String!
  ): JobStatusResponse
  "Accepts an array of up to 100 ticket objects, or a comma-separated list of up to 100 ticket ids."
  TicketsUpdateMany(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Comma-separated list of ticket ids"
    ids: String
  ): JobStatusResponse
  "Creates a trigger category."
  CreateTriggerCategory(subdomain: String = "example", domain: String = "zendesk", input: CreateTriggerCategory_request_Input): CreateTriggerCategory_response
  "Updates the trigger category with the specified ID."
  UpdateTriggerCategory(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the trigger category to update"
    trigger_category_id: String!
    input: UpdateTriggerCategory_request_Input
  ): UpdateTriggerCategory_response
  "Deletes the trigger category with the specified ID."
  DeleteTriggerCategory(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the trigger category to delete"
    trigger_category_id: String!
  ): DeleteTriggerCategory_response
  "Creates a job that performs a batch operation for the given trigger categories."
  BatchOperateTriggerCategories(subdomain: String = "example", domain: String = "zendesk", input: BatchJobRequest_Input): BatchJobResponse
  "#### Allowed For\n\n* Agents\n"
  CreateTrigger(subdomain: String = "example", domain: String = "zendesk", input: TriggerWithCategoryRequest_Input): TriggerResponse
  "#### Allowed For\n\n* Agents\n\n#### Note\n\nUpdating a condition or action updates both the conditions and actions arrays,\nclearing all existing values of both arrays. Include all your conditions\nand actions when updating any condition or action.\n"
  UpdateTrigger(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the trigger"
    trigger_id: Int!
    input: TriggerWithCategoryRequest_Input
  ): TriggerResponse
  "#### Allowed For\n\n* Agents\n"
  DeleteTrigger(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the trigger"
    trigger_id: Int!
  ): Boolean
  "Deletes the triggers corresponding to the provided comma-separated list of IDs.\n\n#### Allowed For\n\n* Agents\n\n#### Request Parameters\n\nThe DELETE request takes one parameter, an `ids` object that lists the\ntriggers to delete.\n\n| Name | Description\n| ---- | -----------\n| ids  | The IDs of the triggers to delete\n\n#### Example request\n\n```js\n{\n  \"ids\": \"25,23,27,22\"\n}\n```\n"
  DeleteManyTriggers(
    subdomain: String = "example"
    domain: String = "zendesk"
    "A comma separated list of trigger IDs"
    ids: String!
  ): Boolean
  "Alters the firing order of triggers in the account. See\n[Reordering and sorting triggers](https://support.zendesk.com/hc/en-us/articles/115015696088)\nin the Zendesk Help Center. The firing order is set in a `trigger_ids` array in the request body.\n\nYou must include every trigger id in your account to reorder the triggers. If not, the endpoint will return 404 Forbidden.\n\nReordering triggers via the API is not permitted if you have more than one trigger category. If there is more than one\ntrigger category, the endpoint will return a `LimitOneCategory` error.\n\n#### Allowed For\n\n* Agents\n"
  ReorderTriggers(subdomain: String = "example", domain: String = "zendesk"): TriggerResponse
  "Updates the position or the active status of multiple triggers. Any additional properties are ignored.\n\n#### Allowed For\n\n* Agents\n\n#### Request Parameters\n\nThe PUT request expects a `triggers` object that lists the triggers to update.\n\nEach trigger may have the following properties:\n\n| Name        | Mandatory | Description\n| --------    | --------- | -----------\n| id          | yes       | The ID of the trigger to update\n| position    | no        | The new position of the trigger\n| active      | no        | The active status of the trigger (true or false)\n| category_id | no        | The ID of the new category the trigger is to be moved to\n\n#### Example Request\n\n```js\n{\n  \"triggers\": [\n    {\"id\": 25, \"position\": 3},\n    {\"id\": 23, \"position\": 5},\n    {\"id\": 27, \"position\": 9},\n    {\"id\": 22, \"position\": 7}\n  ]\n}\n```\n"
  UpdateManyTriggers(subdomain: String = "example", domain: String = "zendesk", input: TriggerBulkUpdateRequest_Input): TriggersResponse
  "Uploads a file that can be attached to a ticket comment. It doesn't attach the file to the comment. For details and examples, see [Attaching ticket comments with the API](/documentation/ticketing/using-the-zendesk-api/adding-ticket-attachments-with-the-api).\n\nThe endpoint has a required `filename` query parameter. The parameter specifies what the file will be named when attached to the ticket comment (to give the agent more context about the file). The parameter does not specify the file on the local system to be uploaded. While the two names can be different, their file extensions must be the same. If they don't match, the agent's browser or file reader could give an error when attempting to open the attachment.\n\nThe `Content-Type` header must contain a recognized MIME type that correctly describes the type of the uploaded file. Failing to send a recognized, correct type may cause undesired behavior. For example, in-browser audio playback may be interrupted by the browser's security mechanisms for MP3s uploaded with an incorrect type.\n\nAdding multiple files to the same upload is handled by splitting requests and passing the API token received from the first request to each subsequent request. The token is valid for 3 days.\n\n**Note**: Even if [private attachments](https://support.zendesk.com/hc/en-us/articles/204265396) are enabled in the Zendesk Support instance, uploaded files are visible to any authenticated user at the `content_URL` specified in the [JSON response](#json-format) until the upload token is consumed. Once a file is associated with a ticket or post, visibility is restricted to users with access to the ticket or post with the attachment.\n\n#### Allowed For\n\n* End users\n"
  UploadFiles(subdomain: String = "example", domain: String = "zendesk"): AttachmentUploadResponse
  "#### Allowed for\n\n* End Users\n"
  DeleteUpload(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The token of the uploaded attachment"
    token: String!
  ): Boolean
  "Creates any of the following custom field types:\n\n* text (default when no \"type\" is specified)\n* textarea\n* checkbox\n* date\n* integer\n* decimal\n* regexp\n* dropdown\n* lookup\n\nSee [About custom field types](https://support.zendesk.com/hc/en-us/articles/203661866) in Zendesk help.\n\n#### Allowed For\n\n* Admins\n"
  CreateUserField(subdomain: String = "example", domain: String = "zendesk"): UserFieldResponse
  "#### Updating a Dropdown (Tagger) Field\n\nDropdown fields return an array of `custom_field_options` which specify the name, value and order of the list of dropdown options.\nUnderstand the following behavior when updating a dropdown field:\n\n- All options must be passed on update. Options that are not passed will be removed. As a result, these values will be removed from any organizations.\n- To create a new option, pass a null `id` along with `name` and `value`.\n- To update an existing option, pass its `id` along with `name` and `value`.\n- To re-order an option, reposition it in the `custom_field_options` array relative to the other options.\n- To remove an option, omit it from the list of options upon update.\n\n#### Example Request\n\n```bash\ncurl https://{subdomain}.zendesk.com/api/v2/user_fields/{user_field_id}.json \\\n  -H \"Content-Type: application/json\" -X PUT \\\n  -d '{\"user_field\": {\"custom_field_options\": [{\"id\": 124, \"name\": \"Option 2\", \"value\": \"option_2\"}, {\"id\": 123, \"name\": \"Option 1\", \"value\": \"option_1\"}, {\"id\": 125, \"name\": \"Option 2\", \"value\": \"option_3\"}]}}' \\\n  -v -u {email_address}:{password}\n```\n#### Allowed for\n\n* Admins\n"
  UpdateUserField(subdomain: String = "example", domain: String = "zendesk", user_field_id: UserFieldId_parameter_Input!): UserFieldResponse
  "#### Allowed for\n\n* Admins\n"
  DeleteUserField(subdomain: String = "example", domain: String = "zendesk", user_field_id: UserFieldId_parameter_Input!): Boolean
  "Creates a new option or updates an existing option for the given drop-down user field.\n\nTo update an option, include the id of the option in the `custom_field_option` object. Example: `{\"custom_field_option\": {\"id\": 10002, \"name\": \"Pineapples\", ... }`. If an option exists for the given ID, the option will be updated. Otherwise, a new option will be created.\n\n#### Response\n\nReturns one of the following status codes:\n\n- 200 with `Location: /api/v2/user_fields/{user_field_id}/options.json` if the user field option already exists in the database\n- 201 with `Location: /api/v2/user_fields/{user_field_id}/options.json` if the user field option is new\n\n#### Allowed For\n\n* Admins\n"
  CreateOrUpdateUserFieldOption(subdomain: String = "example", domain: String = "zendesk", user_field_id: UserFieldId_parameter_Input!): CustomFieldOptionResponse
  "#### Allowed for\n* Admins\n"
  DeleteUserFieldOption(
    subdomain: String = "example"
    domain: String = "zendesk"
    user_field_id: UserFieldId_parameter_Input!
    "The ID of the user field option"
    user_field_option_id: Int!
  ): Boolean
  "#### Allowed For\n\n* Admins\n"
  ReorderUserField(subdomain: String = "example", domain: String = "zendesk"): String
  "Create User"
  CreateUser(subdomain: String = "example", domain: String = "zendesk", input: UserRequest_Input): UserResponse
  "Update User"
  UpdateUser(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
    input: UserRequest_Input
  ): UserResponse
  "Deletes the user and associated records from the account.\n\n**Warning**:\n\n* Deleted users are not recoverable.\n* Both agents and administrators can soft delete users in the agent interface in Zendesk Support. Agents with permission can delete end users, while administrators can delete all users except the account owner.\n\nTo comply with GDPR, a further step is needed. See [Permanently Delete User](/api-reference/ticketing/users/users/#permanently-delete-user).\n\n#### Allowed For\n\n* Admins and [agents in custom roles with permission](https://support.zendesk.com/hc/en-us/articles/4408882153882#topic_cxn_hig_bd) to manage end users or team members\n"
  DeleteUser(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
  ): UserResponse
  "#### Allowed For:\n\n* Agents\n"
  GroupMembershipSetDefault(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
    "The ID of the group membership"
    group_membership_id: Int!
  ): GroupMembershipsResponse
  "Adds an identity to a user's profile. An agent can add an identity to any user profile.\n\nSupported identity types:\n\n| Type             | Example |\n| ---------------- | ------- |\n| email            | `{ \"type\" : \"email\", \"value\" : \"someone@example.com\" }` |\n| twitter          | `{ \"type\" : \"twitter\", \"value\" : \"screen_name\" }` |\n| facebook         | `{ \"type\" : \"facebook\", \"value\" : \"855769377321\" }` |\n| google           | `{ \"type\" : \"google\", \"value\" : \"example@gmail.com\" }` |\n| agent_forwarding | `{ \"type\" : \"agent_forwarding\", \"value\" : \"+1 555-123-4567\" }` |\n| phone_number     | `{ \"type\" : \"phone_number\", \"value\" : \"+1 555-123-4567\" }` |\n\nTo create an identity without sending out a verification email, include a `\"skip_verify_email\": true` property.\n\n#### Allowed For\n\n* Agents\n"
  CreateUserIdentity(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
  ): UserIdentityResponse
  "This endpoint allows you to:\n\n* Set the specified identity as verified (but you cannot unverify a verified identity)\n* Update the `value` property of the specified identity\n\nYou can't change an identity's `primary` attribute with this endpoint. You must use the [Make Identity Primary](#make-identity-primary) endpoint instead.\n\n#### Allowed For\n\n* Agents\n"
  UpdateUserIdentity(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
    "The ID of the user identity"
    user_identity_id: Int!
  ): UserIdentityResponse
  "Deletes the identity for a given user.\nIn certain cases, a phone number associated with an identity is still visible on the user profile after the identity has been deleted via API. You can remove the phone number from the user profile by updating the `phone` attribute of the user to an empty string. See [Update User via API](/api-reference/ticketing/users/users/#update-user) for details and examples.\n\n#### Allowed For\n* Agents\n"
  DeleteUserIdentity(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
    "The ID of the user identity"
    user_identity_id: Int!
  ): Boolean
  "Sets the specified identity as primary. To change other attributes, use the [Update  Identity](#update-identity) endpoint. This is a collection-level operation and the correct behavior for an API client is to subsequently reload the entire collection.\n\nThe first endpoint is the preferred option if authenticating as an agent. If authenticating as an end user, you can only use the second endpoint. In addition, an end user can only make an email identity primary if the email is verified.\n\n#### Allowed For\n\n* Agents\n* Verified end users\n"
  MakeUserIdentityPrimary(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
    "The ID of the user identity"
    user_identity_id: Int!
  ): UserIdentitiesResponse
  "Sends the user a verification email with a link to verify ownership of the email address.\n\n#### Allowed For\n\n* Agents\n"
  RequestUserVerfication(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
    "The ID of the user identity"
    user_identity_id: Int!
  ): String
  "Sets the specified identity as verified.\n\nFor security reasons, you can't use this endpoint to update the email identity of the account owner. To verify the person's identity, send a verification email. See [Verifying the account owner's email address](https://support.zendesk.com/hc/en-us/articles/4408828975130) in Zendesk help.\n\n#### Allowed For\n\n* Agents\n"
  VerifyUserIdentity(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
    "The ID of the user identity"
    user_identity_id: Int!
  ): UserIdentityResponse
  "Merges the end user specified in the path parameter into the existing end user specified in the request body.\n\nAny two end users can be merged with the exception of end users created by sharing agreements.\n\nAgents and admins cannot be merged.\n\nFor more information about how user data is merged, see [Merging a user's duplicate account](https://support.zendesk.com/hc/en-us/articles/4408887695898) in Zendesk help.\n\n#### Allowed For\n\n* Admins or agents with permission to edit end users\n"
  MergeEndUsers(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
    input: UserRequest_Input
  ): UserResponse
  "Sets the default organization membership of a given user.\n\n#### Allowed for\n\n* Admins\n* Agents when setting the default organization membership for an end user\n"
  SetOrganizationMembershipAsDefault(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
    "The ID of the organization membership"
    organization_membership_id: Int!
  ): OrganizationMembershipsResponse
  "Immediately removes a user from an organization and schedules a job to unassign all working tickets currently assigned to the user and organization combination. The `organization_id` of the unassigned tickets is set to null.\n\n#### Allowed For\n\n* Agents\n"
  UnassignOrganization(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
    "The ID of an organization"
    organization_id: Int!
  ): Boolean
  "Sets the default organization membership of a given user.\n\n#### Allowed For\n\n* Agents\n"
  SetOrganizationAsDefault(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
    "The ID of an organization"
    organization_id: Int!
  ): OrganizationMembershipResponse
  "An admin can set a user's password only if the setting is enabled in Zendesk Support under **Settings** > **Security** > **Global**. The setting is off by default. Only the account owner can access and change this setting.\n\n[API token](https://support.zendesk.com/hc/en-us/articles/4408831452954-How-can-I-authenticate-API-requests#h_01HT5BS5HV15B7R6Q3B67M4SQW) authentication is not permitted on this endpoint.\n\n#### Allowed For\n\n* Admins\n"
  SetUserPassword(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
  ): String
  "You can only change your own password. Nobody can change the password of another user because it requires knowing the user's existing password. However, an admin can set a new password for another user without knowing the existing password. See [Set a User's Password](#set-a-users-password) above.\n\n[API token](https://support.zendesk.com/hc/en-us/articles/4408831452954-How-can-I-authenticate-API-requests#h_01HT5BS5HV15B7R6Q3B67M4SQW) authentication is not permitted on this endpoint.\n\n#### Allowed For\n\n* Agents\n* End Users\n"
  ChangeOwnPassword(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
  ): String
  "Deletes all the sessions for a user.\n\n#### Allowed For\n\n* Admins, Agents, End users\n"
  BulkDeleteSessionsByUserId(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
  ): Boolean
  "#### Allowed For\n\n* Admins, Agents, End users\n"
  DeleteSession(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the user"
    user_id: Int!
    "The ID of the session"
    session_id: Int!
  ): Boolean
  "Accepts an array of up to 100 user objects.\n\n**Note**: To protect the data in your Zendesk account, bulk user imports are not enabled by default in Zendesk accounts. The account owner must contact [Zendesk Customer Support](https://support.zendesk.com/hc/en-us/articles/4408843597850) to enable the imports. A 403 Forbidden\nerror is returned if data imports are not enabled.\n\n#### Allowed For\n\n* Admins and [agents in custom roles with permission](https://support.zendesk.com/hc/en-us/articles/4408882153882#topic_cxn_hig_bd) to manage end users or team members\n\n#### Specifying an organization\n\nYou can assign a user to an existing organization by setting an\n`organization_id` property in the user object.\n\n#### Response\n\nThis endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work. Use the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion. Only a certain number of jobs can be queued or running at the same time. See [Job limit](/api-reference/introduction/rate-limits/#job-limit) for more information.\n"
  CreateManyUsers(subdomain: String = "example", domain: String = "zendesk", input: UsersRequest_Input): JobStatusResponse
  "Creates a user if the user does not already exist, or updates an existing user\nidentified by e-mail address or external ID.\n\nIf you don't specify a role parameter, the new user is assigned the role of end user.\n\nIf you need to create users without sending out a verification email, include a `\"skip_verify_email\": true` property in the body.\n\n#### External ID Case Sensitivity\n\nWhen providing an external id to identify an existing user to update, the search for the user record is not case sensitive.\n\nHowever, if an existing user is found, the system will update the user's external id to match the case of the external id used to find the user.\n\n#### Response Status Code\n\n- If the user exists in Zendesk, a successful request returns a 200 status code with \"Location: /api/v2/users/{user_id}.json\".\n- If the user does not exist in Zendesk, a successful request returns a 201 status code with \"Location: /api/v2/users/{new_user_id}.json\".\n\n#### Allowed For\n\n* Admins and [agents in custom roles with permission](https://support.zendesk.com/hc/en-us/articles/4408882153882#topic_cxn_hig_bd) to manage end users or team members\n"
  CreateOrUpdateUser(subdomain: String = "example", domain: String = "zendesk", input: UserRequest_Input): UserResponse
  "Accepts an array of up to 100 user objects. For each user, the user is created if it does not\nalready exist, or the existing user is updated.\n\n**Note**: To protect the data in your Zendesk account, bulk user imports are not enabled by default in Zendesk accounts. The account owner must contact [Zendesk Customer Support](https://support.zendesk.com/hc/en-us/articles/4408843597850) to enable the imports. A 403 Forbidden\nerror is returned if data imports are not enabled.    \n\nEach individual user object can identify an existing user by `email` or by `external_id`.\n\nThis endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work. Use the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion. Only a certain number of jobs can be queued or running at the same time. See [Job limit](/api-reference/introduction/rate-limits/#job-limit) for more information.\n\n#### Allowed For\n\n* Admins and [agents in custom roles with permission](https://support.zendesk.com/hc/en-us/articles/4408882153882#topic_cxn_hig_bd) to manage end users or team members\n"
  CreateOrUpdateManyUsers(subdomain: String = "example", domain: String = "zendesk", input: UsersRequest_Input): JobStatusResponse
  "Accepts a comma-separated list of up to 100 user ids.\n\nThe request takes an `ids` or an `external_ids` query parameter.\n\n#### Allowed for\n\n- Admins and [agents in custom roles with permission](https://support.zendesk.com/hc/en-us/articles/4408882153882#topic_cxn_hig_bd) to manage end users or team members\n\n#### Response\n\nThis endpoint returns a `job_status` [JSON object](/api-reference/ticketing/ticket-management/job_statuses/#json-format) and queues a background job to do the work. Use the [Show Job Status](/api-reference/ticketing/ticket-management/job_statuses/#show-job-status) endpoint to check for the job's completion. Only a certain number of jobs can be queued or running at the same time. See [Job limit](/api-reference/introduction/rate-limits/#job-limit) for more information.\n"
  DestroyManyUsers(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Id of the users to delete. Comma separated"
    ids: String
    "External Id of the users to delete. Comma separated"
    external_ids: String
  ): JobStatusResponse
  "Accepts a comma-separated list of up to 100 user ids.\n\n#### Allowed For:\n\n* Admins\n"
  LogoutManyUsers(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Accepts a comma-separated list of up to 100 user ids."
    ids: String
  ): String
  "Deletes the current session. In practice, this only works when using session auth for requests, such as client-side requests\nmade from a Zendesk app. When using OAuth or basic authentication, you don't have a current session so this endpoint has no effect.\n\n#### Allowed For\n\n* Admins, Agents, End users\n"
  DeleteAuthenticatedSession(subdomain: String = "example", domain: String = "zendesk"): Boolean
  "Sends the owner a reminder email to update their subscription so more agents can be created.\n\n#### Allowed For\n\n* Agents\n"
  RequestUserCreate(subdomain: String = "example", domain: String = "zendesk", input: UserRequest_Input): String
  "Update Many Users"
  UpdateManyUsers(
    subdomain: String = "example"
    domain: String = "zendesk"
    "Id of the users to update. Comma separated"
    ids: String
    "External Id of the users to update. Comma separated"
    external_ids: String
    input: UpdateManyUsers_request_Input
  ): JobStatusResponse
  "#### Allowed For\n\n* Agents\n\n#### JSON Format\n\nThe JSON format consists of one property, a `view` object that lists the values to set when the view is created.\n\n**Note**: The request must include at least one condition in the `all` array that checks one of the following fields: `status`, `type`, `group_id`, `assignee_id`, or `requester_id`.\n\n| Name        | Description\n| ----------- | -----------\n| title       | Required. The title of the view\n| all         | Required. An array of one or more conditions. A ticket must meet all of them to be included in the view. See [Conditions reference](/documentation/ticketing/reference-guides/conditions-reference)\n| any         | An array of one or more conditions. A ticket must meet any of them to be included in the view. See [Conditions reference](/documentation/ticketing/reference-guides/conditions-reference)\n| description | The description of the view\n| active      | Allowed values are true or false. Determines if the view is displayed or not\n| output      | An object that specifies the columns to display. Example: `\"output\": {\"columns\": [\"status\", \"description\", \"priority\"]}`. See [View columns](#view-columns)\n| restriction | An object that describes who can access the view. To give all agents access to the view, omit this property\n\nThe `restriction` object has the following properties.\n\n| Name | Comment\n| ---- | -------\n| type | Allowed values are \"Group\" or \"User\"\n| id   | The numeric ID of a single group or user\n| ids  | The numeric IDs of a single or more groups. Recommended for \"Group\" `type`\n\nIf `type` is \"Group\", the `ids` property is the preferred method of specifying the group id or ids.\n\n#### Example Request Body\n\n```js\n{\n  \"view\": {\n    \"title\": \"Kelly's tickets\",\n    \"raw_title\": \"{{dc.tickets_assigned_to_kelly}}\",\n    \"description\": \"Tickets that are assigned to Kelly\",\n    \"active\": true,\n    \"position\": 3,\n    \"restriction\": {\n      \"type\": \"User\",\n      \"id\": \"213977756\"\n    },\n    \"all\": [\n      {\n        \"field\": \"status\",\n        \"operator\": \"less_than\",\n        \"value\": \"solved\"\n      },\n      {\n        \"field\": \"group_id\",\n        \"operator\": \"is\",\n        \"value\": \"24000932\"\n      },\n      {\n        \"field\": \"custom_fields_360011872073\",\n        \"operator\": \"is\",\n        \"value\": \"Canada\"\n      },\n      ...\n    ],\n    \"output\": {\n      \"columns\": [\"status\", \"requester\", \"assignee\"],\n      \"group_by\": \"assignee\",\n      \"group_order\": \"desc\",\n      \"sort_by\": \"status\",\n      \"sort_order\": \"desc\"\n    }\n  }\n}\n```\n\n#### View columns\n\nThe `output` request parameter lets you specify what columns to include in the view in the agent interface. Example: `\"output\": {\"columns\": [\"status\", \"description\", \"priority\"]}`. The following table lists possible columns for views in the agent UI and the corresponding values in the `columns` array.\n\nFor custom fields, specify the id of the custom field in the `columns` array.\n\nYou can specify a total of 10 columns to a view.\n\n| View column title in UI     | Value                |\n|---------------------------- | -------------------- |\n| Assigned                    | `assigned`           |\n| Assignee                    | `assignee`           |\n| Due Date                    | `due_date`           |\n| Group                       | `group`              |\n| ID                          | `nice_id`            |\n| Updated                     | `updated`            |\n| Assignee updated            | `updated_assignee`   |\n| Requester updated           | `updated_requester`  |\n| Updater                     | `updated_by_type`    |\n| Organization                | `organization`       |\n| Priority                    | `priority`           |\n| Requested                   | `created`            |\n| Requester                   | `requester`          |\n| Requester language          | `locale_id`          |\n| Satisfaction                | `satisfaction_score` |\n| Solved                      | `solved`             |\n| Status category             | `status`             |\n| Subject                     | `description`        |\n| Submitter                   | `submitter`          |\n| Ticket form                 | `ticket_form`        |\n| Type                        | `type`               |\n| Brand                       | `brand`              |\n| Ticket status               | `custom_status_id`   |\n\n#### View sorting\n\nYou can group and sort items in the view by adding items to the `output` parameter:\n\n| Attribute                   | Description\n|-----------------------------| -----------\n| `group_by`, `sort_by`       | Sort or group the tickets by a column in the [View columns](#view-columns) table. The `subject` and `submitter` columns are not supported\n| `group_order`, `sort_order` | Either \"asc\" or \"desc\"\n"
  CreateView(subdomain: String = "example", domain: String = "zendesk"): ViewResponse
  "#### Allowed For\n\n* Agents\n\n#### JSON Format\n\n The PUT request takes one property, a `view` object that lists the values to update. All properties are optional.\n\n**Note**: Updating a condition updates the containing array, clearing the other conditions. Include all your conditions when updating any condition.\n\n| Name        | Description\n| ----------- | -----------\n| title       | The title of the view\n| all         | An array of one or more conditions. A ticket must meet all the conditions to be included in the view. The PUT request replaces all existing conditions. See [Conditions reference](/documentation/ticketing/reference-guides/conditions-reference)\n| any         | An array of one or more conditions. A ticket must meet any of them to be included in the view. At least one `all` condition must be defined with the `any` conditions. The PUT request replaces all existing `any` conditions. See [Conditions reference](/documentation/ticketing/reference-guides/conditions-reference)\n| active      | Allowed values are true or false. Determines if the view is displayed or not\n| output      | An object that specifies the columns to display. Example: `\"output\": {\"columns\": [\"status\", \"description,\" \"priority\"]}`. See [View columns](#view-columns)\n| restriction | An object that describes who can access the view. To give all agents access to the view, omit this property\n\nThe `restriction` object has the following properties.\n\n| Name | Comment\n| ---- | -------\n| type | Allowed values are \"Group\" or \"User\"\n| id   | The numeric ID of a single group or user\n| ids  | The numeric IDs of a single or more groups. Recommended for \"Group\" `type`\n\nIf `type` is \"Group\", the `ids` property is the preferred method of specifying the group id or ids.\n\nYou can also update how items are sorted and grouped. See [View sorting](#view-sorting) in Create View.\n\n#### Example Request Body\n\n```js\n{\n  \"view\": {\n    \"title\": \"Code red tickets\",\n    \"restriction\": {\n      \"type\": \"Group\",\n      \"ids\": [10052, 10057, 10062, 10002]\n    },\n    \"all\": [\n      {\n        \"field\": \"priority\",\n        \"operator\": \"is\",\n        \"value\": \"urgent\"\n      }\n    ],\n    \"output\": {\n      \"columns\": [\"status\", \"requester\", \"assignee\", \"updated\"]\n    }\n  }\n}\n```\n"
  UpdateView(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the view"
    view_id: Int!
  ): ViewResponse
  "#### Allowed For\n* Agents\n"
  DeleteView(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ID of the view"
    view_id: Int!
  ): Boolean
  "Deletes the views corresponding to the provided list of IDs.\n\n#### Allowed For\n* Agents\n"
  BulkDeleteViews(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The IDs of the views to delete"
    ids: String!
  ): Boolean
  "You can preview views by constructing the conditions in the proper format and nesting them under the `view` property. See [Conditions reference](/documentation/ticketing/reference-guides/conditions-reference/). The output can also be controlled by passing in any of the following parameters and nesting them under the `output` property.\n\n| Name            | Type    | Comment\n| --------------- | ------- | -------\n| columns         | Array   | The ticket fields to display. System fields are looked up by name, custom fields by title or id. See the [View columns](#view-columns) table\n| group_by        | String  | When present, the field by which the tickets are grouped\n| group_order     | String  | The direction the tickets are grouped. May be one of \"asc\" or \"desc\"\n| sort_order      | String  | The direction the tickets are sorted. May be one of \"asc\" or \"desc\"\n| sort_by         | String  | The ticket field used for sorting. This will either be a title or a custom field id.\n\nThis endpoint is rate limited to 5 requests per minute, per view, per agent.\n\n#### Allowed For\n\n* Agents\n"
  PreviewViews(subdomain: String = "example", domain: String = "zendesk"): ViewResponse
  "Returns the ticket count for a single preview.\n\n#### Allowed For\n\n* Agents\n"
  PreviewCount(subdomain: String = "example", domain: String = "zendesk"): ViewCountResponse
  "#### Allowed For\n\n* Agents\n\n#### Request Parameters\n\nThe PUT request expects a `views` object that lists the views to update.\n\nEach view may have the following properties:\n\n| Name     | Mandatory | Description\n| -------- | --------- | -----------\n| id       | yes       | The ID of the view to update\n| position | no        | The new position of the view\n| active   | no        | The active status of the view (true or false)\n\n#### Example Request Body\n\n```js\n{\n  \"views\": [\n    {\"id\": 25, \"position\": 3},\n    {\"id\": 23, \"position\": 5},\n    {\"id\": 27, \"position\": 9},\n    {\"id\": 22, \"position\": 7}\n  ]\n}\n```\n"
  UpdateManyViews(subdomain: String = "example", domain: String = "zendesk"): ViewsResponse
  "#### Allowed For\n\n* Admins\n"
  CreateWorkspace(subdomain: String = "example", domain: String = "zendesk", input: CreateWorkspace_request_Input): CreateWorkspace_201_response
  "#### Allowed For\n* Admins"
  UpdateWorkspace(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the workspace"
    workspace_id: Int!
    input: UpdateWorkspace_request_Input
  ): UpdateWorkspace_200_response
  "#### Allowed For\n* Admins\n"
  DeleteWorkspace(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The id of the workspace"
    workspace_id: Int!
  ): Boolean
  "#### Allowed For\n* Admins\n"
  DestroyManyWorkspaces(
    subdomain: String = "example"
    domain: String = "zendesk"
    "The ids of the workspaces to delete"
    ids: [Int]!
  ): String
  "#### Allowed For\n* Admins\n"
  ReorderWorkspaces(subdomain: String = "example", domain: String = "zendesk", input: ReorderWorkspaces_request_Input): String
}

type TrialAccountResponse {
  account: TrialAccountObject
}

type TrialAccountObject {
  "The name of the account"
  name: String
  "The subdomain of the account"
  subdomain: String
  "The URL of the account"
  url: String
}

type ChannelFrameworkPushResultsResponse {
  "An array of [result objects](#result-object)"
  results: [ChannelFrameworkResultObject]
}

type ChannelFrameworkResultObject {
  "The external ID of the resource, as passed in"
  external_resource_id: String
  status: ChannelFrameworkResultStatusObject
}

"The status of the import for the indicated resource"
type ChannelFrameworkResultStatusObject {
  "A code indicating the status of the import of the resource, as described in [status codes](#status-codes)"
  code: String
  "In the case of an exception, a description of the exception. Otherwise, not present."
  description: String
}

input AttachmentUpdateRequest_Input {
  attachment: AttachmentUpdateInput_Input
}

input AttachmentUpdateInput_Input {
  "If true, allows access to attachments with detected malware."
  malware_access_override: Boolean
}

"Represents empty values"
scalar Boolean

type BookmarkResponse {
  bookmark: BookmarkObject
}

input BookmarkCreateRequest_Input {
  bookmark: BookmarkInput_Input
}

input BookmarkInput_Input {
  "The id of the ticket the bookmark is for."
  ticket_id: Int
}

input BrandCreateRequest_Input {
  brand: BrandObject_Input
}

input BrandObject_Input {
  "If the brand is set as active"
  active: Boolean
  "The url of the brand"
  brand_url: String
  "The time the brand was created"
  created_at: AWSDateTime
  "Is the brand the default brand for this account"
  default: Boolean
  "If the brand has a Help Center"
  has_help_center: Boolean
  help_center_state: query_ListBrands_allOf_1_brands_items_help_center_state
  "The hostmapping to this brand, if any. Only admins view this property."
  host_mapping: String
  "The ID automatically assigned when the brand is created"
  id: Int
  "If the brand object is deleted or not"
  is_deleted: Boolean
  logo: AttachmentObject_Input
  "The name of the brand"
  name: String!
  "The signature template for a brand"
  signature_template: String
  "The subdomain of the brand"
  subdomain: String!
  "The ids of ticket forms that are available for use by a brand"
  ticket_form_ids: [Int]
  "The time of the last update of the brand"
  updated_at: AWSDateTime
  "The API url of this brand"
  url: String
}

"A file represented as an [Attachment](/api-reference/ticketing/tickets/ticket-attachments/) object"
input AttachmentObject_Input {
  "The content type of the image. Example value: \"image/png\""
  content_type: String
  "A full URL where the attachment image file can be downloaded. The file may be hosted externally so take care not to inadvertently send Zendesk authentication credentials. See [Working with url properties](/documentation/ticketing/managing-tickets/working-with-url-properties)"
  content_url: String
  "If true, the attachment has been deleted"
  deleted: Boolean
  "The name of the image file"
  file_name: String
  "The height of the image file in pixels. If height is unknown, returns null"
  height: String
  "Automatically assigned when created"
  id: Int
  "If true, the attachment is excluded from the attachment list and the attachment's URL\ncan be referenced within the comment of a ticket. Default is false"
  inline: Boolean
  "If true, you can download an attachment flagged as malware. If false, you can't download such an attachment."
  malware_access_override: Boolean
  "The result of the malware scan. There is a delay between the time the attachment is uploaded and when the malware scan is completed. Usually the scan is done within a few seconds, but high load conditions can delay the scan results. Possible values: \"malware_found\", \"malware_not_found\", \"failed_to_scan\", \"not_scanned\""
  malware_scan_result: String
  "The URL the attachment image file has been mapped to"
  mapped_content_url: String
  "The size of the image file in bytes"
  size: Int
  "A URL to access the attachment details"
  url: String
  "The width of the image file in pixels. If width is unknown, returns null"
  width: String
  "An array of attachment objects. Note that photo thumbnails do not have thumbnails"
  thumbnails: [AttachmentBaseObject_Input]
}

input AttachmentBaseObject_Input {
  "The content type of the image. Example value: \"image/png\""
  content_type: String
  "A full URL where the attachment image file can be downloaded. The file may be hosted externally so take care not to inadvertently send Zendesk authentication credentials. See [Working with url properties](/documentation/ticketing/managing-tickets/working-with-url-properties)"
  content_url: String
  "If true, the attachment has been deleted"
  deleted: Boolean
  "The name of the image file"
  file_name: String
  "The height of the image file in pixels. If height is unknown, returns null"
  height: String
  "Automatically assigned when created"
  id: Int
  "If true, the attachment is excluded from the attachment list and the attachment's URL\ncan be referenced within the comment of a ticket. Default is false"
  inline: Boolean
  "If true, you can download an attachment flagged as malware. If false, you can't download such an attachment."
  malware_access_override: Boolean
  "The result of the malware scan. There is a delay between the time the attachment is uploaded and when the malware scan is completed. Usually the scan is done within a few seconds, but high load conditions can delay the scan results. Possible values: \"malware_found\", \"malware_not_found\", \"failed_to_scan\", \"not_scanned\""
  malware_scan_result: String
  "The URL the attachment image file has been mapped to"
  mapped_content_url: String
  "The size of the image file in bytes"
  size: Int
  "A URL to access the attachment details"
  url: String
  "The width of the image file in pixels. If width is unknown, returns null"
  width: String
}

input BrandUpdateRequest_Input {
  brand: BrandObject_Input
}

union CreateTicketOrVoicemailTicket_response = TicketResponse | String_container

input TicketCreateVoicemailTicketRequest_Input {
  "Optional value such as the ID of the agent that will see the newly created ticket."
  display_to_agent: Int
  ticket: TicketCreateVoicemailTicketInput_Input
}

input TicketCreateVoicemailTicketInput_Input {
  comment: TicketCommentObject_Input
  priority: mutationInput_CreateTicketOrVoicemailTicket_input_ticket_priority
  via_id: mutationInput_CreateTicketOrVoicemailTicket_input_ticket_via_id
  voice_comment: TicketCreateVoicemailTicketVoiceCommentInput_Input
}

input TicketCommentObject_Input {
  "Attachments, if any. See [Attachment](/api-reference/ticketing/tickets/ticket-attachments/)"
  attachments: [AttachmentObject_Input]
  "The id of the ticket audit record. See [Show Audit](/api-reference/ticketing/tickets/ticket_audits/#show-audit)"
  audit_id: Int
  "The id of the comment author. See [Author id](#author-id)"
  author_id: Int
  "The comment string. See [Bodies](#bodies)"
  body: String
  "The time the comment was created"
  created_at: AWSDateTime
  "The comment formatted as HTML. See [Bodies](#bodies)"
  html_body: String
  "Automatically assigned when the comment is created"
  id: Int
  "System information (web client, IP address, etc.) and comment flags, if any. See [Comment flags](#comment-flags)"
  metadata: AWSJSON
  "The comment presented as plain text. See [Bodies](#bodies)"
  plain_body: String
  "true if a public comment; false if an internal note. The initial value set on ticket creation persists for any additional comment unless you change it"
  public: Boolean
  "`Comment` or `VoiceComment`. The JSON object for adding voice comments to tickets is different. See [Adding voice comments to tickets](/documentation/ticketing/managing-tickets/adding-voice-comments-to-tickets)"
  type: String
  "List of tokens received from [uploading files](/api-reference/ticketing/tickets/ticket-attachments/#upload-files) for comment attachments. The files are attached by creating or updating tickets with the tokens. See [Attaching files](/api-reference/ticketing/tickets/tickets/#attaching-files) in Tickets"
  uploads: [String]
  via: TicketAuditViaObject_Input
}

"Describes how the object was created. See the [Via object reference](/documentation/ticketing/reference-guides/via-object-reference)"
input TicketAuditViaObject_Input {
  "This tells you how the ticket or event was created. Examples: \"web\", \"mobile\", \"rule\", \"system\""
  channel: String
  "For some channels a source object gives more information about how or why the ticket or event was created"
  source: AWSJSON
}

"The urgency with which the ticket should be addressed."
enum mutationInput_CreateTicketOrVoicemailTicket_input_ticket_priority {
  urgent
  high
  normal
  low
}

"Required for Create Ticket operation"
enum mutationInput_CreateTicketOrVoicemailTicket_input_ticket_via_id {
  _44
  _45
  _46
}

input TicketCreateVoicemailTicketVoiceCommentInput_Input {
  "The agent who answered the call"
  answered_by_id: Int
  "Duration in seconds of the call"
  call_duration: Int
  "Incoming phone number"
  from: String
  "Location of the caller (optional)"
  location: String
  "Incoming phone number"
  recording_url: String
  "[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp of the call starting time"
  started_at: AWSDateTime
  "Dialed phone number"
  to: String
  "Transcription of the call (optional)"
  transcription_text: String
}

type TicketChatCommentRedactionResponse {
  chat_event: mutation_RedactChatCommentAttachment_chat_event
}

"Chat event object"
type mutation_RedactChatCommentAttachment_chat_event {
  "Id assigned to the chat event object"
  id: Int
  "Type of chat event"
  type: String
  value: mutation_RedactChatCommentAttachment_chat_event_value
}

"The value of the chat event object"
type mutation_RedactChatCommentAttachment_chat_event_value {
  "Id of the chat session"
  chat_id: String
  "Chat events within the chat session"
  history: [AWSJSON]
  "Id assigned to the visitor"
  visitor_id: String
}

input CustomObjectsCreateRequest_Input {
  custom_object: CustomObjectCreateInput_Input
}

input CustomObjectCreateInput_Input {
  "Unique identifier. Writable on create only"
  key: String
  "Display name for the object"
  title: String
  "Pluralized version of the object's title"
  title_pluralized: String
}

input CustomObjectFieldsCreateRequest_Input {
  custom_object_field: CustomObjectField_Input
}

input CustomObjectField_Input {
  "If true, this field is available for use"
  active: Boolean
  "The time of the last update of the ticket field"
  created_at: AWSDateTime
  "Required and presented for a custom field of type \"dropdown\". Each option is represented by an object with a `name` and `value` property"
  custom_field_options: [CustomFieldOptionObject_Input]
  "User-defined description of this field's purpose"
  description: String
  "Automatically assigned upon creation"
  id: Int
  "A unique key that identifies this custom field. This is used for updating the field and referencing in placeholders. The key must consist of only letters, numbers, and underscores. It can't be only numbers"
  key: String!
  "Ordering of the field relative to other fields"
  position: Int
  "The dynamic content placeholder, if present, or the `description` value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_description: String
  "The dynamic content placeholder, if present, or the `title` value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_title: String
  "Regular expression field only. The validation pattern for a field value to be deemed valid"
  regexp_for_validation: String
  relationship_filter: AWSJSON
  "A representation of what type of object the field references. Options are \"zen:user\", \"zen:organization\", \"zen:ticket\", and \"zen:custom_object:{key}\" where key is a custom object key. For example \"zen:custom_object:apartment\"."
  relationship_target_type: String
  "If true, only active and position values of this field can be changed"
  system: Boolean
  "Optional for custom field of type \"checkbox\"; not presented otherwise."
  tag: String
  "The title of the custom field"
  title: String!
  "The custom field type: \"checkbox\", \"date\", \"decimal\", \"dropdown\", \"integer\", [\"lookup\"](/api-reference/ticketing/lookup_relationships/lookup_relationships/), \"regexp\", \"text\", or \"textarea\""
  type: String!
  "The time of the last update of the ticket field"
  updated_at: AWSDateTime
  "The URL for this resource"
  url: String
}

input CustomFieldOptionObject_Input {
  "Automatically assigned upon creation"
  id: Int
  "Name of the dropdown option"
  name: String!
  "Position of the dropdown option"
  position: Int
  "Raw name of the dropdown option"
  raw_name: String
  "URL of the dropdown option"
  url: String
  "Value of the dropdown option"
  value: String!
}

type CustomObjectRecordsJobsResponse {
  job_status: mutation_CustomObjectRecordBulkJobs_job_status
}

type mutation_CustomObjectRecordBulkJobs_job_status {
  id: String
  message: String
  progress: Int
  results: [CustomObjectRecord]
  status: String
  total: Int
  url: String
}

input CustomObjectRecordsBulkCreateRequest_Input {
  job: mutationInput_CustomObjectRecordBulkJobs_input_job_Input
}

input mutationInput_CustomObjectRecordBulkJobs_input_job_Input {
  action: String
  "An array of record objects for job actions that create, update, or set. An array of strings for job actions that delete."
  items: [CustomObjectRecord_Input]
}

input CustomObjectRecord_Input {
  "The time the object was created"
  created_at: AWSDateTime
  "Id of a user who created the object"
  created_by_user_id: String
  custom_object_fields: AWSJSON
  "A user-defined unique identifier"
  custom_object_key: String
  "An id you can use to link custom object records to external data"
  external_id: String
  "Automatically assigned upon creation"
  id: String
  "User-defined display name for the object"
  name: String
  "The time of the last update of the object"
  updated_at: AWSDateTime
  "Id of the last user who updated the object"
  updated_by_user_id: String
  "Direct link to the specific custom object"
  url: String
}

input CustomObjectRecordsCreateRequest_Input {
  custom_object_record: CustomObjectRecord_Input
}

input CustomObjectRecordsUpsertRequest_Input {
  custom_object_record: CustomObjectRecord_Input
}

input BulkUpdateDefaultCustomStatusRequest_Input {
  "The comma-separated list of custom ticket status ids to be set as default for their status categories"
  ids: String
}

input CustomStatusCreateRequest_Input {
  custom_status: CustomStatusCreateInput_Input
}

input CustomStatusCreateInput_Input {
  "True if the custom status is set as active; inactive if false"
  active: Boolean
  "The dynamic content placeholder, if present, or the \"agent_label\" value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  agent_label: String
  "The dynamic content placeholder, if present, or the \"description\" value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  description: String
  "The dynamic content placeholder, if present, or the \"end_user_description\" value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  end_user_description: String
  "The dynamic content placeholder, if present, or the \"end_user_label\" value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  end_user_label: String
  status_category: mutationInput_CreateCustomStatus_input_custom_status_allOf_1_status_category
}

"The status category the custom ticket status belongs to"
enum mutationInput_CreateCustomStatus_input_custom_status_allOf_1_status_category {
  new
  open
  pending
  hold
  solved
}

input CustomStatusUpdateRequest_Input {
  custom_status: CustomStatusUpdateInput_Input
}

input CustomStatusUpdateInput_Input {
  "True if the custom status is set as active; inactive if false"
  active: Boolean
  "The dynamic content placeholder, if present, or the \"agent_label\" value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  agent_label: String
  "The dynamic content placeholder, if present, or the \"description\" value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  description: String
  "The dynamic content placeholder, if present, or the \"end_user_description\" value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  end_user_description: String
  "The dynamic content placeholder, if present, or the \"end_user_label\" value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  end_user_label: String
}

input TicketImportRequest_Input {
  ticket: TicketImportInput_Input
}

input TicketImportInput_Input {
  "The agent currently assigned to the ticket"
  assignee_id: Int
  "The conversation between requesters, collaborators, and agents"
  comments: [mutationInput_TicketImport_input_ticket_comments_items_Input]
  "Read-only first comment on the ticket. When [creating a ticket](#create-ticket), use `comment` to set the description. See [Description and first comment](#description-and-first-comment)"
  description: String
  "The user who requested this ticket"
  requester_id: Int
  "The value of the subject field for this ticket"
  subject: String
  "The array of tags applied to this ticket"
  tags: [String]
}

input mutationInput_TicketImport_input_ticket_comments_items_Input {
  "The comment string value"
  value: String
  "Attachments, if any. See [Attachment](/api-reference/ticketing/tickets/ticket-attachments/)"
  attachments: [AttachmentObject_Input]
  "The id of the ticket audit record. See [Show Audit](/api-reference/ticketing/tickets/ticket_audits/#show-audit)"
  audit_id: Int
  "The id of the comment author. See [Author id](#author-id)"
  author_id: Int
  "The comment string. See [Bodies](#bodies)"
  body: String
  "The time the comment was created"
  created_at: AWSDateTime
  "The comment formatted as HTML. See [Bodies](#bodies)"
  html_body: String
  "Automatically assigned when the comment is created"
  id: Int
  "System information (web client, IP address, etc.) and comment flags, if any. See [Comment flags](#comment-flags)"
  metadata: AWSJSON
  "The comment presented as plain text. See [Bodies](#bodies)"
  plain_body: String
  "true if a public comment; false if an internal note. The initial value set on ticket creation persists for any additional comment unless you change it"
  public: Boolean
  "`Comment` or `VoiceComment`. The JSON object for adding voice comments to tickets is different. See [Adding voice comments to tickets](/documentation/ticketing/managing-tickets/adding-voice-comments-to-tickets)"
  type: String
  "List of tokens received from [uploading files](/api-reference/ticketing/tickets/ticket-attachments/#upload-files) for comment attachments. The files are attached by creating or updating tickets with the tokens. See [Attaching files](/api-reference/ticketing/tickets/tickets/#attaching-files) in Tickets"
  uploads: [String]
  via: TicketAuditViaObject_Input
}

input TicketBulkImportRequest_Input {
  tickets: [TicketImportInput_Input]
}

type CreateMacro_200_response {
  macro: MacroObject
}

input CreateMacro_request_Input {
  macro: MacroInput_Input
}

input MacroInput_Input {
  "Each action describes what the macro will do"
  actions: [ActionObject_Input]!
  "Useful for determining if the macro should be displayed"
  active: Boolean
  "The description of the macro"
  description: String
  restriction: mutationInput_CreateMacro_input_macro_restriction_Input
  "The title of the macro"
  title: String!
}

input ActionObject_Input {
  "The name of a ticket field to modify"
  field: String
  "The new value of the field"
  value: String
}

"Who may access this macro. Will be null when everyone in the account can access it"
input mutationInput_CreateMacro_input_macro_restriction_Input {
  "The numeric ID of the group or user"
  id: Int
  "The numeric IDs of the groups"
  ids: [Int]
  "Allowed values are Group or User"
  type: String
}

type UpdateMacro_200_response {
  macro: MacroObject
}

input UpdateMacro_request_Input {
  macro: MacroInput_Input
}

input MacroUpdateManyInput_Input {
  macros: [mutationInput_UpdateManyMacros_input_macros_items_Input]
}

input mutationInput_UpdateManyMacros_input_macros_items_Input {
  "The active status of the macro (true or false)"
  active: Boolean
  "The ID of the macro to update"
  id: Int!
  "The new position of the macro"
  position: Int
}

input OrganizationSubscriptionCreateRequest_Input {
  organization_subscription: OrganizationSubscriptionInput_Input
}

input OrganizationSubscriptionInput_Input {
  "The ID of the organization"
  organization_id: Int
  "The ID of the user"
  user_id: Int
}

input CreateOrganizationRequest_Input {
  organization: OrganizationObject_Input!
}

input OrganizationObject_Input {
  "The time the organization was created"
  created_at: String
  "Any details obout the organization, such as the address"
  details: String
  "An array of domain names associated with this organization"
  domain_names: [String]
  "A unique external id to associate organizations to an external record. The id is case-insensitive. For example, \"company1\" and \"Company1\" are considered the same"
  external_id: String
  "New tickets from users in this organization are automatically put in this group"
  group_id: Int
  "Automatically assigned when the organization is created"
  id: Int
  "A unique name for the organization"
  name: String!
  "Any notes you have about the organization"
  notes: String
  "Custom fields for this organization. See [Custom organization fields](/api-reference/ticketing/organizations/organizations/#custom-organization-fields)"
  organization_fields: AWSJSON
  "End users in this organization are able to comment on each other's tickets"
  shared_comments: Boolean
  "End users in this organization are able to see each other's tickets"
  shared_tickets: Boolean
  "The tags of the organization"
  tags: [String]
  "The time of the last update of the organization"
  updated_at: String
  "The API url of this organization"
  url: String
}

union UpdateOrganization_response = OrganizationResponse | Errors

input OrganizationMergeRequest_Input {
  organization_merge: mutationInput_CreateOrganizationMerge_input_organization_merge_Input
}

input mutationInput_CreateOrganizationMerge_input_organization_merge_Input {
  "The id of the winning organization."
  winner_id: Int
}

input AutocompleteProblems_request_Input {
  "The text to search for"
  text: String
}

input PushNotificationDevicesRequest_Input {
  push_notification_devices: [String]
}

type TicketSkipCreation {
  skip: TicketSkipObject
}

union RecoverSuspendedTicket_response = RecoverSuspendedTicketResponse | RecoverSuspendedTicketUnprocessableContentResponse

type RecoverSuspendedTicketResponse {
  ticket: [SuspendedTicketObject]
}

type RecoverSuspendedTicketUnprocessableContentResponse {
  ticket: [SuspendedTicketObject]
}

type SuspendedTicketsAttachmentsResponse {
  upload: mutation_SuspendedTicketsAttachments_upload
}

type mutation_SuspendedTicketsAttachments_upload {
  attachments: [AttachmentObject]
  "Token for subsequent request"
  token: String
}

type SuspendedTicketsExportResponse {
  export: mutation_ExportSuspendedTickets_export
}

type mutation_ExportSuspendedTickets_export {
  status: String
  view_id: String
}

type RecoverSuspendedTicketsResponse {
  tickets: [SuspendedTicketObject]
}

input TicketCreateRequest_Input {
  ticket: TicketCreateInput_Input
}

input TicketCreateInput_Input {
  "An array of numeric IDs, emails, or objects containing name and email properties. See [Setting Collaborators](/api-reference/ticketing/tickets/tickets/#setting-collaborators). An email notification is sent to them when the ticket is updated"
  additional_collaborators: [CollaboratorObject_Input]
  "The email address of the agent to assign the ticket to"
  assignee_email: AWSEmail
  "The agent currently assigned to the ticket"
  assignee_id: Int
  "An array of the IDs of attribute values to be associated with the ticket"
  attribute_value_ids: [Int]
  "The ids of users currently CC'ed on the ticket"
  collaborator_ids: [Int]
  comment: TicketCommentObject_Input
  "Custom fields for the ticket. See [Setting custom field values](/documentation/ticketing/managing-tickets/creating-and-updating-tickets#setting-custom-field-values)"
  custom_fields: [CustomFieldObject_Input]
  "The custom ticket status id of the ticket. See [custom ticket statuses](#custom-ticket-statuses)"
  custom_status_id: Int
  "If this is a ticket of type \"task\" it has a due date.  Due date format uses [ISO 8601](http://en.wikipedia.org/wiki/ISO_8601) format."
  due_at: AWSDateTime
  "An array of objects that represent agent or end users email CCs to add or delete from the ticket. See [Setting email CCs](/documentation/ticketing/managing-tickets/creating-and-updating-tickets#setting-email-ccs)"
  email_ccs: [EmailCCObject_Input]
  "An id you can use to link Zendesk Support tickets to local records"
  external_id: String
  "An array of objects that represent agent followers to add or delete from the ticket. See [Setting followers](/documentation/ticketing/managing-tickets/creating-and-updating-tickets#setting-followers)"
  followers: [FollowerObject_Input]
  "The group this ticket is assigned to"
  group_id: Int
  "The organization of the requester. You can only specify the ID of an organization associated with the requester. See [Organization Memberships](/api-reference/ticketing/organizations/organization_memberships/)"
  organization_id: Int
  priority: mutationInput_CreateTicket_input_ticket_allOf_0_priority
  "For tickets of type \"incident\", the ID of the problem the incident is linked to"
  problem_id: Int
  "The user who requested this ticket"
  requester_id: Int
  "Optional boolean. Prevents updates with outdated ticket data (`updated_stamp` property required when true)"
  safe_update: Boolean
  "An array of the numeric IDs of sharing agreements. Note that this replaces any existing agreements"
  sharing_agreement_ids: [Int]
  status: mutationInput_CreateTicket_input_ticket_allOf_0_status
  "The value of the subject field for this ticket"
  subject: String
  "The array of tags applied to this ticket"
  tags: [String]
  type: mutationInput_CreateTicket_input_ticket_allOf_0_type
  "Datetime of last update received from API. See the safe_update property"
  updated_stamp: AWSDateTime
  "Enterprise only. The id of the brand this ticket is associated with"
  brand_id: Int
  "POST requests only. Users to add as cc's when creating a ticket. See [Setting Collaborators](/documentation/ticketing/managing-tickets/creating-and-updating-tickets#setting-collaborators)"
  collaborators: [CollaboratorObject_Input]
  "The ids of agents or end users currently CC'ed on the ticket. See [CCs and followers resources](https://support.zendesk.com/hc/en-us/articles/360020585233) in the Support Help Center"
  email_cc_ids: [Int]
  "The ids of agents currently following the ticket. See [CCs and followers resources](https://support.zendesk.com/hc/en-us/articles/360020585233)"
  follower_ids: [Int]
  "POST requests only. List of macro IDs to be recorded in the ticket audit"
  macro_ids: [Int]
  "The dynamic content placeholder, if present, or the \"subject\" value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_subject: String
  "The original recipient e-mail address of the ticket"
  recipient: String
  "The user who submitted the ticket. The submitter always becomes the author of the first comment on the ticket"
  submitter_id: Int
  "Enterprise only. The id of the ticket form to render for the ticket"
  ticket_form_id: Int
  via: ViaObject_Input
  "POST requests only. The id of a closed ticket when creating a follow-up ticket. See [Creating a follow-up ticket](/documentation/ticketing/managing-tickets/creating-and-updating-tickets#creating-a-follow-up-ticket)"
  via_followup_source_id: Int
}

input CollaboratorObject_Input {
  email: AWSEmail
  name: String
}

input CustomFieldObject_Input {
  "If true, this field is available for use"
  active: Boolean
  "The time of the last update of the ticket field"
  created_at: AWSDateTime
  "Required and presented for a custom field of type \"dropdown\". Each option is represented by an object with a `name` and `value` property"
  custom_field_options: [CustomFieldOptionObject_Input]
  "User-defined description of this field's purpose"
  description: String
  "Automatically assigned upon creation"
  id: Int
  "A unique key that identifies this custom field. This is used for updating the field and referencing in placeholders. The key must consist of only letters, numbers, and underscores. It can't be only numbers"
  key: String!
  "Ordering of the field relative to other fields"
  position: Int
  "The dynamic content placeholder, if present, or the `description` value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_description: String
  "The dynamic content placeholder, if present, or the `title` value, if not. See [Dynamic Content Items](/api-reference/ticketing/ticket-management/dynamic_content/)"
  raw_title: String
  "Regular expression field only. The validation pattern for a field value to be deemed valid"
  regexp_for_validation: String
  relationship_filter: AWSJSON
  "A representation of what type of object the field references. Options are \"zen:user\", \"zen:organization\", \"zen:ticket\", and \"zen:custom_object:{key}\" where key is a custom object key. For example \"zen:custom_object:apartment\"."
  relationship_target_type: String
  "If true, only active and position values of this field can be changed"
  system: Boolean
  "Optional for custom field of type \"checkbox\"; not presented otherwise."
  tag: String
  "The title of the custom field"
  title: String!
  "The custom field type: \"checkbox\", \"date\", \"decimal\", \"dropdown\", \"integer\", [\"lookup\"](/api-reference/ticketing/lookup_relationships/lookup_relationships/), \"regexp\", \"text\", or \"textarea\""
  type: String!
  "The time of the last update of the ticket field"
  updated_at: AWSDateTime
  "The URL for this resource"
  url: String
}

input EmailCCObject_Input {
  action: mutationInput_CreateTicket_input_ticket_allOf_0_email_ccs_items_allOf_1_action
  user_email: String
  user_id: String
  user_name: String
}

enum mutationInput_CreateTicket_input_ticket_allOf_0_email_ccs_items_allOf_1_action {
  put
  delete
}

input FollowerObject_Input {
  action: mutationInput_CreateTicket_input_ticket_allOf_0_email_ccs_items_allOf_0_action
  user_email: AWSEmail
  user_id: String
}

enum mutationInput_CreateTicket_input_ticket_allOf_0_email_ccs_items_allOf_0_action {
  put
  delete
}

"The urgency with which the ticket should be addressed."
enum mutationInput_CreateTicket_input_ticket_allOf_0_priority {
  urgent
  high
  normal
  low
}

"The state of the ticket.\n\nIf your account has activated custom ticket statuses, this is the ticket's\nstatus category. See [custom ticket statuses](#custom-ticket-statuses)."
enum mutationInput_CreateTicket_input_ticket_allOf_0_status {
  new
  open
  pending
  hold
  solved
  closed
}

"The type of this ticket."
enum mutationInput_CreateTicket_input_ticket_allOf_0_type {
  problem
  incident
  question
  task
}

"An object explaining how the ticket was created. See the [Via object reference](/documentation/ticketing/reference-guides/via-object-reference)"
input ViaObject_Input {
  "This tells you how the ticket or event was created. Examples: \"web\", \"mobile\", \"rule\", \"system\""
  channel: String
  source: query_ListSuspendedTickets_suspended_tickets_items_via_source_Input
}

"For some channels a source object gives more information about how or why the ticket or event was created"
input query_ListSuspendedTickets_suspended_tickets_items_via_source_Input {
  from: query_ListSuspendedTickets_suspended_tickets_items_via_source_from_Input
  rel: String
  to: query_ListSuspendedTickets_suspended_tickets_items_via_source_to_Input
}

input query_ListSuspendedTickets_suspended_tickets_items_via_source_from_Input {
  address: String
  id: Int
  name: String
  title: String
}

input query_ListSuspendedTickets_suspended_tickets_items_via_source_to_Input {
  address: String
  name: String
}

type TicketUpdateResponse {
  audit: AuditObject
  ticket: TicketObject
}

type AuditObject {
  author_id: Int
  created_at: AWSDateTime
  events: [mutation_UpdateTicket_audit_events_items]
  id: Int
  metadata: AWSJSON
  ticket_id: Int
  via: ViaObject
}

type mutation_UpdateTicket_audit_events_items {
  body: String
  field_name: String
  id: Int
  type: String
  value: mutation_UpdateTicket_audit_events_items_value
}

union mutation_UpdateTicket_audit_events_items_value = String_container | Int_container

input TicketUpdateRequest_Input {
  ticket: TicketUpdateInput_Input
}

input TicketUpdateInput_Input {
  "An array of numeric IDs, emails, or objects containing name and email properties. See [Setting Collaborators](/api-reference/ticketing/tickets/tickets/#setting-collaborators). An email notification is sent to them when the ticket is updated"
  additional_collaborators: [CollaboratorObject_Input]
  "The email address of the agent to assign the ticket to"
  assignee_email: AWSEmail
  "The agent currently assigned to the ticket"
  assignee_id: Int
  "An array of the IDs of attribute values to be associated with the ticket"
  attribute_value_ids: [Int]
  "The ids of users currently CC'ed on the ticket"
  collaborator_ids: [Int]
  comment: TicketCommentObject_Input
  "Custom fields for the ticket. See [Setting custom field values](/documentation/ticketing/managing-tickets/creating-and-updating-tickets#setting-custom-field-values)"
  custom_fields: [CustomFieldObject_Input]
  "The custom ticket status id of the ticket. See [custom ticket statuses](#custom-ticket-statuses)"
  custom_status_id: Int
  "If this is a ticket of type \"task\" it has a due date.  Due date format uses [ISO 8601](http://en.wikipedia.org/wiki/ISO_8601) format."
  due_at: AWSDateTime
  "An array of objects that represent agent or end users email CCs to add or delete from the ticket. See [Setting email CCs](/documentation/ticketing/managing-tickets/creating-and-updating-tickets#setting-email-ccs)"
  email_ccs: [EmailCCObject_Input]
  "An id you can use to link Zendesk Support tickets to local records"
  external_id: String
  "An array of objects that represent agent followers to add or delete from the ticket. See [Setting followers](/documentation/ticketing/managing-tickets/creating-and-updating-tickets#setting-followers)"
  followers: [FollowerObject_Input]
  "The group this ticket is assigned to"
  group_id: Int
  "The organization of the requester. You can only specify the ID of an organization associated with the requester. See [Organization Memberships](/api-reference/ticketing/organizations/organization_memberships/)"
  organization_id: Int
  priority: mutationInput_CreateTicket_input_ticket_allOf_0_priority
  "For tickets of type \"incident\", the ID of the problem the incident is linked to"
  problem_id: Int
  "The user who requested this ticket"
  requester_id: Int
  "Optional boolean. Prevents updates with outdated ticket data (`updated_stamp` property required when true)"
  safe_update: Boolean
  "An array of the numeric IDs of sharing agreements. Note that this replaces any existing agreements"
  sharing_agreement_ids: [Int]
  status: mutationInput_CreateTicket_input_ticket_allOf_0_status
  "The value of the subject field for this ticket"
  subject: String
  "The array of tags applied to this ticket"
  tags: [String]
  type: mutationInput_CreateTicket_input_ticket_allOf_0_type
  "Datetime of last update received from API. See the safe_update property"
  updated_stamp: AWSDateTime
}

input TicketMergeInput_Input {
  "Ids of tickets to merge into the target ticket"
  ids: [Int]!
  "Private comment to add to the source ticket"
  source_comment: String
  "Whether comment in source tickets are public or private"
  source_comment_is_public: Boolean
  "Private comment to add to the target ticket"
  target_comment: String
  "Whether comment in target ticket is public or private"
  target_comment_is_public: Boolean
}

input TicketsCreateRequest_Input {
  tickets: [TicketCreateInput_Input]
}

union CreateTriggerCategory_response = TriggerCategoryResponse | Errors

input CreateTriggerCategory_request_Input {
  trigger_category: AWSJSON
}

union UpdateTriggerCategory_response = TriggerCategoryResponse | Errors

input UpdateTriggerCategory_request_Input {
  trigger_category: TriggerCategoryRequest_Input
}

input TriggerCategoryRequest_Input {
  name: String
  position: Int
}

union DeleteTriggerCategory_response = Void_container | Errors

type Void_container {
  Void: Boolean
}

type BatchJobResponse {
  errors: [BatchErrorItem]
  results: mutation_BatchOperateTriggerCategories_oneOf_0_results
  status: mutation_BatchOperateTriggerCategories_oneOf_0_status
}

type BatchErrorItem {
  code: String!
  detail: String
  id: String
  links: AWSJSON
  source: AWSJSON
  status: String
  title: String!
  trigger_id: String
}

type mutation_BatchOperateTriggerCategories_oneOf_0_results {
  trigger_categories: [TriggerCategory]
  triggers: [TriggerObject]
}

enum mutation_BatchOperateTriggerCategories_oneOf_0_status {
  complete
  failed
}

input BatchJobRequest_Input {
  job: mutationInput_BatchOperateTriggerCategories_input_job_Input
}

input mutationInput_BatchOperateTriggerCategories_input_job_Input {
  action: patch_const
  items: mutationInput_BatchOperateTriggerCategories_input_job_items_Input
}

enum patch_const {
  patch
}

input mutationInput_BatchOperateTriggerCategories_input_job_items_Input {
  trigger_categories: [TriggerCategoryBatchRequest_Input]
  triggers: [TriggerBatchRequest_Input]
}

input TriggerCategoryBatchRequest_Input {
  id: String!
  position: Int!
}

input TriggerBatchRequest_Input {
  active: Boolean
  category_id: String
  id: String!
  position: Int
}

input TriggerWithCategoryRequest_Input {
  trigger: AWSJSON
}

input TriggerBulkUpdateRequest_Input {
  triggers: [TriggerBulkUpdateItem_Input]
}

input TriggerBulkUpdateItem_Input {
  "The active status of the trigger (true or false)"
  active: Boolean
  "The ID of the new category the trigger is to be moved to"
  category_id: String
  "The ID of the trigger to update"
  id: Int!
  "The new position of the trigger"
  position: Int
}

type AttachmentUploadResponse {
  upload: mutation_UploadFiles_upload
}

type mutation_UploadFiles_upload {
  attachment: AttachmentObject
  attachments: [AttachmentObject]
  "Token for subsequent request"
  token: String
}

input UserRequest_Input {
  user: UserInput_Input!
}

input UserInput_Input {
  custom_role_id: Int
  email: String!
  external_id: String
  identities: [mutationInput_CreateUser_input_user_anyOf_0_identities_items_Input]
  name: String!
  organization: mutationInput_CreateUser_input_user_anyOf_0_organization_Input
  organization_id: Int
  role: String
  password: String
  id: Int
}

input mutationInput_CreateUser_input_user_anyOf_0_identities_items_Input {
  type: String!
  value: String!
}

input mutationInput_CreateUser_input_user_anyOf_0_organization_Input {
  name: String!
}

input UsersRequest_Input {
  users: [UserInput_Input]!
}

input UpdateManyUsers_request_Input {
  UserRequest_Input: UserRequest_Input
  UsersRequest_Input: UsersRequest_Input
}

type CreateWorkspace_201_response {
  workspace: WorkspaceObject
}

input CreateWorkspace_request_Input {
  workspace: WorkspaceInput_Input
}

input WorkspaceInput_Input {
  conditions: ConditionsObject_Input
  "User-defined description of this workspace's purpose"
  description: String
  macros: [Float]
  ticket_form_id: Float
  "The title of the workspace"
  title: String
}

"An object that describes the conditions under which the automation will execute. See [Conditions reference](/documentation/ticketing/reference-guides/conditions-reference)"
input ConditionsObject_Input {
  "Logical AND. Tickets must fulfill all of the conditions to be considered matching"
  all: [ConditionObject_Input]
  "Logical OR. Tickets may satisfy any of the conditions to be considered matching"
  any: [ConditionObject_Input]
}

input ConditionObject_Input {
  "The name of a ticket field"
  field: String
  "A comparison operator"
  operator: String
  "The value of a ticket field"
  value: String
}

type UpdateWorkspace_200_response {
  workspace: WorkspaceObject
}

input UpdateWorkspace_request_Input {
  workspace: WorkspaceInput_Input
}

input ReorderWorkspaces_request_Input {
  ids: [Float]
}

scalar AWSJSON

enum HTTPMethod {
  GET
  HEAD
  POST
  PUT
  DELETE
  CONNECT
  OPTIONS
  TRACE
  PATCH
}
